// Generated by jextract

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class llama_h extends llama_h_1 {

    llama_h() {
        // Should not be called directly
    }

    private static class ggml_rope_ext_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_rope_ext_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_ext_inplace$descriptor() {
        return ggml_rope_ext_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_ext_inplace$handle() {
        return ggml_rope_ext_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_ext_inplace$address() {
        return ggml_rope_ext_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_ext_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_ext_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_ext_inplace", ctx, a, b, c, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_custom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_rope_custom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_custom$descriptor() {
        return ggml_rope_custom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_custom$handle() {
        return ggml_rope_custom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_custom$address() {
        return ggml_rope_custom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_custom(MemorySegment ctx, MemorySegment a, MemorySegment b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_custom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_custom", ctx, a, b, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_custom_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_rope_custom_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_custom_inplace$descriptor() {
        return ggml_rope_custom_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_custom_inplace$handle() {
        return ggml_rope_custom_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_custom_inplace$address() {
        return ggml_rope_custom_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_custom_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_custom_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_custom_inplace", ctx, a, b, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_yarn_corr_dims {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_rope_yarn_corr_dims");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_rope_yarn_corr_dims(int n_dims, int n_ctx_orig, float freq_base, float beta_fast, float beta_slow, float dims[2])
     * }
     */
    public static FunctionDescriptor ggml_rope_yarn_corr_dims$descriptor() {
        return ggml_rope_yarn_corr_dims.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_rope_yarn_corr_dims(int n_dims, int n_ctx_orig, float freq_base, float beta_fast, float beta_slow, float dims[2])
     * }
     */
    public static MethodHandle ggml_rope_yarn_corr_dims$handle() {
        return ggml_rope_yarn_corr_dims.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_rope_yarn_corr_dims(int n_dims, int n_ctx_orig, float freq_base, float beta_fast, float beta_slow, float dims[2])
     * }
     */
    public static MemorySegment ggml_rope_yarn_corr_dims$address() {
        return ggml_rope_yarn_corr_dims.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_rope_yarn_corr_dims(int n_dims, int n_ctx_orig, float freq_base, float beta_fast, float beta_slow, float dims[2])
     * }
     */
    public static void ggml_rope_yarn_corr_dims(int n_dims, int n_ctx_orig, float freq_base, float beta_fast, float beta_slow, MemorySegment dims) {
        var mh$ = ggml_rope_yarn_corr_dims.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_yarn_corr_dims", n_dims, n_ctx_orig, freq_base, beta_fast, beta_slow, dims);
            }
            mh$.invokeExact(n_dims, n_ctx_orig, freq_base, beta_fast, beta_slow, dims);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_ext_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_rope_ext_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_ext_back$descriptor() {
        return ggml_rope_ext_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_ext_back$handle() {
        return ggml_rope_ext_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_ext_back$address() {
        return ggml_rope_ext_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_ext_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_ext_back(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, int n_dims, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_ext_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_ext_back", ctx, a, b, c, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, n_dims, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rope_multi_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_rope_multi_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static FunctionDescriptor ggml_rope_multi_back$descriptor() {
        return ggml_rope_multi_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MethodHandle ggml_rope_multi_back$handle() {
        return ggml_rope_multi_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_multi_back$address() {
        return ggml_rope_multi_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rope_multi_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, int n_dims, int sections[4], int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow)
     * }
     */
    public static MemorySegment ggml_rope_multi_back(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, int n_dims, MemorySegment sections, int mode, int n_ctx_orig, float freq_base, float freq_scale, float ext_factor, float attn_factor, float beta_fast, float beta_slow) {
        var mh$ = ggml_rope_multi_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rope_multi_back", ctx, a, b, c, n_dims, sections, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, n_dims, sections, mode, n_ctx_orig, freq_base, freq_scale, ext_factor, attn_factor, beta_fast, beta_slow);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_clamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_clamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_clamp(struct ggml_context *ctx, struct ggml_tensor *a, float min, float max)
     * }
     */
    public static FunctionDescriptor ggml_clamp$descriptor() {
        return ggml_clamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_clamp(struct ggml_context *ctx, struct ggml_tensor *a, float min, float max)
     * }
     */
    public static MethodHandle ggml_clamp$handle() {
        return ggml_clamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_clamp(struct ggml_context *ctx, struct ggml_tensor *a, float min, float max)
     * }
     */
    public static MemorySegment ggml_clamp$address() {
        return ggml_clamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_clamp(struct ggml_context *ctx, struct ggml_tensor *a, float min, float max)
     * }
     */
    public static MemorySegment ggml_clamp(MemorySegment ctx, MemorySegment a, float min, float max) {
        var mh$ = ggml_clamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_clamp", ctx, a, min, max);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, min, max);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_im2col {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_BOOL,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_im2col");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D, enum ggml_type dst_type)
     * }
     */
    public static FunctionDescriptor ggml_im2col$descriptor() {
        return ggml_im2col.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D, enum ggml_type dst_type)
     * }
     */
    public static MethodHandle ggml_im2col$handle() {
        return ggml_im2col.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D, enum ggml_type dst_type)
     * }
     */
    public static MemorySegment ggml_im2col$address() {
        return ggml_im2col.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D, enum ggml_type dst_type)
     * }
     */
    public static MemorySegment ggml_im2col(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int s1, int p0, int p1, int d0, int d1, boolean is_2D, int dst_type) {
        var mh$ = ggml_im2col.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_im2col", ctx, a, b, s0, s1, p0, p1, d0, d1, is_2D, dst_type);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, s1, p0, p1, d0, d1, is_2D, dst_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_im2col_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_im2col_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int64_t *ne, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D)
     * }
     */
    public static FunctionDescriptor ggml_im2col_back$descriptor() {
        return ggml_im2col_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int64_t *ne, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D)
     * }
     */
    public static MethodHandle ggml_im2col_back$handle() {
        return ggml_im2col_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int64_t *ne, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D)
     * }
     */
    public static MemorySegment ggml_im2col_back$address() {
        return ggml_im2col_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_im2col_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int64_t *ne, int s0, int s1, int p0, int p1, int d0, int d1, bool is_2D)
     * }
     */
    public static MemorySegment ggml_im2col_back(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment ne, int s0, int s1, int p0, int p1, int d0, int d1, boolean is_2D) {
        var mh$ = ggml_im2col_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_im2col_back", ctx, a, b, ne, s0, s1, p0, p1, d0, d1, is_2D);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, ne, s0, s1, p0, p1, d0, d1, is_2D);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_conv_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static FunctionDescriptor ggml_conv_1d$descriptor() {
        return ggml_conv_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MethodHandle ggml_conv_1d$handle() {
        return ggml_conv_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_1d$address() {
        return ggml_conv_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_1d(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int p0, int d0) {
        var mh$ = ggml_conv_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_1d", ctx, a, b, s0, p0, d0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, p0, d0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_1d_ph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_conv_1d_ph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s, int d)
     * }
     */
    public static FunctionDescriptor ggml_conv_1d_ph$descriptor() {
        return ggml_conv_1d_ph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s, int d)
     * }
     */
    public static MethodHandle ggml_conv_1d_ph$handle() {
        return ggml_conv_1d_ph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s, int d)
     * }
     */
    public static MemorySegment ggml_conv_1d_ph$address() {
        return ggml_conv_1d_ph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s, int d)
     * }
     */
    public static MemorySegment ggml_conv_1d_ph(MemorySegment ctx, MemorySegment a, MemorySegment b, int s, int d) {
        var mh$ = ggml_conv_1d_ph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_1d_ph", ctx, a, b, s, d);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s, d);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_1d_dw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_conv_1d_dw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static FunctionDescriptor ggml_conv_1d_dw$descriptor() {
        return ggml_conv_1d_dw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MethodHandle ggml_conv_1d_dw$handle() {
        return ggml_conv_1d_dw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_1d_dw$address() {
        return ggml_conv_1d_dw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_1d_dw(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int p0, int d0) {
        var mh$ = ggml_conv_1d_dw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_1d_dw", ctx, a, b, s0, p0, d0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, p0, d0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_1d_dw_ph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_conv_1d_dw_ph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int d0)
     * }
     */
    public static FunctionDescriptor ggml_conv_1d_dw_ph$descriptor() {
        return ggml_conv_1d_dw_ph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int d0)
     * }
     */
    public static MethodHandle ggml_conv_1d_dw_ph$handle() {
        return ggml_conv_1d_dw_ph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_1d_dw_ph$address() {
        return ggml_conv_1d_dw_ph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_1d_dw_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_1d_dw_ph(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int d0) {
        var mh$ = ggml_conv_1d_dw_ph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_1d_dw_ph", ctx, a, b, s0, d0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, d0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_transpose_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_conv_transpose_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static FunctionDescriptor ggml_conv_transpose_1d$descriptor() {
        return ggml_conv_transpose_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MethodHandle ggml_conv_transpose_1d$handle() {
        return ggml_conv_transpose_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_transpose_1d$address() {
        return ggml_conv_transpose_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_1d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int p0, int d0)
     * }
     */
    public static MemorySegment ggml_conv_transpose_1d(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int p0, int d0) {
        var mh$ = ggml_conv_transpose_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_transpose_1d", ctx, a, b, s0, p0, d0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, p0, d0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_conv_2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static FunctionDescriptor ggml_conv_2d$descriptor() {
        return ggml_conv_2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MethodHandle ggml_conv_2d$handle() {
        return ggml_conv_2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MemorySegment ggml_conv_2d$address() {
        return ggml_conv_2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MemorySegment ggml_conv_2d(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int s1, int p0, int p1, int d0, int d1) {
        var mh$ = ggml_conv_2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_2d", ctx, a, b, s0, s1, p0, p1, d0, d1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, s1, p0, p1, d0, d1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_2d_sk_p0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_conv_2d_sk_p0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_sk_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_conv_2d_sk_p0$descriptor() {
        return ggml_conv_2d_sk_p0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_sk_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_conv_2d_sk_p0$handle() {
        return ggml_conv_2d_sk_p0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_sk_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_conv_2d_sk_p0$address() {
        return ggml_conv_2d_sk_p0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_sk_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_conv_2d_sk_p0(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_conv_2d_sk_p0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_2d_sk_p0", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_2d_s1_ph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_conv_2d_s1_ph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_s1_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_conv_2d_s1_ph$descriptor() {
        return ggml_conv_2d_s1_ph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_s1_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_conv_2d_s1_ph$handle() {
        return ggml_conv_2d_s1_ph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_s1_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_conv_2d_s1_ph$address() {
        return ggml_conv_2d_s1_ph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_s1_ph(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_conv_2d_s1_ph(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_conv_2d_s1_ph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_2d_s1_ph", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_2d_dw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_conv_2d_dw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static FunctionDescriptor ggml_conv_2d_dw$descriptor() {
        return ggml_conv_2d_dw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MethodHandle ggml_conv_2d_dw$handle() {
        return ggml_conv_2d_dw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MemorySegment ggml_conv_2d_dw$address() {
        return ggml_conv_2d_dw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int s0, int s1, int p0, int p1, int d0, int d1)
     * }
     */
    public static MemorySegment ggml_conv_2d_dw(MemorySegment ctx, MemorySegment a, MemorySegment b, int s0, int s1, int p0, int p1, int d0, int d1) {
        var mh$ = ggml_conv_2d_dw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_2d_dw", ctx, a, b, s0, s1, p0, p1, d0, d1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, s0, s1, p0, p1, d0, d1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_2d_dw_direct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_conv_2d_dw_direct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride0, int stride1, int pad0, int pad1, int dilation0, int dilation1)
     * }
     */
    public static FunctionDescriptor ggml_conv_2d_dw_direct$descriptor() {
        return ggml_conv_2d_dw_direct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride0, int stride1, int pad0, int pad1, int dilation0, int dilation1)
     * }
     */
    public static MethodHandle ggml_conv_2d_dw_direct$handle() {
        return ggml_conv_2d_dw_direct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride0, int stride1, int pad0, int pad1, int dilation0, int dilation1)
     * }
     */
    public static MemorySegment ggml_conv_2d_dw_direct$address() {
        return ggml_conv_2d_dw_direct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_2d_dw_direct(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride0, int stride1, int pad0, int pad1, int dilation0, int dilation1)
     * }
     */
    public static MemorySegment ggml_conv_2d_dw_direct(MemorySegment ctx, MemorySegment a, MemorySegment b, int stride0, int stride1, int pad0, int pad1, int dilation0, int dilation1) {
        var mh$ = ggml_conv_2d_dw_direct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_2d_dw_direct", ctx, a, b, stride0, stride1, pad0, pad1, dilation0, dilation1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, stride0, stride1, pad0, pad1, dilation0, dilation1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_conv_transpose_2d_p0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_conv_transpose_2d_p0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_2d_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride)
     * }
     */
    public static FunctionDescriptor ggml_conv_transpose_2d_p0$descriptor() {
        return ggml_conv_transpose_2d_p0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_2d_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride)
     * }
     */
    public static MethodHandle ggml_conv_transpose_2d_p0$handle() {
        return ggml_conv_transpose_2d_p0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_2d_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride)
     * }
     */
    public static MemorySegment ggml_conv_transpose_2d_p0$address() {
        return ggml_conv_transpose_2d_p0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_conv_transpose_2d_p0(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, int stride)
     * }
     */
    public static MemorySegment ggml_conv_transpose_2d_p0(MemorySegment ctx, MemorySegment a, MemorySegment b, int stride) {
        var mh$ = ggml_conv_transpose_2d_p0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_conv_transpose_2d_p0", ctx, a, b, stride);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, stride);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_OP_POOL_MAX = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_op_pool.GGML_OP_POOL_MAX = 0
     * }
     */
    public static int GGML_OP_POOL_MAX() {
        return GGML_OP_POOL_MAX;
    }
    private static final int GGML_OP_POOL_AVG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_op_pool.GGML_OP_POOL_AVG = 1
     * }
     */
    public static int GGML_OP_POOL_AVG() {
        return GGML_OP_POOL_AVG;
    }
    private static final int GGML_OP_POOL_COUNT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_op_pool.GGML_OP_POOL_COUNT = 2
     * }
     */
    public static int GGML_OP_POOL_COUNT() {
        return GGML_OP_POOL_COUNT;
    }

    private static class ggml_pool_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_pool_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_1d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int s0, int p0)
     * }
     */
    public static FunctionDescriptor ggml_pool_1d$descriptor() {
        return ggml_pool_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_1d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int s0, int p0)
     * }
     */
    public static MethodHandle ggml_pool_1d$handle() {
        return ggml_pool_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_1d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int s0, int p0)
     * }
     */
    public static MemorySegment ggml_pool_1d$address() {
        return ggml_pool_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_1d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int s0, int p0)
     * }
     */
    public static MemorySegment ggml_pool_1d(MemorySegment ctx, MemorySegment a, int op, int k0, int s0, int p0) {
        var mh$ = ggml_pool_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_pool_1d", ctx, a, op, k0, s0, p0);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, op, k0, s0, p0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_pool_2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_pool_2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static FunctionDescriptor ggml_pool_2d$descriptor() {
        return ggml_pool_2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static MethodHandle ggml_pool_2d$handle() {
        return ggml_pool_2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static MemorySegment ggml_pool_2d$address() {
        return ggml_pool_2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static MemorySegment ggml_pool_2d(MemorySegment ctx, MemorySegment a, int op, int k0, int k1, int s0, int s1, float p0, float p1) {
        var mh$ = ggml_pool_2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_pool_2d", ctx, a, op, k0, k1, s0, s1, p0, p1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, op, k0, k1, s0, s1, p0, p1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_pool_2d_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_pool_2d_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *af, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static FunctionDescriptor ggml_pool_2d_back$descriptor() {
        return ggml_pool_2d_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *af, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static MethodHandle ggml_pool_2d_back$handle() {
        return ggml_pool_2d_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *af, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static MemorySegment ggml_pool_2d_back$address() {
        return ggml_pool_2d_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pool_2d_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *af, enum ggml_op_pool op, int k0, int k1, int s0, int s1, float p0, float p1)
     * }
     */
    public static MemorySegment ggml_pool_2d_back(MemorySegment ctx, MemorySegment a, MemorySegment af, int op, int k0, int k1, int s0, int s1, float p0, float p1) {
        var mh$ = ggml_pool_2d_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_pool_2d_back", ctx, a, af, op, k0, k1, s0, s1, p0, p1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, af, op, k0, k1, s0, s1, p0, p1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_SCALE_MODE_NEAREST = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_scale_mode.GGML_SCALE_MODE_NEAREST = 0
     * }
     */
    public static int GGML_SCALE_MODE_NEAREST() {
        return GGML_SCALE_MODE_NEAREST;
    }
    private static final int GGML_SCALE_MODE_BILINEAR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_scale_mode.GGML_SCALE_MODE_BILINEAR = 1
     * }
     */
    public static int GGML_SCALE_MODE_BILINEAR() {
        return GGML_SCALE_MODE_BILINEAR;
    }

    private static class ggml_upscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_upscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale(struct ggml_context *ctx, struct ggml_tensor *a, int scale_factor, enum ggml_scale_mode mode)
     * }
     */
    public static FunctionDescriptor ggml_upscale$descriptor() {
        return ggml_upscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale(struct ggml_context *ctx, struct ggml_tensor *a, int scale_factor, enum ggml_scale_mode mode)
     * }
     */
    public static MethodHandle ggml_upscale$handle() {
        return ggml_upscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale(struct ggml_context *ctx, struct ggml_tensor *a, int scale_factor, enum ggml_scale_mode mode)
     * }
     */
    public static MemorySegment ggml_upscale$address() {
        return ggml_upscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale(struct ggml_context *ctx, struct ggml_tensor *a, int scale_factor, enum ggml_scale_mode mode)
     * }
     */
    public static MemorySegment ggml_upscale(MemorySegment ctx, MemorySegment a, int scale_factor, int mode) {
        var mh$ = ggml_upscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_upscale", ctx, a, scale_factor, mode);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, scale_factor, mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_upscale_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_upscale_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale_ext(struct ggml_context *ctx, struct ggml_tensor *a, int ne0, int ne1, int ne2, int ne3, enum ggml_scale_mode mode)
     * }
     */
    public static FunctionDescriptor ggml_upscale_ext$descriptor() {
        return ggml_upscale_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale_ext(struct ggml_context *ctx, struct ggml_tensor *a, int ne0, int ne1, int ne2, int ne3, enum ggml_scale_mode mode)
     * }
     */
    public static MethodHandle ggml_upscale_ext$handle() {
        return ggml_upscale_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale_ext(struct ggml_context *ctx, struct ggml_tensor *a, int ne0, int ne1, int ne2, int ne3, enum ggml_scale_mode mode)
     * }
     */
    public static MemorySegment ggml_upscale_ext$address() {
        return ggml_upscale_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_upscale_ext(struct ggml_context *ctx, struct ggml_tensor *a, int ne0, int ne1, int ne2, int ne3, enum ggml_scale_mode mode)
     * }
     */
    public static MemorySegment ggml_upscale_ext(MemorySegment ctx, MemorySegment a, int ne0, int ne1, int ne2, int ne3, int mode) {
        var mh$ = ggml_upscale_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_upscale_ext", ctx, a, ne0, ne1, ne2, ne3, mode);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, ne0, ne1, ne2, ne3, mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_pad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_pad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1, int p2, int p3)
     * }
     */
    public static FunctionDescriptor ggml_pad$descriptor() {
        return ggml_pad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1, int p2, int p3)
     * }
     */
    public static MethodHandle ggml_pad$handle() {
        return ggml_pad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1, int p2, int p3)
     * }
     */
    public static MemorySegment ggml_pad$address() {
        return ggml_pad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1, int p2, int p3)
     * }
     */
    public static MemorySegment ggml_pad(MemorySegment ctx, MemorySegment a, int p0, int p1, int p2, int p3) {
        var mh$ = ggml_pad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_pad", ctx, a, p0, p1, p2, p3);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, p0, p1, p2, p3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_pad_reflect_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_pad_reflect_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad_reflect_1d(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1)
     * }
     */
    public static FunctionDescriptor ggml_pad_reflect_1d$descriptor() {
        return ggml_pad_reflect_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad_reflect_1d(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1)
     * }
     */
    public static MethodHandle ggml_pad_reflect_1d$handle() {
        return ggml_pad_reflect_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad_reflect_1d(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1)
     * }
     */
    public static MemorySegment ggml_pad_reflect_1d$address() {
        return ggml_pad_reflect_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_pad_reflect_1d(struct ggml_context *ctx, struct ggml_tensor *a, int p0, int p1)
     * }
     */
    public static MemorySegment ggml_pad_reflect_1d(MemorySegment ctx, MemorySegment a, int p0, int p1) {
        var mh$ = ggml_pad_reflect_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_pad_reflect_1d", ctx, a, p0, p1);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, p0, p1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_timestep_embedding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_timestep_embedding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_timestep_embedding(struct ggml_context *ctx, struct ggml_tensor *timesteps, int dim, int max_period)
     * }
     */
    public static FunctionDescriptor ggml_timestep_embedding$descriptor() {
        return ggml_timestep_embedding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_timestep_embedding(struct ggml_context *ctx, struct ggml_tensor *timesteps, int dim, int max_period)
     * }
     */
    public static MethodHandle ggml_timestep_embedding$handle() {
        return ggml_timestep_embedding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_timestep_embedding(struct ggml_context *ctx, struct ggml_tensor *timesteps, int dim, int max_period)
     * }
     */
    public static MemorySegment ggml_timestep_embedding$address() {
        return ggml_timestep_embedding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_timestep_embedding(struct ggml_context *ctx, struct ggml_tensor *timesteps, int dim, int max_period)
     * }
     */
    public static MemorySegment ggml_timestep_embedding(MemorySegment ctx, MemorySegment timesteps, int dim, int max_period) {
        var mh$ = ggml_timestep_embedding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_timestep_embedding", ctx, timesteps, dim, max_period);
            }
            return (MemorySegment)mh$.invokeExact(ctx, timesteps, dim, max_period);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_SORT_ORDER_ASC = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_sort_order.GGML_SORT_ORDER_ASC = 0
     * }
     */
    public static int GGML_SORT_ORDER_ASC() {
        return GGML_SORT_ORDER_ASC;
    }
    private static final int GGML_SORT_ORDER_DESC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_sort_order.GGML_SORT_ORDER_DESC = 1
     * }
     */
    public static int GGML_SORT_ORDER_DESC() {
        return GGML_SORT_ORDER_DESC;
    }

    private static class ggml_argsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_argsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argsort(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_sort_order order)
     * }
     */
    public static FunctionDescriptor ggml_argsort$descriptor() {
        return ggml_argsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argsort(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_sort_order order)
     * }
     */
    public static MethodHandle ggml_argsort$handle() {
        return ggml_argsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argsort(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_sort_order order)
     * }
     */
    public static MemorySegment ggml_argsort$address() {
        return ggml_argsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_argsort(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_sort_order order)
     * }
     */
    public static MemorySegment ggml_argsort(MemorySegment ctx, MemorySegment a, int order) {
        var mh$ = ggml_argsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_argsort", ctx, a, order);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, order);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_arange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_arange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_arange(struct ggml_context *ctx, float start, float stop, float step)
     * }
     */
    public static FunctionDescriptor ggml_arange$descriptor() {
        return ggml_arange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_arange(struct ggml_context *ctx, float start, float stop, float step)
     * }
     */
    public static MethodHandle ggml_arange$handle() {
        return ggml_arange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_arange(struct ggml_context *ctx, float start, float stop, float step)
     * }
     */
    public static MemorySegment ggml_arange$address() {
        return ggml_arange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_arange(struct ggml_context *ctx, float start, float stop, float step)
     * }
     */
    public static MemorySegment ggml_arange(MemorySegment ctx, float start, float stop, float step) {
        var mh$ = ggml_arange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_arange", ctx, start, stop, step);
            }
            return (MemorySegment)mh$.invokeExact(ctx, start, stop, step);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_top_k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_top_k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_top_k(struct ggml_context *ctx, struct ggml_tensor *a, int k)
     * }
     */
    public static FunctionDescriptor ggml_top_k$descriptor() {
        return ggml_top_k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_top_k(struct ggml_context *ctx, struct ggml_tensor *a, int k)
     * }
     */
    public static MethodHandle ggml_top_k$handle() {
        return ggml_top_k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_top_k(struct ggml_context *ctx, struct ggml_tensor *a, int k)
     * }
     */
    public static MemorySegment ggml_top_k$address() {
        return ggml_top_k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_top_k(struct ggml_context *ctx, struct ggml_tensor *a, int k)
     * }
     */
    public static MemorySegment ggml_top_k(MemorySegment ctx, MemorySegment a, int k) {
        var mh$ = ggml_top_k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_top_k", ctx, a, k);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, k);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_flash_attn_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_flash_attn_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_ext(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *mask, float scale, float max_bias, float logit_softcap)
     * }
     */
    public static FunctionDescriptor ggml_flash_attn_ext$descriptor() {
        return ggml_flash_attn_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_ext(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *mask, float scale, float max_bias, float logit_softcap)
     * }
     */
    public static MethodHandle ggml_flash_attn_ext$handle() {
        return ggml_flash_attn_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_ext(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *mask, float scale, float max_bias, float logit_softcap)
     * }
     */
    public static MemorySegment ggml_flash_attn_ext$address() {
        return ggml_flash_attn_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_ext(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *mask, float scale, float max_bias, float logit_softcap)
     * }
     */
    public static MemorySegment ggml_flash_attn_ext(MemorySegment ctx, MemorySegment q, MemorySegment k, MemorySegment v, MemorySegment mask, float scale, float max_bias, float logit_softcap) {
        var mh$ = ggml_flash_attn_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_flash_attn_ext", ctx, q, k, v, mask, scale, max_bias, logit_softcap);
            }
            return (MemorySegment)mh$.invokeExact(ctx, q, k, v, mask, scale, max_bias, logit_softcap);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_flash_attn_ext_set_prec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_flash_attn_ext_set_prec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_flash_attn_ext_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static FunctionDescriptor ggml_flash_attn_ext_set_prec$descriptor() {
        return ggml_flash_attn_ext_set_prec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_flash_attn_ext_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static MethodHandle ggml_flash_attn_ext_set_prec$handle() {
        return ggml_flash_attn_ext_set_prec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_flash_attn_ext_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static MemorySegment ggml_flash_attn_ext_set_prec$address() {
        return ggml_flash_attn_ext_set_prec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_flash_attn_ext_set_prec(struct ggml_tensor *a, enum ggml_prec prec)
     * }
     */
    public static void ggml_flash_attn_ext_set_prec(MemorySegment a, int prec) {
        var mh$ = ggml_flash_attn_ext_set_prec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_flash_attn_ext_set_prec", a, prec);
            }
            mh$.invokeExact(a, prec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_flash_attn_ext_get_prec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_flash_attn_ext_get_prec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_prec ggml_flash_attn_ext_get_prec(const struct ggml_tensor *a)
     * }
     */
    public static FunctionDescriptor ggml_flash_attn_ext_get_prec$descriptor() {
        return ggml_flash_attn_ext_get_prec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_prec ggml_flash_attn_ext_get_prec(const struct ggml_tensor *a)
     * }
     */
    public static MethodHandle ggml_flash_attn_ext_get_prec$handle() {
        return ggml_flash_attn_ext_get_prec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_prec ggml_flash_attn_ext_get_prec(const struct ggml_tensor *a)
     * }
     */
    public static MemorySegment ggml_flash_attn_ext_get_prec$address() {
        return ggml_flash_attn_ext_get_prec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_prec ggml_flash_attn_ext_get_prec(const struct ggml_tensor *a)
     * }
     */
    public static int ggml_flash_attn_ext_get_prec(MemorySegment a) {
        var mh$ = ggml_flash_attn_ext_get_prec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_flash_attn_ext_get_prec", a);
            }
            return (int)mh$.invokeExact(a);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_flash_attn_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_flash_attn_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_back(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *d, bool masked)
     * }
     */
    public static FunctionDescriptor ggml_flash_attn_back$descriptor() {
        return ggml_flash_attn_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_back(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *d, bool masked)
     * }
     */
    public static MethodHandle ggml_flash_attn_back$handle() {
        return ggml_flash_attn_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_back(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *d, bool masked)
     * }
     */
    public static MemorySegment ggml_flash_attn_back$address() {
        return ggml_flash_attn_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_flash_attn_back(struct ggml_context *ctx, struct ggml_tensor *q, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *d, bool masked)
     * }
     */
    public static MemorySegment ggml_flash_attn_back(MemorySegment ctx, MemorySegment q, MemorySegment k, MemorySegment v, MemorySegment d, boolean masked) {
        var mh$ = ggml_flash_attn_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_flash_attn_back", ctx, q, k, v, d, masked);
            }
            return (MemorySegment)mh$.invokeExact(ctx, q, k, v, d, masked);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_ssm_conv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_ssm_conv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_conv(struct ggml_context *ctx, struct ggml_tensor *sx, struct ggml_tensor *c)
     * }
     */
    public static FunctionDescriptor ggml_ssm_conv$descriptor() {
        return ggml_ssm_conv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_conv(struct ggml_context *ctx, struct ggml_tensor *sx, struct ggml_tensor *c)
     * }
     */
    public static MethodHandle ggml_ssm_conv$handle() {
        return ggml_ssm_conv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_conv(struct ggml_context *ctx, struct ggml_tensor *sx, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_ssm_conv$address() {
        return ggml_ssm_conv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_conv(struct ggml_context *ctx, struct ggml_tensor *sx, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_ssm_conv(MemorySegment ctx, MemorySegment sx, MemorySegment c) {
        var mh$ = ggml_ssm_conv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_ssm_conv", ctx, sx, c);
            }
            return (MemorySegment)mh$.invokeExact(ctx, sx, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_ssm_scan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_ssm_scan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_scan(struct ggml_context *ctx, struct ggml_tensor *s, struct ggml_tensor *x, struct ggml_tensor *dt, struct ggml_tensor *A, struct ggml_tensor *B, struct ggml_tensor *C)
     * }
     */
    public static FunctionDescriptor ggml_ssm_scan$descriptor() {
        return ggml_ssm_scan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_scan(struct ggml_context *ctx, struct ggml_tensor *s, struct ggml_tensor *x, struct ggml_tensor *dt, struct ggml_tensor *A, struct ggml_tensor *B, struct ggml_tensor *C)
     * }
     */
    public static MethodHandle ggml_ssm_scan$handle() {
        return ggml_ssm_scan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_scan(struct ggml_context *ctx, struct ggml_tensor *s, struct ggml_tensor *x, struct ggml_tensor *dt, struct ggml_tensor *A, struct ggml_tensor *B, struct ggml_tensor *C)
     * }
     */
    public static MemorySegment ggml_ssm_scan$address() {
        return ggml_ssm_scan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_ssm_scan(struct ggml_context *ctx, struct ggml_tensor *s, struct ggml_tensor *x, struct ggml_tensor *dt, struct ggml_tensor *A, struct ggml_tensor *B, struct ggml_tensor *C)
     * }
     */
    public static MemorySegment ggml_ssm_scan(MemorySegment ctx, MemorySegment s, MemorySegment x, MemorySegment dt, MemorySegment A, MemorySegment B, MemorySegment C) {
        var mh$ = ggml_ssm_scan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_ssm_scan", ctx, s, x, dt, A, B, C);
            }
            return (MemorySegment)mh$.invokeExact(ctx, s, x, dt, A, B, C);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_win_part {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_win_part");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_part(struct ggml_context *ctx, struct ggml_tensor *a, int w)
     * }
     */
    public static FunctionDescriptor ggml_win_part$descriptor() {
        return ggml_win_part.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_part(struct ggml_context *ctx, struct ggml_tensor *a, int w)
     * }
     */
    public static MethodHandle ggml_win_part$handle() {
        return ggml_win_part.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_part(struct ggml_context *ctx, struct ggml_tensor *a, int w)
     * }
     */
    public static MemorySegment ggml_win_part$address() {
        return ggml_win_part.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_part(struct ggml_context *ctx, struct ggml_tensor *a, int w)
     * }
     */
    public static MemorySegment ggml_win_part(MemorySegment ctx, MemorySegment a, int w) {
        var mh$ = ggml_win_part.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_win_part", ctx, a, w);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, w);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_win_unpart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_win_unpart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_unpart(struct ggml_context *ctx, struct ggml_tensor *a, int w0, int h0, int w)
     * }
     */
    public static FunctionDescriptor ggml_win_unpart$descriptor() {
        return ggml_win_unpart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_unpart(struct ggml_context *ctx, struct ggml_tensor *a, int w0, int h0, int w)
     * }
     */
    public static MethodHandle ggml_win_unpart$handle() {
        return ggml_win_unpart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_unpart(struct ggml_context *ctx, struct ggml_tensor *a, int w0, int h0, int w)
     * }
     */
    public static MemorySegment ggml_win_unpart$address() {
        return ggml_win_unpart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_win_unpart(struct ggml_context *ctx, struct ggml_tensor *a, int w0, int h0, int w)
     * }
     */
    public static MemorySegment ggml_win_unpart(MemorySegment ctx, MemorySegment a, int w0, int h0, int w) {
        var mh$ = ggml_win_unpart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_win_unpart", ctx, a, w0, h0, w);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, w0, h0, w);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_unary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_unary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static FunctionDescriptor ggml_unary$descriptor() {
        return ggml_unary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static MethodHandle ggml_unary$handle() {
        return ggml_unary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static MemorySegment ggml_unary$address() {
        return ggml_unary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static MemorySegment ggml_unary(MemorySegment ctx, MemorySegment a, int op) {
        var mh$ = ggml_unary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_unary", ctx, a, op);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, op);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_unary_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_unary_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary_inplace(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static FunctionDescriptor ggml_unary_inplace$descriptor() {
        return ggml_unary_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary_inplace(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static MethodHandle ggml_unary_inplace$handle() {
        return ggml_unary_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary_inplace(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static MemorySegment ggml_unary_inplace$address() {
        return ggml_unary_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_unary_inplace(struct ggml_context *ctx, struct ggml_tensor *a, enum ggml_unary_op op)
     * }
     */
    public static MemorySegment ggml_unary_inplace(MemorySegment ctx, MemorySegment a, int op) {
        var mh$ = ggml_unary_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_unary_inplace", ctx, a, op);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, op);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_rel_pos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_get_rel_pos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, int qh, int kh)
     * }
     */
    public static FunctionDescriptor ggml_get_rel_pos$descriptor() {
        return ggml_get_rel_pos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, int qh, int kh)
     * }
     */
    public static MethodHandle ggml_get_rel_pos$handle() {
        return ggml_get_rel_pos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, int qh, int kh)
     * }
     */
    public static MemorySegment ggml_get_rel_pos$address() {
        return ggml_get_rel_pos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_get_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, int qh, int kh)
     * }
     */
    public static MemorySegment ggml_get_rel_pos(MemorySegment ctx, MemorySegment a, int qh, int kh) {
        var mh$ = ggml_get_rel_pos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_rel_pos", ctx, a, qh, kh);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, qh, kh);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_add_rel_pos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_add_rel_pos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static FunctionDescriptor ggml_add_rel_pos$descriptor() {
        return ggml_add_rel_pos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static MethodHandle ggml_add_rel_pos$handle() {
        return ggml_add_rel_pos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static MemorySegment ggml_add_rel_pos$address() {
        return ggml_add_rel_pos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static MemorySegment ggml_add_rel_pos(MemorySegment ctx, MemorySegment a, MemorySegment pw, MemorySegment ph) {
        var mh$ = ggml_add_rel_pos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_add_rel_pos", ctx, a, pw, ph);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, pw, ph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_add_rel_pos_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_add_rel_pos_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static FunctionDescriptor ggml_add_rel_pos_inplace$descriptor() {
        return ggml_add_rel_pos_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static MethodHandle ggml_add_rel_pos_inplace$handle() {
        return ggml_add_rel_pos_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static MemorySegment ggml_add_rel_pos_inplace$address() {
        return ggml_add_rel_pos_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_add_rel_pos_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *pw, struct ggml_tensor *ph)
     * }
     */
    public static MemorySegment ggml_add_rel_pos_inplace(MemorySegment ctx, MemorySegment a, MemorySegment pw, MemorySegment ph) {
        var mh$ = ggml_add_rel_pos_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_add_rel_pos_inplace", ctx, a, pw, ph);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, pw, ph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rwkv_wkv6 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_rwkv_wkv6");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv6(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *r, struct ggml_tensor *tf, struct ggml_tensor *td, struct ggml_tensor *state)
     * }
     */
    public static FunctionDescriptor ggml_rwkv_wkv6$descriptor() {
        return ggml_rwkv_wkv6.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv6(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *r, struct ggml_tensor *tf, struct ggml_tensor *td, struct ggml_tensor *state)
     * }
     */
    public static MethodHandle ggml_rwkv_wkv6$handle() {
        return ggml_rwkv_wkv6.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv6(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *r, struct ggml_tensor *tf, struct ggml_tensor *td, struct ggml_tensor *state)
     * }
     */
    public static MemorySegment ggml_rwkv_wkv6$address() {
        return ggml_rwkv_wkv6.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv6(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *r, struct ggml_tensor *tf, struct ggml_tensor *td, struct ggml_tensor *state)
     * }
     */
    public static MemorySegment ggml_rwkv_wkv6(MemorySegment ctx, MemorySegment k, MemorySegment v, MemorySegment r, MemorySegment tf, MemorySegment td, MemorySegment state) {
        var mh$ = ggml_rwkv_wkv6.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rwkv_wkv6", ctx, k, v, r, tf, td, state);
            }
            return (MemorySegment)mh$.invokeExact(ctx, k, v, r, tf, td, state);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gated_linear_attn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_gated_linear_attn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gated_linear_attn(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *q, struct ggml_tensor *g, struct ggml_tensor *state, float scale)
     * }
     */
    public static FunctionDescriptor ggml_gated_linear_attn$descriptor() {
        return ggml_gated_linear_attn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gated_linear_attn(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *q, struct ggml_tensor *g, struct ggml_tensor *state, float scale)
     * }
     */
    public static MethodHandle ggml_gated_linear_attn$handle() {
        return ggml_gated_linear_attn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gated_linear_attn(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *q, struct ggml_tensor *g, struct ggml_tensor *state, float scale)
     * }
     */
    public static MemorySegment ggml_gated_linear_attn$address() {
        return ggml_gated_linear_attn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_gated_linear_attn(struct ggml_context *ctx, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *q, struct ggml_tensor *g, struct ggml_tensor *state, float scale)
     * }
     */
    public static MemorySegment ggml_gated_linear_attn(MemorySegment ctx, MemorySegment k, MemorySegment v, MemorySegment q, MemorySegment g, MemorySegment state, float scale) {
        var mh$ = ggml_gated_linear_attn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gated_linear_attn", ctx, k, v, q, g, state, scale);
            }
            return (MemorySegment)mh$.invokeExact(ctx, k, v, q, g, state, scale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_rwkv_wkv7 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_rwkv_wkv7");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv7(struct ggml_context *ctx, struct ggml_tensor *r, struct ggml_tensor *w, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *state)
     * }
     */
    public static FunctionDescriptor ggml_rwkv_wkv7$descriptor() {
        return ggml_rwkv_wkv7.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv7(struct ggml_context *ctx, struct ggml_tensor *r, struct ggml_tensor *w, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *state)
     * }
     */
    public static MethodHandle ggml_rwkv_wkv7$handle() {
        return ggml_rwkv_wkv7.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv7(struct ggml_context *ctx, struct ggml_tensor *r, struct ggml_tensor *w, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *state)
     * }
     */
    public static MemorySegment ggml_rwkv_wkv7$address() {
        return ggml_rwkv_wkv7.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_rwkv_wkv7(struct ggml_context *ctx, struct ggml_tensor *r, struct ggml_tensor *w, struct ggml_tensor *k, struct ggml_tensor *v, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *state)
     * }
     */
    public static MemorySegment ggml_rwkv_wkv7(MemorySegment ctx, MemorySegment r, MemorySegment w, MemorySegment k, MemorySegment v, MemorySegment a, MemorySegment b, MemorySegment state) {
        var mh$ = ggml_rwkv_wkv7.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_rwkv_wkv7", ctx, r, w, k, v, a, b, state);
            }
            return (MemorySegment)mh$.invokeExact(ctx, r, w, k, v, a, b, state);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_map_custom1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_map_custom1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_map_custom1$descriptor() {
        return ggml_map_custom1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_map_custom1$handle() {
        return ggml_map_custom1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom1$address() {
        return ggml_map_custom1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom1(MemorySegment ctx, MemorySegment a, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_map_custom1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_map_custom1", ctx, a, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, fun, n_tasks, userdata);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_map_custom1_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_map_custom1_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_map_custom1_inplace$descriptor() {
        return ggml_map_custom1_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_map_custom1_inplace$handle() {
        return ggml_map_custom1_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom1_inplace$address() {
        return ggml_map_custom1_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom1_inplace(struct ggml_context *ctx, struct ggml_tensor *a, ggml_custom1_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom1_inplace(MemorySegment ctx, MemorySegment a, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_map_custom1_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_map_custom1_inplace", ctx, a, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, fun, n_tasks, userdata);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_map_custom2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_map_custom2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_map_custom2$descriptor() {
        return ggml_map_custom2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_map_custom2$handle() {
        return ggml_map_custom2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom2$address() {
        return ggml_map_custom2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom2(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_map_custom2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_map_custom2", ctx, a, b, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, fun, n_tasks, userdata);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_map_custom2_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_map_custom2_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_map_custom2_inplace$descriptor() {
        return ggml_map_custom2_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_map_custom2_inplace$handle() {
        return ggml_map_custom2_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom2_inplace$address() {
        return ggml_map_custom2_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom2_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, ggml_custom2_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom2_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_map_custom2_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_map_custom2_inplace", ctx, a, b, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, fun, n_tasks, userdata);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_map_custom3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_map_custom3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_map_custom3$descriptor() {
        return ggml_map_custom3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_map_custom3$handle() {
        return ggml_map_custom3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom3$address() {
        return ggml_map_custom3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom3(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_map_custom3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_map_custom3", ctx, a, b, c, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, fun, n_tasks, userdata);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_map_custom3_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_map_custom3_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_map_custom3_inplace$descriptor() {
        return ggml_map_custom3_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_map_custom3_inplace$handle() {
        return ggml_map_custom3_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom3_inplace$address() {
        return ggml_map_custom3_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_map_custom3_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c, ggml_custom3_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_map_custom3_inplace(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_map_custom3_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_map_custom3_inplace", ctx, a, b, c, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c, fun, n_tasks, userdata);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_custom_4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_LONG_LONG,
            llama_h.C_LONG_LONG,
            llama_h.C_LONG_LONG,
            llama_h.C_LONG_LONG,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_custom_4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_custom_4d$descriptor() {
        return ggml_custom_4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_custom_4d$handle() {
        return ggml_custom_4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_custom_4d$address() {
        return ggml_custom_4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_4d(struct ggml_context *ctx, enum ggml_type type, int64_t ne0, int64_t ne1, int64_t ne2, int64_t ne3, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_custom_4d(MemorySegment ctx, int type, long ne0, long ne1, long ne2, long ne3, MemorySegment args, int n_args, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_custom_4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_custom_4d", ctx, type, ne0, ne1, ne2, ne3, args, n_args, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, type, ne0, ne1, ne2, ne3, args, n_args, fun, n_tasks, userdata);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_custom_inplace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_custom_inplace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_custom_inplace$descriptor() {
        return ggml_custom_inplace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MethodHandle ggml_custom_inplace$handle() {
        return ggml_custom_inplace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_custom_inplace$address() {
        return ggml_custom_inplace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_custom_inplace(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor **args, int n_args, ggml_custom_op_t fun, int n_tasks, void *userdata)
     * }
     */
    public static MemorySegment ggml_custom_inplace(MemorySegment ctx, MemorySegment a, MemorySegment args, int n_args, MemorySegment fun, int n_tasks, MemorySegment userdata) {
        var mh$ = ggml_custom_inplace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_custom_inplace", ctx, a, args, n_args, fun, n_tasks, userdata);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, args, n_args, fun, n_tasks, userdata);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cross_entropy_loss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cross_entropy_loss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static FunctionDescriptor ggml_cross_entropy_loss$descriptor() {
        return ggml_cross_entropy_loss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MethodHandle ggml_cross_entropy_loss$handle() {
        return ggml_cross_entropy_loss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_cross_entropy_loss$address() {
        return ggml_cross_entropy_loss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b)
     * }
     */
    public static MemorySegment ggml_cross_entropy_loss(MemorySegment ctx, MemorySegment a, MemorySegment b) {
        var mh$ = ggml_cross_entropy_loss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cross_entropy_loss", ctx, a, b);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cross_entropy_loss_back {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cross_entropy_loss_back");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static FunctionDescriptor ggml_cross_entropy_loss_back$descriptor() {
        return ggml_cross_entropy_loss_back.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MethodHandle ggml_cross_entropy_loss_back$handle() {
        return ggml_cross_entropy_loss_back.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_cross_entropy_loss_back$address() {
        return ggml_cross_entropy_loss_back.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_cross_entropy_loss_back(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *b, struct ggml_tensor *c)
     * }
     */
    public static MemorySegment ggml_cross_entropy_loss_back(MemorySegment ctx, MemorySegment a, MemorySegment b, MemorySegment c) {
        var mh$ = ggml_cross_entropy_loss_back.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cross_entropy_loss_back", ctx, a, b, c);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, b, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_step_adamw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_step_adamw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_step_adamw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *grad, struct ggml_tensor *m, struct ggml_tensor *v, struct ggml_tensor *adamw_params)
     * }
     */
    public static FunctionDescriptor ggml_opt_step_adamw$descriptor() {
        return ggml_opt_step_adamw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_step_adamw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *grad, struct ggml_tensor *m, struct ggml_tensor *v, struct ggml_tensor *adamw_params)
     * }
     */
    public static MethodHandle ggml_opt_step_adamw$handle() {
        return ggml_opt_step_adamw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_step_adamw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *grad, struct ggml_tensor *m, struct ggml_tensor *v, struct ggml_tensor *adamw_params)
     * }
     */
    public static MemorySegment ggml_opt_step_adamw$address() {
        return ggml_opt_step_adamw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_step_adamw(struct ggml_context *ctx, struct ggml_tensor *a, struct ggml_tensor *grad, struct ggml_tensor *m, struct ggml_tensor *v, struct ggml_tensor *adamw_params)
     * }
     */
    public static MemorySegment ggml_opt_step_adamw(MemorySegment ctx, MemorySegment a, MemorySegment grad, MemorySegment m, MemorySegment v, MemorySegment adamw_params) {
        var mh$ = ggml_opt_step_adamw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_step_adamw", ctx, a, grad, m, v, adamw_params);
            }
            return (MemorySegment)mh$.invokeExact(ctx, a, grad, m, v, adamw_params);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_build_forward_expand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_build_forward_expand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_build_forward_expand(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_build_forward_expand$descriptor() {
        return ggml_build_forward_expand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_build_forward_expand(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_build_forward_expand$handle() {
        return ggml_build_forward_expand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_build_forward_expand(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_build_forward_expand$address() {
        return ggml_build_forward_expand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_build_forward_expand(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static void ggml_build_forward_expand(MemorySegment cgraph, MemorySegment tensor) {
        var mh$ = ggml_build_forward_expand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_build_forward_expand", cgraph, tensor);
            }
            mh$.invokeExact(cgraph, tensor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_build_backward_expand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_build_backward_expand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_build_backward_expand(struct ggml_context *ctx, struct ggml_cgraph *cgraph, struct ggml_tensor **grad_accs)
     * }
     */
    public static FunctionDescriptor ggml_build_backward_expand$descriptor() {
        return ggml_build_backward_expand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_build_backward_expand(struct ggml_context *ctx, struct ggml_cgraph *cgraph, struct ggml_tensor **grad_accs)
     * }
     */
    public static MethodHandle ggml_build_backward_expand$handle() {
        return ggml_build_backward_expand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_build_backward_expand(struct ggml_context *ctx, struct ggml_cgraph *cgraph, struct ggml_tensor **grad_accs)
     * }
     */
    public static MemorySegment ggml_build_backward_expand$address() {
        return ggml_build_backward_expand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_build_backward_expand(struct ggml_context *ctx, struct ggml_cgraph *cgraph, struct ggml_tensor **grad_accs)
     * }
     */
    public static void ggml_build_backward_expand(MemorySegment ctx, MemorySegment cgraph, MemorySegment grad_accs) {
        var mh$ = ggml_build_backward_expand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_build_backward_expand", ctx, cgraph, grad_accs);
            }
            mh$.invokeExact(ctx, cgraph, grad_accs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_graph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_new_graph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph(struct ggml_context *ctx)
     * }
     */
    public static FunctionDescriptor ggml_new_graph$descriptor() {
        return ggml_new_graph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph(struct ggml_context *ctx)
     * }
     */
    public static MethodHandle ggml_new_graph$handle() {
        return ggml_new_graph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph(struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_new_graph$address() {
        return ggml_new_graph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph(struct ggml_context *ctx)
     * }
     */
    public static MemorySegment ggml_new_graph(MemorySegment ctx) {
        var mh$ = ggml_new_graph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_graph", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_graph_custom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_new_graph_custom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph_custom(struct ggml_context *ctx, size_t size, bool grads)
     * }
     */
    public static FunctionDescriptor ggml_new_graph_custom$descriptor() {
        return ggml_new_graph_custom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph_custom(struct ggml_context *ctx, size_t size, bool grads)
     * }
     */
    public static MethodHandle ggml_new_graph_custom$handle() {
        return ggml_new_graph_custom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph_custom(struct ggml_context *ctx, size_t size, bool grads)
     * }
     */
    public static MemorySegment ggml_new_graph_custom$address() {
        return ggml_new_graph_custom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_new_graph_custom(struct ggml_context *ctx, size_t size, bool grads)
     * }
     */
    public static MemorySegment ggml_new_graph_custom(MemorySegment ctx, long size, boolean grads) {
        var mh$ = ggml_new_graph_custom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_graph_custom", ctx, size, grads);
            }
            return (MemorySegment)mh$.invokeExact(ctx, size, grads);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_graph_dup(struct ggml_context *ctx, struct ggml_cgraph *cgraph, bool force_grads)
     * }
     */
    public static FunctionDescriptor ggml_graph_dup$descriptor() {
        return ggml_graph_dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_graph_dup(struct ggml_context *ctx, struct ggml_cgraph *cgraph, bool force_grads)
     * }
     */
    public static MethodHandle ggml_graph_dup$handle() {
        return ggml_graph_dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_graph_dup(struct ggml_context *ctx, struct ggml_cgraph *cgraph, bool force_grads)
     * }
     */
    public static MemorySegment ggml_graph_dup$address() {
        return ggml_graph_dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_cgraph *ggml_graph_dup(struct ggml_context *ctx, struct ggml_cgraph *cgraph, bool force_grads)
     * }
     */
    public static MemorySegment ggml_graph_dup(MemorySegment ctx, MemorySegment cgraph, boolean force_grads) {
        var mh$ = ggml_graph_dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_dup", ctx, cgraph, force_grads);
            }
            return (MemorySegment)mh$.invokeExact(ctx, cgraph, force_grads);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_cpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_cpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_graph_cpy(struct ggml_cgraph *src, struct ggml_cgraph *dst)
     * }
     */
    public static FunctionDescriptor ggml_graph_cpy$descriptor() {
        return ggml_graph_cpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_graph_cpy(struct ggml_cgraph *src, struct ggml_cgraph *dst)
     * }
     */
    public static MethodHandle ggml_graph_cpy$handle() {
        return ggml_graph_cpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_graph_cpy(struct ggml_cgraph *src, struct ggml_cgraph *dst)
     * }
     */
    public static MemorySegment ggml_graph_cpy$address() {
        return ggml_graph_cpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_graph_cpy(struct ggml_cgraph *src, struct ggml_cgraph *dst)
     * }
     */
    public static void ggml_graph_cpy(MemorySegment src, MemorySegment dst) {
        var mh$ = ggml_graph_cpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_cpy", src, dst);
            }
            mh$.invokeExact(src, dst);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_graph_reset(struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_graph_reset$descriptor() {
        return ggml_graph_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_graph_reset(struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_graph_reset$handle() {
        return ggml_graph_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_graph_reset(struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_reset$address() {
        return ggml_graph_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_graph_reset(struct ggml_cgraph *cgraph)
     * }
     */
    public static void ggml_graph_reset(MemorySegment cgraph) {
        var mh$ = ggml_graph_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_reset", cgraph);
            }
            mh$.invokeExact(cgraph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_graph_clear(struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_graph_clear$descriptor() {
        return ggml_graph_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_graph_clear(struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_graph_clear$handle() {
        return ggml_graph_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_graph_clear(struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_clear$address() {
        return ggml_graph_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_graph_clear(struct ggml_cgraph *cgraph)
     * }
     */
    public static void ggml_graph_clear(MemorySegment cgraph) {
        var mh$ = ggml_graph_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_clear", cgraph);
            }
            mh$.invokeExact(cgraph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_graph_size(struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_graph_size$descriptor() {
        return ggml_graph_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_graph_size(struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_graph_size$handle() {
        return ggml_graph_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_graph_size(struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_size$address() {
        return ggml_graph_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_graph_size(struct ggml_cgraph *cgraph)
     * }
     */
    public static int ggml_graph_size(MemorySegment cgraph) {
        var mh$ = ggml_graph_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_size", cgraph);
            }
            return (int)mh$.invokeExact(cgraph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_node");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_node(struct ggml_cgraph *cgraph, int i)
     * }
     */
    public static FunctionDescriptor ggml_graph_node$descriptor() {
        return ggml_graph_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_node(struct ggml_cgraph *cgraph, int i)
     * }
     */
    public static MethodHandle ggml_graph_node$handle() {
        return ggml_graph_node.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_node(struct ggml_cgraph *cgraph, int i)
     * }
     */
    public static MemorySegment ggml_graph_node$address() {
        return ggml_graph_node.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_node(struct ggml_cgraph *cgraph, int i)
     * }
     */
    public static MemorySegment ggml_graph_node(MemorySegment cgraph, int i) {
        var mh$ = ggml_graph_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_node", cgraph, i);
            }
            return (MemorySegment)mh$.invokeExact(cgraph, i);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_nodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_nodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor **ggml_graph_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_graph_nodes$descriptor() {
        return ggml_graph_nodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor **ggml_graph_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_graph_nodes$handle() {
        return ggml_graph_nodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor **ggml_graph_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_nodes$address() {
        return ggml_graph_nodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor **ggml_graph_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_nodes(MemorySegment cgraph) {
        var mh$ = ggml_graph_nodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_nodes", cgraph);
            }
            return (MemorySegment)mh$.invokeExact(cgraph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_n_nodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_n_nodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_graph_n_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_graph_n_nodes$descriptor() {
        return ggml_graph_n_nodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_graph_n_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_graph_n_nodes$handle() {
        return ggml_graph_n_nodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_graph_n_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_n_nodes$address() {
        return ggml_graph_n_nodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_graph_n_nodes(struct ggml_cgraph *cgraph)
     * }
     */
    public static int ggml_graph_n_nodes(MemorySegment cgraph) {
        var mh$ = ggml_graph_n_nodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_n_nodes", cgraph);
            }
            return (int)mh$.invokeExact(cgraph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_add_node {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_add_node");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_graph_add_node(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_graph_add_node$descriptor() {
        return ggml_graph_add_node.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_graph_add_node(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_graph_add_node$handle() {
        return ggml_graph_add_node.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_graph_add_node(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_graph_add_node$address() {
        return ggml_graph_add_node.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_graph_add_node(struct ggml_cgraph *cgraph, struct ggml_tensor *tensor)
     * }
     */
    public static void ggml_graph_add_node(MemorySegment cgraph, MemorySegment tensor) {
        var mh$ = ggml_graph_add_node.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_add_node", cgraph, tensor);
            }
            mh$.invokeExact(cgraph, tensor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_overhead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_overhead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead(void)
     * }
     */
    public static FunctionDescriptor ggml_graph_overhead$descriptor() {
        return ggml_graph_overhead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead(void)
     * }
     */
    public static MethodHandle ggml_graph_overhead$handle() {
        return ggml_graph_overhead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead(void)
     * }
     */
    public static MemorySegment ggml_graph_overhead$address() {
        return ggml_graph_overhead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead(void)
     * }
     */
    public static long ggml_graph_overhead() {
        var mh$ = ggml_graph_overhead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_overhead");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_overhead_custom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_LONG,
            llama_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_overhead_custom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead_custom(size_t size, bool grads)
     * }
     */
    public static FunctionDescriptor ggml_graph_overhead_custom$descriptor() {
        return ggml_graph_overhead_custom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead_custom(size_t size, bool grads)
     * }
     */
    public static MethodHandle ggml_graph_overhead_custom$handle() {
        return ggml_graph_overhead_custom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead_custom(size_t size, bool grads)
     * }
     */
    public static MemorySegment ggml_graph_overhead_custom$address() {
        return ggml_graph_overhead_custom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_graph_overhead_custom(size_t size, bool grads)
     * }
     */
    public static long ggml_graph_overhead_custom(long size, boolean grads) {
        var mh$ = ggml_graph_overhead_custom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_overhead_custom", size, grads);
            }
            return (long)mh$.invokeExact(size, grads);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_get_tensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_get_tensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_tensor(const struct ggml_cgraph *cgraph, const char *name)
     * }
     */
    public static FunctionDescriptor ggml_graph_get_tensor$descriptor() {
        return ggml_graph_get_tensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_tensor(const struct ggml_cgraph *cgraph, const char *name)
     * }
     */
    public static MethodHandle ggml_graph_get_tensor$handle() {
        return ggml_graph_get_tensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_tensor(const struct ggml_cgraph *cgraph, const char *name)
     * }
     */
    public static MemorySegment ggml_graph_get_tensor$address() {
        return ggml_graph_get_tensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_tensor(const struct ggml_cgraph *cgraph, const char *name)
     * }
     */
    public static MemorySegment ggml_graph_get_tensor(MemorySegment cgraph, MemorySegment name) {
        var mh$ = ggml_graph_get_tensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_get_tensor", cgraph, name);
            }
            return (MemorySegment)mh$.invokeExact(cgraph, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_get_grad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_get_grad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static FunctionDescriptor ggml_graph_get_grad$descriptor() {
        return ggml_graph_get_grad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static MethodHandle ggml_graph_get_grad$handle() {
        return ggml_graph_get_grad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_graph_get_grad$address() {
        return ggml_graph_get_grad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_graph_get_grad(MemorySegment cgraph, MemorySegment node) {
        var mh$ = ggml_graph_get_grad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_get_grad", cgraph, node);
            }
            return (MemorySegment)mh$.invokeExact(cgraph, node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_get_grad_acc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_get_grad_acc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad_acc(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static FunctionDescriptor ggml_graph_get_grad_acc$descriptor() {
        return ggml_graph_get_grad_acc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad_acc(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static MethodHandle ggml_graph_get_grad_acc$handle() {
        return ggml_graph_get_grad_acc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad_acc(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_graph_get_grad_acc$address() {
        return ggml_graph_get_grad_acc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_graph_get_grad_acc(const struct ggml_cgraph *cgraph, const struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_graph_get_grad_acc(MemorySegment cgraph, MemorySegment node) {
        var mh$ = ggml_graph_get_grad_acc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_get_grad_acc", cgraph, node);
            }
            return (MemorySegment)mh$.invokeExact(cgraph, node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_graph_print(const struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_graph_print$descriptor() {
        return ggml_graph_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_graph_print(const struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_graph_print$handle() {
        return ggml_graph_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_graph_print(const struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_graph_print$address() {
        return ggml_graph_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_graph_print(const struct ggml_cgraph *cgraph)
     * }
     */
    public static void ggml_graph_print(MemorySegment cgraph) {
        var mh$ = ggml_graph_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_print", cgraph);
            }
            mh$.invokeExact(cgraph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_dump_dot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_dump_dot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_graph_dump_dot(const struct ggml_cgraph *gb, const struct ggml_cgraph *gf, const char *filename)
     * }
     */
    public static FunctionDescriptor ggml_graph_dump_dot$descriptor() {
        return ggml_graph_dump_dot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_graph_dump_dot(const struct ggml_cgraph *gb, const struct ggml_cgraph *gf, const char *filename)
     * }
     */
    public static MethodHandle ggml_graph_dump_dot$handle() {
        return ggml_graph_dump_dot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_graph_dump_dot(const struct ggml_cgraph *gb, const struct ggml_cgraph *gf, const char *filename)
     * }
     */
    public static MemorySegment ggml_graph_dump_dot$address() {
        return ggml_graph_dump_dot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_graph_dump_dot(const struct ggml_cgraph *gb, const struct ggml_cgraph *gf, const char *filename)
     * }
     */
    public static void ggml_graph_dump_dot(MemorySegment gb, MemorySegment gf, MemorySegment filename) {
        var mh$ = ggml_graph_dump_dot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_dump_dot", gb, gf, filename);
            }
            mh$.invokeExact(gb, gf, filename);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_log_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_log_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_log_set(ggml_log_callback log_callback, void *user_data)
     * }
     */
    public static FunctionDescriptor ggml_log_set$descriptor() {
        return ggml_log_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_log_set(ggml_log_callback log_callback, void *user_data)
     * }
     */
    public static MethodHandle ggml_log_set$handle() {
        return ggml_log_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_log_set(ggml_log_callback log_callback, void *user_data)
     * }
     */
    public static MemorySegment ggml_log_set$address() {
        return ggml_log_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_log_set(ggml_log_callback log_callback, void *user_data)
     * }
     */
    public static void ggml_log_set(MemorySegment log_callback, MemorySegment user_data) {
        var mh$ = ggml_log_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_log_set", log_callback, user_data);
            }
            mh$.invokeExact(log_callback, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_zero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_set_zero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_zero(struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_set_zero$descriptor() {
        return ggml_set_zero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_zero(struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_set_zero$handle() {
        return ggml_set_zero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_zero(struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_set_zero$address() {
        return ggml_set_zero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_zero(struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_set_zero(MemorySegment tensor) {
        var mh$ = ggml_set_zero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_zero", tensor);
            }
            return (MemorySegment)mh$.invokeExact(tensor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_quantize_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_quantize_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_quantize_init(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_quantize_init$descriptor() {
        return ggml_quantize_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_quantize_init(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_quantize_init$handle() {
        return ggml_quantize_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_quantize_init(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_quantize_init$address() {
        return ggml_quantize_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_quantize_init(enum ggml_type type)
     * }
     */
    public static void ggml_quantize_init(int type) {
        var mh$ = ggml_quantize_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_quantize_init", type);
            }
            mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_quantize_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_quantize_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_quantize_free(void)
     * }
     */
    public static FunctionDescriptor ggml_quantize_free$descriptor() {
        return ggml_quantize_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_quantize_free(void)
     * }
     */
    public static MethodHandle ggml_quantize_free$handle() {
        return ggml_quantize_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_quantize_free(void)
     * }
     */
    public static MemorySegment ggml_quantize_free$address() {
        return ggml_quantize_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_quantize_free(void)
     * }
     */
    public static void ggml_quantize_free() {
        var mh$ = ggml_quantize_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_quantize_free");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_quantize_requires_imatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_quantize_requires_imatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_quantize_requires_imatrix(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_quantize_requires_imatrix$descriptor() {
        return ggml_quantize_requires_imatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_quantize_requires_imatrix(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_quantize_requires_imatrix$handle() {
        return ggml_quantize_requires_imatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_quantize_requires_imatrix(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_quantize_requires_imatrix$address() {
        return ggml_quantize_requires_imatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_quantize_requires_imatrix(enum ggml_type type)
     * }
     */
    public static boolean ggml_quantize_requires_imatrix(int type) {
        var mh$ = ggml_quantize_requires_imatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_quantize_requires_imatrix", type);
            }
            return (boolean)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_quantize_chunk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG_LONG,
            llama_h.C_LONG_LONG,
            llama_h.C_LONG_LONG,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_quantize_chunk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_quantize_chunk(enum ggml_type type, const float *src, void *dst, int64_t start, int64_t nrows, int64_t n_per_row, const float *imatrix)
     * }
     */
    public static FunctionDescriptor ggml_quantize_chunk$descriptor() {
        return ggml_quantize_chunk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_quantize_chunk(enum ggml_type type, const float *src, void *dst, int64_t start, int64_t nrows, int64_t n_per_row, const float *imatrix)
     * }
     */
    public static MethodHandle ggml_quantize_chunk$handle() {
        return ggml_quantize_chunk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_quantize_chunk(enum ggml_type type, const float *src, void *dst, int64_t start, int64_t nrows, int64_t n_per_row, const float *imatrix)
     * }
     */
    public static MemorySegment ggml_quantize_chunk$address() {
        return ggml_quantize_chunk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_quantize_chunk(enum ggml_type type, const float *src, void *dst, int64_t start, int64_t nrows, int64_t n_per_row, const float *imatrix)
     * }
     */
    public static long ggml_quantize_chunk(int type, MemorySegment src, MemorySegment dst, long start, long nrows, long n_per_row, MemorySegment imatrix) {
        var mh$ = ggml_quantize_chunk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_quantize_chunk", type, src, dst, start, nrows, n_per_row, imatrix);
            }
            return (long)mh$.invokeExact(type, src, dst, start, nrows, n_per_row, imatrix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_type_traits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_get_type_traits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const struct ggml_type_traits *ggml_get_type_traits(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_get_type_traits$descriptor() {
        return ggml_get_type_traits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const struct ggml_type_traits *ggml_get_type_traits(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_get_type_traits$handle() {
        return ggml_get_type_traits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const struct ggml_type_traits *ggml_get_type_traits(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_get_type_traits$address() {
        return ggml_get_type_traits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const struct ggml_type_traits *ggml_get_type_traits(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_get_type_traits(int type) {
        var mh$ = ggml_get_type_traits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_type_traits", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_SCHED_PRIO_LOW = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum ggml_sched_priority.GGML_SCHED_PRIO_LOW = -1
     * }
     */
    public static int GGML_SCHED_PRIO_LOW() {
        return GGML_SCHED_PRIO_LOW;
    }
    private static final int GGML_SCHED_PRIO_NORMAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_sched_priority.GGML_SCHED_PRIO_NORMAL = 0
     * }
     */
    public static int GGML_SCHED_PRIO_NORMAL() {
        return GGML_SCHED_PRIO_NORMAL;
    }
    private static final int GGML_SCHED_PRIO_MEDIUM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_sched_priority.GGML_SCHED_PRIO_MEDIUM = 1
     * }
     */
    public static int GGML_SCHED_PRIO_MEDIUM() {
        return GGML_SCHED_PRIO_MEDIUM;
    }
    private static final int GGML_SCHED_PRIO_HIGH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_sched_priority.GGML_SCHED_PRIO_HIGH = 2
     * }
     */
    public static int GGML_SCHED_PRIO_HIGH() {
        return GGML_SCHED_PRIO_HIGH;
    }
    private static final int GGML_SCHED_PRIO_REALTIME = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_sched_priority.GGML_SCHED_PRIO_REALTIME = 3
     * }
     */
    public static int GGML_SCHED_PRIO_REALTIME() {
        return GGML_SCHED_PRIO_REALTIME;
    }
    /**
     * {@snippet lang=c :
     * typedef struct ggml_threadpool *ggml_threadpool_t
     * }
     */
    public static final AddressLayout ggml_threadpool_t = llama_h.C_POINTER;

    private static class ggml_threadpool_params_default {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ggml_threadpool_params.layout(),
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_threadpool_params_default");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_threadpool_params ggml_threadpool_params_default(int n_threads)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_params_default$descriptor() {
        return ggml_threadpool_params_default.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_threadpool_params ggml_threadpool_params_default(int n_threads)
     * }
     */
    public static MethodHandle ggml_threadpool_params_default$handle() {
        return ggml_threadpool_params_default.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_threadpool_params ggml_threadpool_params_default(int n_threads)
     * }
     */
    public static MemorySegment ggml_threadpool_params_default$address() {
        return ggml_threadpool_params_default.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_threadpool_params ggml_threadpool_params_default(int n_threads)
     * }
     */
    public static MemorySegment ggml_threadpool_params_default(SegmentAllocator allocator, int n_threads) {
        var mh$ = ggml_threadpool_params_default.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_params_default", allocator, n_threads);
            }
            return (MemorySegment)mh$.invokeExact(allocator, n_threads);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_params_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_threadpool_params_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_params_init(struct ggml_threadpool_params *p, int n_threads)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_params_init$descriptor() {
        return ggml_threadpool_params_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_params_init(struct ggml_threadpool_params *p, int n_threads)
     * }
     */
    public static MethodHandle ggml_threadpool_params_init$handle() {
        return ggml_threadpool_params_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_params_init(struct ggml_threadpool_params *p, int n_threads)
     * }
     */
    public static MemorySegment ggml_threadpool_params_init$address() {
        return ggml_threadpool_params_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_threadpool_params_init(struct ggml_threadpool_params *p, int n_threads)
     * }
     */
    public static void ggml_threadpool_params_init(MemorySegment p, int n_threads) {
        var mh$ = ggml_threadpool_params_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_params_init", p, n_threads);
            }
            mh$.invokeExact(p, n_threads);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_params_match {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_threadpool_params_match");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_threadpool_params_match(const struct ggml_threadpool_params *p0, const struct ggml_threadpool_params *p1)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_params_match$descriptor() {
        return ggml_threadpool_params_match.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_threadpool_params_match(const struct ggml_threadpool_params *p0, const struct ggml_threadpool_params *p1)
     * }
     */
    public static MethodHandle ggml_threadpool_params_match$handle() {
        return ggml_threadpool_params_match.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_threadpool_params_match(const struct ggml_threadpool_params *p0, const struct ggml_threadpool_params *p1)
     * }
     */
    public static MemorySegment ggml_threadpool_params_match$address() {
        return ggml_threadpool_params_match.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_threadpool_params_match(const struct ggml_threadpool_params *p0, const struct ggml_threadpool_params *p1)
     * }
     */
    public static boolean ggml_threadpool_params_match(MemorySegment p0, MemorySegment p1) {
        var mh$ = ggml_threadpool_params_match.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_params_match", p0, p1);
            }
            return (boolean)mh$.invokeExact(p0, p1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend_buffer_type *ggml_backend_buffer_type_t
     * }
     */
    public static final AddressLayout ggml_backend_buffer_type_t = llama_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend_buffer *ggml_backend_buffer_t
     * }
     */
    public static final AddressLayout ggml_backend_buffer_t = llama_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend *ggml_backend_t
     * }
     */
    public static final AddressLayout ggml_backend_t = llama_h.C_POINTER;

    private static class ggml_tallocr_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ggml_tallocr.layout(),
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_tallocr_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tallocr ggml_tallocr_new(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_tallocr_new$descriptor() {
        return ggml_tallocr_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tallocr ggml_tallocr_new(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_tallocr_new$handle() {
        return ggml_tallocr_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tallocr ggml_tallocr_new(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_tallocr_new$address() {
        return ggml_tallocr_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tallocr ggml_tallocr_new(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_tallocr_new(SegmentAllocator allocator, MemorySegment buffer) {
        var mh$ = ggml_tallocr_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_tallocr_new", allocator, buffer);
            }
            return (MemorySegment)mh$.invokeExact(allocator, buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_tallocr_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_tallocr_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_tallocr_alloc(struct ggml_tallocr *talloc, struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_tallocr_alloc$descriptor() {
        return ggml_tallocr_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_tallocr_alloc(struct ggml_tallocr *talloc, struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_tallocr_alloc$handle() {
        return ggml_tallocr_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_tallocr_alloc(struct ggml_tallocr *talloc, struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_tallocr_alloc$address() {
        return ggml_tallocr_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_tallocr_alloc(struct ggml_tallocr *talloc, struct ggml_tensor *tensor)
     * }
     */
    public static int ggml_tallocr_alloc(MemorySegment talloc, MemorySegment tensor) {
        var mh$ = ggml_tallocr_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_tallocr_alloc", talloc, tensor);
            }
            return (int)mh$.invokeExact(talloc, tensor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct ggml_gallocr *ggml_gallocr_t
     * }
     */
    public static final AddressLayout ggml_gallocr_t = llama_h.C_POINTER;

    private static class ggml_gallocr_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_gallocr_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new(ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_new$descriptor() {
        return ggml_gallocr_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_gallocr_new$handle() {
        return ggml_gallocr_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_gallocr_new$address() {
        return ggml_gallocr_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_gallocr_new(MemorySegment buft) {
        var mh$ = ggml_gallocr_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_new", buft);
            }
            return (MemorySegment)mh$.invokeExact(buft);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gallocr_new_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_gallocr_new_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new_n(ggml_backend_buffer_type_t *bufts, int n_bufs)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_new_n$descriptor() {
        return ggml_gallocr_new_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new_n(ggml_backend_buffer_type_t *bufts, int n_bufs)
     * }
     */
    public static MethodHandle ggml_gallocr_new_n$handle() {
        return ggml_gallocr_new_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new_n(ggml_backend_buffer_type_t *bufts, int n_bufs)
     * }
     */
    public static MemorySegment ggml_gallocr_new_n$address() {
        return ggml_gallocr_new_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_gallocr_t ggml_gallocr_new_n(ggml_backend_buffer_type_t *bufts, int n_bufs)
     * }
     */
    public static MemorySegment ggml_gallocr_new_n(MemorySegment bufts, int n_bufs) {
        var mh$ = ggml_gallocr_new_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_new_n", bufts, n_bufs);
            }
            return (MemorySegment)mh$.invokeExact(bufts, n_bufs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gallocr_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_gallocr_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_gallocr_free(ggml_gallocr_t galloc)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_free$descriptor() {
        return ggml_gallocr_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_gallocr_free(ggml_gallocr_t galloc)
     * }
     */
    public static MethodHandle ggml_gallocr_free$handle() {
        return ggml_gallocr_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_gallocr_free(ggml_gallocr_t galloc)
     * }
     */
    public static MemorySegment ggml_gallocr_free$address() {
        return ggml_gallocr_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_gallocr_free(ggml_gallocr_t galloc)
     * }
     */
    public static void ggml_gallocr_free(MemorySegment galloc) {
        var mh$ = ggml_gallocr_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_free", galloc);
            }
            mh$.invokeExact(galloc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gallocr_reserve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_gallocr_reserve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_reserve$descriptor() {
        return ggml_gallocr_reserve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static MethodHandle ggml_gallocr_reserve$handle() {
        return ggml_gallocr_reserve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static MemorySegment ggml_gallocr_reserve$address() {
        return ggml_gallocr_reserve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static boolean ggml_gallocr_reserve(MemorySegment galloc, MemorySegment graph) {
        var mh$ = ggml_gallocr_reserve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_reserve", galloc, graph);
            }
            return (boolean)mh$.invokeExact(galloc, graph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gallocr_reserve_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_gallocr_reserve_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve_n(ggml_gallocr_t galloc, struct ggml_cgraph *graph, const int *node_buffer_ids, const int *leaf_buffer_ids)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_reserve_n$descriptor() {
        return ggml_gallocr_reserve_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve_n(ggml_gallocr_t galloc, struct ggml_cgraph *graph, const int *node_buffer_ids, const int *leaf_buffer_ids)
     * }
     */
    public static MethodHandle ggml_gallocr_reserve_n$handle() {
        return ggml_gallocr_reserve_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve_n(ggml_gallocr_t galloc, struct ggml_cgraph *graph, const int *node_buffer_ids, const int *leaf_buffer_ids)
     * }
     */
    public static MemorySegment ggml_gallocr_reserve_n$address() {
        return ggml_gallocr_reserve_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_gallocr_reserve_n(ggml_gallocr_t galloc, struct ggml_cgraph *graph, const int *node_buffer_ids, const int *leaf_buffer_ids)
     * }
     */
    public static boolean ggml_gallocr_reserve_n(MemorySegment galloc, MemorySegment graph, MemorySegment node_buffer_ids, MemorySegment leaf_buffer_ids) {
        var mh$ = ggml_gallocr_reserve_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_reserve_n", galloc, graph, node_buffer_ids, leaf_buffer_ids);
            }
            return (boolean)mh$.invokeExact(galloc, graph, node_buffer_ids, leaf_buffer_ids);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gallocr_alloc_graph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_gallocr_alloc_graph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_alloc_graph(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_alloc_graph$descriptor() {
        return ggml_gallocr_alloc_graph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_alloc_graph(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static MethodHandle ggml_gallocr_alloc_graph$handle() {
        return ggml_gallocr_alloc_graph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_gallocr_alloc_graph(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static MemorySegment ggml_gallocr_alloc_graph$address() {
        return ggml_gallocr_alloc_graph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_gallocr_alloc_graph(ggml_gallocr_t galloc, struct ggml_cgraph *graph)
     * }
     */
    public static boolean ggml_gallocr_alloc_graph(MemorySegment galloc, MemorySegment graph) {
        var mh$ = ggml_gallocr_alloc_graph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_alloc_graph", galloc, graph);
            }
            return (boolean)mh$.invokeExact(galloc, graph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_gallocr_get_buffer_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_gallocr_get_buffer_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_gallocr_get_buffer_size(ggml_gallocr_t galloc, int buffer_id)
     * }
     */
    public static FunctionDescriptor ggml_gallocr_get_buffer_size$descriptor() {
        return ggml_gallocr_get_buffer_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_gallocr_get_buffer_size(ggml_gallocr_t galloc, int buffer_id)
     * }
     */
    public static MethodHandle ggml_gallocr_get_buffer_size$handle() {
        return ggml_gallocr_get_buffer_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_gallocr_get_buffer_size(ggml_gallocr_t galloc, int buffer_id)
     * }
     */
    public static MemorySegment ggml_gallocr_get_buffer_size$address() {
        return ggml_gallocr_get_buffer_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_gallocr_get_buffer_size(ggml_gallocr_t galloc, int buffer_id)
     * }
     */
    public static long ggml_gallocr_get_buffer_size(MemorySegment galloc, int buffer_id) {
        var mh$ = ggml_gallocr_get_buffer_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_gallocr_get_buffer_size", galloc, buffer_id);
            }
            return (long)mh$.invokeExact(galloc, buffer_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_alloc_ctx_tensors_from_buft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_alloc_ctx_tensors_from_buft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors_from_buft(struct ggml_context *ctx, ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_alloc_ctx_tensors_from_buft$descriptor() {
        return ggml_backend_alloc_ctx_tensors_from_buft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors_from_buft(struct ggml_context *ctx, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_alloc_ctx_tensors_from_buft$handle() {
        return ggml_backend_alloc_ctx_tensors_from_buft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors_from_buft(struct ggml_context *ctx, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_alloc_ctx_tensors_from_buft$address() {
        return ggml_backend_alloc_ctx_tensors_from_buft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors_from_buft(struct ggml_context *ctx, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_alloc_ctx_tensors_from_buft(MemorySegment ctx, MemorySegment buft) {
        var mh$ = ggml_backend_alloc_ctx_tensors_from_buft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_alloc_ctx_tensors_from_buft", ctx, buft);
            }
            return (MemorySegment)mh$.invokeExact(ctx, buft);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_alloc_ctx_tensors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_alloc_ctx_tensors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors(struct ggml_context *ctx, ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_alloc_ctx_tensors$descriptor() {
        return ggml_backend_alloc_ctx_tensors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors(struct ggml_context *ctx, ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_alloc_ctx_tensors$handle() {
        return ggml_backend_alloc_ctx_tensors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors(struct ggml_context *ctx, ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_alloc_ctx_tensors$address() {
        return ggml_backend_alloc_ctx_tensors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_backend_buffer *ggml_backend_alloc_ctx_tensors(struct ggml_context *ctx, ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_alloc_ctx_tensors(MemorySegment ctx, MemorySegment backend) {
        var mh$ = ggml_backend_alloc_ctx_tensors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_alloc_ctx_tensors", ctx, backend);
            }
            return (MemorySegment)mh$.invokeExact(ctx, backend);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend_event *ggml_backend_event_t
     * }
     */
    public static final AddressLayout ggml_backend_event_t = llama_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *ggml_backend_graph_plan_t
     * }
     */
    public static final AddressLayout ggml_backend_graph_plan_t = llama_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend_reg *ggml_backend_reg_t
     * }
     */
    public static final AddressLayout ggml_backend_reg_t = llama_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend_device *ggml_backend_dev_t
     * }
     */
    public static final AddressLayout ggml_backend_dev_t = llama_h.C_POINTER;

    private static class ggml_backend_buft_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buft_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_buft_name(ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_name$descriptor() {
        return ggml_backend_buft_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_buft_name(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_buft_name$handle() {
        return ggml_backend_buft_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_buft_name(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_name$address() {
        return ggml_backend_buft_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_backend_buft_name(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_name(MemorySegment buft) {
        var mh$ = ggml_backend_buft_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_name", buft);
            }
            return (MemorySegment)mh$.invokeExact(buft);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buft_alloc_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buft_alloc_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_buft_alloc_buffer(ggml_backend_buffer_type_t buft, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_alloc_buffer$descriptor() {
        return ggml_backend_buft_alloc_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_buft_alloc_buffer(ggml_backend_buffer_type_t buft, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_buft_alloc_buffer$handle() {
        return ggml_backend_buft_alloc_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_buft_alloc_buffer(ggml_backend_buffer_type_t buft, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_buft_alloc_buffer$address() {
        return ggml_backend_buft_alloc_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_buft_alloc_buffer(ggml_backend_buffer_type_t buft, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_buft_alloc_buffer(MemorySegment buft, long size) {
        var mh$ = ggml_backend_buft_alloc_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_alloc_buffer", buft, size);
            }
            return (MemorySegment)mh$.invokeExact(buft, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buft_get_alignment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buft_get_alignment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alignment(ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_get_alignment$descriptor() {
        return ggml_backend_buft_get_alignment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alignment(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_buft_get_alignment$handle() {
        return ggml_backend_buft_get_alignment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alignment(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_get_alignment$address() {
        return ggml_backend_buft_get_alignment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alignment(ggml_backend_buffer_type_t buft)
     * }
     */
    public static long ggml_backend_buft_get_alignment(MemorySegment buft) {
        var mh$ = ggml_backend_buft_get_alignment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_get_alignment", buft);
            }
            return (long)mh$.invokeExact(buft);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buft_get_max_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buft_get_max_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_max_size(ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_get_max_size$descriptor() {
        return ggml_backend_buft_get_max_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_max_size(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_buft_get_max_size$handle() {
        return ggml_backend_buft_get_max_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_max_size(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_get_max_size$address() {
        return ggml_backend_buft_get_max_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_max_size(ggml_backend_buffer_type_t buft)
     * }
     */
    public static long ggml_backend_buft_get_max_size(MemorySegment buft) {
        var mh$ = ggml_backend_buft_get_max_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_get_max_size", buft);
            }
            return (long)mh$.invokeExact(buft);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buft_get_alloc_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buft_get_alloc_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alloc_size(ggml_backend_buffer_type_t buft, const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_get_alloc_size$descriptor() {
        return ggml_backend_buft_get_alloc_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alloc_size(ggml_backend_buffer_type_t buft, const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_backend_buft_get_alloc_size$handle() {
        return ggml_backend_buft_get_alloc_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alloc_size(ggml_backend_buffer_type_t buft, const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_backend_buft_get_alloc_size$address() {
        return ggml_backend_buft_get_alloc_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buft_get_alloc_size(ggml_backend_buffer_type_t buft, const struct ggml_tensor *tensor)
     * }
     */
    public static long ggml_backend_buft_get_alloc_size(MemorySegment buft, MemorySegment tensor) {
        var mh$ = ggml_backend_buft_get_alloc_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_get_alloc_size", buft, tensor);
            }
            return (long)mh$.invokeExact(buft, tensor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buft_is_host {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buft_is_host");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_buft_is_host(ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_is_host$descriptor() {
        return ggml_backend_buft_is_host.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_buft_is_host(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_buft_is_host$handle() {
        return ggml_backend_buft_is_host.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_buft_is_host(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_is_host$address() {
        return ggml_backend_buft_is_host.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_buft_is_host(ggml_backend_buffer_type_t buft)
     * }
     */
    public static boolean ggml_backend_buft_is_host(MemorySegment buft) {
        var mh$ = ggml_backend_buft_is_host.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_is_host", buft);
            }
            return (boolean)mh$.invokeExact(buft);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buft_get_device {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buft_get_device");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_buft_get_device(ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_buft_get_device$descriptor() {
        return ggml_backend_buft_get_device.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_buft_get_device(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_buft_get_device$handle() {
        return ggml_backend_buft_get_device.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_buft_get_device(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_get_device$address() {
        return ggml_backend_buft_get_device.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_buft_get_device(ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_buft_get_device(MemorySegment buft) {
        var mh$ = ggml_backend_buft_get_device.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buft_get_device", buft);
            }
            return (MemorySegment)mh$.invokeExact(buft);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_BACKEND_BUFFER_USAGE_ANY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_backend_buffer_usage.GGML_BACKEND_BUFFER_USAGE_ANY = 0
     * }
     */
    public static int GGML_BACKEND_BUFFER_USAGE_ANY() {
        return GGML_BACKEND_BUFFER_USAGE_ANY;
    }
    private static final int GGML_BACKEND_BUFFER_USAGE_WEIGHTS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_backend_buffer_usage.GGML_BACKEND_BUFFER_USAGE_WEIGHTS = 1
     * }
     */
    public static int GGML_BACKEND_BUFFER_USAGE_WEIGHTS() {
        return GGML_BACKEND_BUFFER_USAGE_WEIGHTS;
    }
    private static final int GGML_BACKEND_BUFFER_USAGE_COMPUTE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_backend_buffer_usage.GGML_BACKEND_BUFFER_USAGE_COMPUTE = 2
     * }
     */
    public static int GGML_BACKEND_BUFFER_USAGE_COMPUTE() {
        return GGML_BACKEND_BUFFER_USAGE_COMPUTE;
    }

    private static class ggml_backend_buffer_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buffer_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_buffer_name(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_name$descriptor() {
        return ggml_backend_buffer_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_buffer_name(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_name$handle() {
        return ggml_backend_buffer_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_buffer_name(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_name$address() {
        return ggml_backend_buffer_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_backend_buffer_name(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_name(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_name", buffer);
            }
            return (MemorySegment)mh$.invokeExact(buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buffer_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_free(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_free$descriptor() {
        return ggml_backend_buffer_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_free(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_free$handle() {
        return ggml_backend_buffer_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_free(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_free$address() {
        return ggml_backend_buffer_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_free(ggml_backend_buffer_t buffer)
     * }
     */
    public static void ggml_backend_buffer_free(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_free", buffer);
            }
            mh$.invokeExact(buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buffer_get_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *ggml_backend_buffer_get_base(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_base$descriptor() {
        return ggml_backend_buffer_get_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *ggml_backend_buffer_get_base(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_base$handle() {
        return ggml_backend_buffer_get_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *ggml_backend_buffer_get_base(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_base$address() {
        return ggml_backend_buffer_get_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *ggml_backend_buffer_get_base(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_base(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_get_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_base", buffer);
            }
            return (MemorySegment)mh$.invokeExact(buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buffer_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_size$descriptor() {
        return ggml_backend_buffer_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_size$handle() {
        return ggml_backend_buffer_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_size$address() {
        return ggml_backend_buffer_get_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static long ggml_backend_buffer_get_size(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_size", buffer);
            }
            return (long)mh$.invokeExact(buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_init_tensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buffer_init_tensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_buffer_init_tensor(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_init_tensor$descriptor() {
        return ggml_backend_buffer_init_tensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_buffer_init_tensor(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_backend_buffer_init_tensor$handle() {
        return ggml_backend_buffer_init_tensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_buffer_init_tensor(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_backend_buffer_init_tensor$address() {
        return ggml_backend_buffer_init_tensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_buffer_init_tensor(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor)
     * }
     */
    public static int ggml_backend_buffer_init_tensor(MemorySegment buffer, MemorySegment tensor) {
        var mh$ = ggml_backend_buffer_init_tensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_init_tensor", buffer, tensor);
            }
            return (int)mh$.invokeExact(buffer, tensor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_alignment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buffer_get_alignment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alignment(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_alignment$descriptor() {
        return ggml_backend_buffer_get_alignment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alignment(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_alignment$handle() {
        return ggml_backend_buffer_get_alignment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alignment(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_alignment$address() {
        return ggml_backend_buffer_get_alignment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alignment(ggml_backend_buffer_t buffer)
     * }
     */
    public static long ggml_backend_buffer_get_alignment(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_get_alignment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_alignment", buffer);
            }
            return (long)mh$.invokeExact(buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_max_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buffer_get_max_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_max_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_max_size$descriptor() {
        return ggml_backend_buffer_get_max_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_max_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_max_size$handle() {
        return ggml_backend_buffer_get_max_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_max_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_max_size$address() {
        return ggml_backend_buffer_get_max_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_max_size(ggml_backend_buffer_t buffer)
     * }
     */
    public static long ggml_backend_buffer_get_max_size(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_get_max_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_max_size", buffer);
            }
            return (long)mh$.invokeExact(buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_alloc_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buffer_get_alloc_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alloc_size(ggml_backend_buffer_t buffer, const struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_alloc_size$descriptor() {
        return ggml_backend_buffer_get_alloc_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alloc_size(ggml_backend_buffer_t buffer, const struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_alloc_size$handle() {
        return ggml_backend_buffer_get_alloc_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alloc_size(ggml_backend_buffer_t buffer, const struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_alloc_size$address() {
        return ggml_backend_buffer_get_alloc_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_buffer_get_alloc_size(ggml_backend_buffer_t buffer, const struct ggml_tensor *tensor)
     * }
     */
    public static long ggml_backend_buffer_get_alloc_size(MemorySegment buffer, MemorySegment tensor) {
        var mh$ = ggml_backend_buffer_get_alloc_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_alloc_size", buffer, tensor);
            }
            return (long)mh$.invokeExact(buffer, tensor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buffer_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_clear(ggml_backend_buffer_t buffer, uint8_t value)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_clear$descriptor() {
        return ggml_backend_buffer_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_clear(ggml_backend_buffer_t buffer, uint8_t value)
     * }
     */
    public static MethodHandle ggml_backend_buffer_clear$handle() {
        return ggml_backend_buffer_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_clear(ggml_backend_buffer_t buffer, uint8_t value)
     * }
     */
    public static MemorySegment ggml_backend_buffer_clear$address() {
        return ggml_backend_buffer_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_clear(ggml_backend_buffer_t buffer, uint8_t value)
     * }
     */
    public static void ggml_backend_buffer_clear(MemorySegment buffer, byte value) {
        var mh$ = ggml_backend_buffer_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_clear", buffer, value);
            }
            mh$.invokeExact(buffer, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_is_host {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buffer_is_host");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_buffer_is_host(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_is_host$descriptor() {
        return ggml_backend_buffer_is_host.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_buffer_is_host(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_is_host$handle() {
        return ggml_backend_buffer_is_host.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_buffer_is_host(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_is_host$address() {
        return ggml_backend_buffer_is_host.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_buffer_is_host(ggml_backend_buffer_t buffer)
     * }
     */
    public static boolean ggml_backend_buffer_is_host(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_is_host.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_is_host", buffer);
            }
            return (boolean)mh$.invokeExact(buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_set_usage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buffer_set_usage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_set_usage(ggml_backend_buffer_t buffer, enum ggml_backend_buffer_usage usage)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_set_usage$descriptor() {
        return ggml_backend_buffer_set_usage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_set_usage(ggml_backend_buffer_t buffer, enum ggml_backend_buffer_usage usage)
     * }
     */
    public static MethodHandle ggml_backend_buffer_set_usage$handle() {
        return ggml_backend_buffer_set_usage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_set_usage(ggml_backend_buffer_t buffer, enum ggml_backend_buffer_usage usage)
     * }
     */
    public static MemorySegment ggml_backend_buffer_set_usage$address() {
        return ggml_backend_buffer_set_usage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_set_usage(ggml_backend_buffer_t buffer, enum ggml_backend_buffer_usage usage)
     * }
     */
    public static void ggml_backend_buffer_set_usage(MemorySegment buffer, int usage) {
        var mh$ = ggml_backend_buffer_set_usage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_set_usage", buffer, usage);
            }
            mh$.invokeExact(buffer, usage);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_usage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buffer_get_usage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_backend_buffer_usage ggml_backend_buffer_get_usage(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_usage$descriptor() {
        return ggml_backend_buffer_get_usage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_backend_buffer_usage ggml_backend_buffer_get_usage(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_usage$handle() {
        return ggml_backend_buffer_get_usage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_backend_buffer_usage ggml_backend_buffer_get_usage(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_usage$address() {
        return ggml_backend_buffer_get_usage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_backend_buffer_usage ggml_backend_buffer_get_usage(ggml_backend_buffer_t buffer)
     * }
     */
    public static int ggml_backend_buffer_get_usage(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_get_usage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_usage", buffer);
            }
            return (int)mh$.invokeExact(buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buffer_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_buffer_get_type(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_get_type$descriptor() {
        return ggml_backend_buffer_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_buffer_get_type(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_get_type$handle() {
        return ggml_backend_buffer_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_buffer_get_type(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_type$address() {
        return ggml_backend_buffer_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_buffer_get_type(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_get_type(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_get_type", buffer);
            }
            return (MemorySegment)mh$.invokeExact(buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_buffer_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_buffer_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_reset(ggml_backend_buffer_t buffer)
     * }
     */
    public static FunctionDescriptor ggml_backend_buffer_reset$descriptor() {
        return ggml_backend_buffer_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_reset(ggml_backend_buffer_t buffer)
     * }
     */
    public static MethodHandle ggml_backend_buffer_reset$handle() {
        return ggml_backend_buffer_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_reset(ggml_backend_buffer_t buffer)
     * }
     */
    public static MemorySegment ggml_backend_buffer_reset$address() {
        return ggml_backend_buffer_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_buffer_reset(ggml_backend_buffer_t buffer)
     * }
     */
    public static void ggml_backend_buffer_reset(MemorySegment buffer) {
        var mh$ = ggml_backend_buffer_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_buffer_reset", buffer);
            }
            mh$.invokeExact(buffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_tensor_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy(struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_copy$descriptor() {
        return ggml_backend_tensor_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy(struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static MethodHandle ggml_backend_tensor_copy$handle() {
        return ggml_backend_tensor_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy(struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static MemorySegment ggml_backend_tensor_copy$address() {
        return ggml_backend_tensor_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy(struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static void ggml_backend_tensor_copy(MemorySegment src, MemorySegment dst) {
        var mh$ = ggml_backend_tensor_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_copy", src, dst);
            }
            mh$.invokeExact(src, dst);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_guid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_guid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_guid_t ggml_backend_guid(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_guid$descriptor() {
        return ggml_backend_guid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_guid_t ggml_backend_guid(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_guid$handle() {
        return ggml_backend_guid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_guid_t ggml_backend_guid(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_guid$address() {
        return ggml_backend_guid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_guid_t ggml_backend_guid(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_guid(MemorySegment backend) {
        var mh$ = ggml_backend_guid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_guid", backend);
            }
            return (MemorySegment)mh$.invokeExact(backend);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_name(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_name$descriptor() {
        return ggml_backend_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_name(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_name$handle() {
        return ggml_backend_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_name(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_name$address() {
        return ggml_backend_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_backend_name(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_name(MemorySegment backend) {
        var mh$ = ggml_backend_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_name", backend);
            }
            return (MemorySegment)mh$.invokeExact(backend);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_free(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_free$descriptor() {
        return ggml_backend_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_free(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_free$handle() {
        return ggml_backend_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_free(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_free$address() {
        return ggml_backend_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_free(ggml_backend_t backend)
     * }
     */
    public static void ggml_backend_free(MemorySegment backend) {
        var mh$ = ggml_backend_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_free", backend);
            }
            mh$.invokeExact(backend);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_get_default_buffer_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_get_default_buffer_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_get_default_buffer_type(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_get_default_buffer_type$descriptor() {
        return ggml_backend_get_default_buffer_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_get_default_buffer_type(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_get_default_buffer_type$handle() {
        return ggml_backend_get_default_buffer_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_get_default_buffer_type(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_get_default_buffer_type$address() {
        return ggml_backend_get_default_buffer_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_get_default_buffer_type(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_get_default_buffer_type(MemorySegment backend) {
        var mh$ = ggml_backend_get_default_buffer_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_get_default_buffer_type", backend);
            }
            return (MemorySegment)mh$.invokeExact(backend);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_alloc_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_alloc_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_alloc_buffer(ggml_backend_t backend, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_alloc_buffer$descriptor() {
        return ggml_backend_alloc_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_alloc_buffer(ggml_backend_t backend, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_alloc_buffer$handle() {
        return ggml_backend_alloc_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_alloc_buffer(ggml_backend_t backend, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_alloc_buffer$address() {
        return ggml_backend_alloc_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_alloc_buffer(ggml_backend_t backend, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_alloc_buffer(MemorySegment backend, long size) {
        var mh$ = ggml_backend_alloc_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_alloc_buffer", backend, size);
            }
            return (MemorySegment)mh$.invokeExact(backend, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_get_alignment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_get_alignment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_alignment(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_get_alignment$descriptor() {
        return ggml_backend_get_alignment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_alignment(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_get_alignment$handle() {
        return ggml_backend_get_alignment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_alignment(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_get_alignment$address() {
        return ggml_backend_get_alignment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_alignment(ggml_backend_t backend)
     * }
     */
    public static long ggml_backend_get_alignment(MemorySegment backend) {
        var mh$ = ggml_backend_get_alignment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_get_alignment", backend);
            }
            return (long)mh$.invokeExact(backend);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_get_max_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_get_max_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_max_size(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_get_max_size$descriptor() {
        return ggml_backend_get_max_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_max_size(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_get_max_size$handle() {
        return ggml_backend_get_max_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_max_size(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_get_max_size$address() {
        return ggml_backend_get_max_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_get_max_size(ggml_backend_t backend)
     * }
     */
    public static long ggml_backend_get_max_size(MemorySegment backend) {
        var mh$ = ggml_backend_get_max_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_get_max_size", backend);
            }
            return (long)mh$.invokeExact(backend);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_set_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_tensor_set_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set_async(ggml_backend_t backend, struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_set_async$descriptor() {
        return ggml_backend_tensor_set_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set_async(ggml_backend_t backend, struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_tensor_set_async$handle() {
        return ggml_backend_tensor_set_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set_async(ggml_backend_t backend, struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_tensor_set_async$address() {
        return ggml_backend_tensor_set_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set_async(ggml_backend_t backend, struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static void ggml_backend_tensor_set_async(MemorySegment backend, MemorySegment tensor, MemorySegment data, long offset, long size) {
        var mh$ = ggml_backend_tensor_set_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_set_async", backend, tensor, data, offset, size);
            }
            mh$.invokeExact(backend, tensor, data, offset, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_get_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_tensor_get_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get_async(ggml_backend_t backend, const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_get_async$descriptor() {
        return ggml_backend_tensor_get_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get_async(ggml_backend_t backend, const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_tensor_get_async$handle() {
        return ggml_backend_tensor_get_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get_async(ggml_backend_t backend, const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_tensor_get_async$address() {
        return ggml_backend_tensor_get_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get_async(ggml_backend_t backend, const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static void ggml_backend_tensor_get_async(MemorySegment backend, MemorySegment tensor, MemorySegment data, long offset, long size) {
        var mh$ = ggml_backend_tensor_get_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_get_async", backend, tensor, data, offset, size);
            }
            mh$.invokeExact(backend, tensor, data, offset, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_tensor_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set(struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_set$descriptor() {
        return ggml_backend_tensor_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set(struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_tensor_set$handle() {
        return ggml_backend_tensor_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set(struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_tensor_set$address() {
        return ggml_backend_tensor_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_set(struct ggml_tensor *tensor, const void *data, size_t offset, size_t size)
     * }
     */
    public static void ggml_backend_tensor_set(MemorySegment tensor, MemorySegment data, long offset, long size) {
        var mh$ = ggml_backend_tensor_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_set", tensor, data, offset, size);
            }
            mh$.invokeExact(tensor, data, offset, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_tensor_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get(const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_get$descriptor() {
        return ggml_backend_tensor_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get(const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_tensor_get$handle() {
        return ggml_backend_tensor_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get(const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_tensor_get$address() {
        return ggml_backend_tensor_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_get(const struct ggml_tensor *tensor, void *data, size_t offset, size_t size)
     * }
     */
    public static void ggml_backend_tensor_get(MemorySegment tensor, MemorySegment data, long offset, long size) {
        var mh$ = ggml_backend_tensor_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_get", tensor, data, offset, size);
            }
            mh$.invokeExact(tensor, data, offset, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_CHAR,
            llama_h.C_LONG,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_tensor_memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_memset(struct ggml_tensor *tensor, uint8_t value, size_t offset, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_memset$descriptor() {
        return ggml_backend_tensor_memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_memset(struct ggml_tensor *tensor, uint8_t value, size_t offset, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_tensor_memset$handle() {
        return ggml_backend_tensor_memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_memset(struct ggml_tensor *tensor, uint8_t value, size_t offset, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_tensor_memset$address() {
        return ggml_backend_tensor_memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_memset(struct ggml_tensor *tensor, uint8_t value, size_t offset, size_t size)
     * }
     */
    public static void ggml_backend_tensor_memset(MemorySegment tensor, byte value, long offset, long size) {
        var mh$ = ggml_backend_tensor_memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_memset", tensor, value, offset, size);
            }
            mh$.invokeExact(tensor, value, offset, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_synchronize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_synchronize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_synchronize(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_synchronize$descriptor() {
        return ggml_backend_synchronize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_synchronize(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_synchronize$handle() {
        return ggml_backend_synchronize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_synchronize(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_synchronize$address() {
        return ggml_backend_synchronize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_synchronize(ggml_backend_t backend)
     * }
     */
    public static void ggml_backend_synchronize(MemorySegment backend) {
        var mh$ = ggml_backend_synchronize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_synchronize", backend);
            }
            mh$.invokeExact(backend);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_graph_plan_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_graph_plan_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_graph_plan_t ggml_backend_graph_plan_create(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_backend_graph_plan_create$descriptor() {
        return ggml_backend_graph_plan_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_graph_plan_t ggml_backend_graph_plan_create(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_backend_graph_plan_create$handle() {
        return ggml_backend_graph_plan_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_graph_plan_t ggml_backend_graph_plan_create(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_backend_graph_plan_create$address() {
        return ggml_backend_graph_plan_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_graph_plan_t ggml_backend_graph_plan_create(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_backend_graph_plan_create(MemorySegment backend, MemorySegment cgraph) {
        var mh$ = ggml_backend_graph_plan_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_graph_plan_create", backend, cgraph);
            }
            return (MemorySegment)mh$.invokeExact(backend, cgraph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_graph_plan_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_graph_plan_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_graph_plan_free(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static FunctionDescriptor ggml_backend_graph_plan_free$descriptor() {
        return ggml_backend_graph_plan_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_graph_plan_free(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static MethodHandle ggml_backend_graph_plan_free$handle() {
        return ggml_backend_graph_plan_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_graph_plan_free(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static MemorySegment ggml_backend_graph_plan_free$address() {
        return ggml_backend_graph_plan_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_graph_plan_free(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static void ggml_backend_graph_plan_free(MemorySegment backend, MemorySegment plan) {
        var mh$ = ggml_backend_graph_plan_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_graph_plan_free", backend, plan);
            }
            mh$.invokeExact(backend, plan);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_graph_plan_compute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_graph_plan_compute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_plan_compute(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static FunctionDescriptor ggml_backend_graph_plan_compute$descriptor() {
        return ggml_backend_graph_plan_compute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_plan_compute(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static MethodHandle ggml_backend_graph_plan_compute$handle() {
        return ggml_backend_graph_plan_compute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_plan_compute(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static MemorySegment ggml_backend_graph_plan_compute$address() {
        return ggml_backend_graph_plan_compute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_plan_compute(ggml_backend_t backend, ggml_backend_graph_plan_t plan)
     * }
     */
    public static int ggml_backend_graph_plan_compute(MemorySegment backend, MemorySegment plan) {
        var mh$ = ggml_backend_graph_plan_compute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_graph_plan_compute", backend, plan);
            }
            return (int)mh$.invokeExact(backend, plan);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_graph_compute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_graph_compute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_backend_graph_compute$descriptor() {
        return ggml_backend_graph_compute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_backend_graph_compute$handle() {
        return ggml_backend_graph_compute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_backend_graph_compute$address() {
        return ggml_backend_graph_compute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static int ggml_backend_graph_compute(MemorySegment backend, MemorySegment cgraph) {
        var mh$ = ggml_backend_graph_compute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_graph_compute", backend, cgraph);
            }
            return (int)mh$.invokeExact(backend, cgraph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_graph_compute_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_graph_compute_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute_async(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static FunctionDescriptor ggml_backend_graph_compute_async$descriptor() {
        return ggml_backend_graph_compute_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute_async(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MethodHandle ggml_backend_graph_compute_async$handle() {
        return ggml_backend_graph_compute_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute_async(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static MemorySegment ggml_backend_graph_compute_async$address() {
        return ggml_backend_graph_compute_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_graph_compute_async(ggml_backend_t backend, struct ggml_cgraph *cgraph)
     * }
     */
    public static int ggml_backend_graph_compute_async(MemorySegment backend, MemorySegment cgraph) {
        var mh$ = ggml_backend_graph_compute_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_graph_compute_async", backend, cgraph);
            }
            return (int)mh$.invokeExact(backend, cgraph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_supports_op {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_supports_op");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static FunctionDescriptor ggml_backend_supports_op$descriptor() {
        return ggml_backend_supports_op.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static MethodHandle ggml_backend_supports_op$handle() {
        return ggml_backend_supports_op.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static MemorySegment ggml_backend_supports_op$address() {
        return ggml_backend_supports_op.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static boolean ggml_backend_supports_op(MemorySegment backend, MemorySegment op) {
        var mh$ = ggml_backend_supports_op.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_supports_op", backend, op);
            }
            return (boolean)mh$.invokeExact(backend, op);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_supports_buft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_supports_buft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_buft(ggml_backend_t backend, ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_supports_buft$descriptor() {
        return ggml_backend_supports_buft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_buft(ggml_backend_t backend, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_supports_buft$handle() {
        return ggml_backend_supports_buft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_buft(ggml_backend_t backend, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_supports_buft$address() {
        return ggml_backend_supports_buft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_supports_buft(ggml_backend_t backend, ggml_backend_buffer_type_t buft)
     * }
     */
    public static boolean ggml_backend_supports_buft(MemorySegment backend, MemorySegment buft) {
        var mh$ = ggml_backend_supports_buft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_supports_buft", backend, buft);
            }
            return (boolean)mh$.invokeExact(backend, buft);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_offload_op {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_offload_op");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_offload_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static FunctionDescriptor ggml_backend_offload_op$descriptor() {
        return ggml_backend_offload_op.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_offload_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static MethodHandle ggml_backend_offload_op$handle() {
        return ggml_backend_offload_op.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_offload_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static MemorySegment ggml_backend_offload_op$address() {
        return ggml_backend_offload_op.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_offload_op(ggml_backend_t backend, const struct ggml_tensor *op)
     * }
     */
    public static boolean ggml_backend_offload_op(MemorySegment backend, MemorySegment op) {
        var mh$ = ggml_backend_offload_op.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_offload_op", backend, op);
            }
            return (boolean)mh$.invokeExact(backend, op);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_copy_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_tensor_copy_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy_async(ggml_backend_t backend_src, ggml_backend_t backend_dst, struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_copy_async$descriptor() {
        return ggml_backend_tensor_copy_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy_async(ggml_backend_t backend_src, ggml_backend_t backend_dst, struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static MethodHandle ggml_backend_tensor_copy_async$handle() {
        return ggml_backend_tensor_copy_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy_async(ggml_backend_t backend_src, ggml_backend_t backend_dst, struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static MemorySegment ggml_backend_tensor_copy_async$address() {
        return ggml_backend_tensor_copy_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_tensor_copy_async(ggml_backend_t backend_src, ggml_backend_t backend_dst, struct ggml_tensor *src, struct ggml_tensor *dst)
     * }
     */
    public static void ggml_backend_tensor_copy_async(MemorySegment backend_src, MemorySegment backend_dst, MemorySegment src, MemorySegment dst) {
        var mh$ = ggml_backend_tensor_copy_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_copy_async", backend_src, backend_dst, src, dst);
            }
            mh$.invokeExact(backend_src, backend_dst, src, dst);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_get_device {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_get_device");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_get_device(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_get_device$descriptor() {
        return ggml_backend_get_device.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_get_device(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_get_device$handle() {
        return ggml_backend_get_device.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_get_device(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_get_device$address() {
        return ggml_backend_get_device.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_get_device(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_get_device(MemorySegment backend) {
        var mh$ = ggml_backend_get_device.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_get_device", backend);
            }
            return (MemorySegment)mh$.invokeExact(backend);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_event_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_event_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_event_t ggml_backend_event_new(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_event_new$descriptor() {
        return ggml_backend_event_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_event_t ggml_backend_event_new(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_event_new$handle() {
        return ggml_backend_event_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_event_t ggml_backend_event_new(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_event_new$address() {
        return ggml_backend_event_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_event_t ggml_backend_event_new(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_event_new(MemorySegment device) {
        var mh$ = ggml_backend_event_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_event_new", device);
            }
            return (MemorySegment)mh$.invokeExact(device);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_event_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_event_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_free(ggml_backend_event_t event)
     * }
     */
    public static FunctionDescriptor ggml_backend_event_free$descriptor() {
        return ggml_backend_event_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_free(ggml_backend_event_t event)
     * }
     */
    public static MethodHandle ggml_backend_event_free$handle() {
        return ggml_backend_event_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_free(ggml_backend_event_t event)
     * }
     */
    public static MemorySegment ggml_backend_event_free$address() {
        return ggml_backend_event_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_event_free(ggml_backend_event_t event)
     * }
     */
    public static void ggml_backend_event_free(MemorySegment event) {
        var mh$ = ggml_backend_event_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_event_free", event);
            }
            mh$.invokeExact(event);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_event_record {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_event_record");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_record(ggml_backend_event_t event, ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_event_record$descriptor() {
        return ggml_backend_event_record.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_record(ggml_backend_event_t event, ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_event_record$handle() {
        return ggml_backend_event_record.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_record(ggml_backend_event_t event, ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_event_record$address() {
        return ggml_backend_event_record.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_event_record(ggml_backend_event_t event, ggml_backend_t backend)
     * }
     */
    public static void ggml_backend_event_record(MemorySegment event, MemorySegment backend) {
        var mh$ = ggml_backend_event_record.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_event_record", event, backend);
            }
            mh$.invokeExact(event, backend);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_event_synchronize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_event_synchronize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_synchronize(ggml_backend_event_t event)
     * }
     */
    public static FunctionDescriptor ggml_backend_event_synchronize$descriptor() {
        return ggml_backend_event_synchronize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_synchronize(ggml_backend_event_t event)
     * }
     */
    public static MethodHandle ggml_backend_event_synchronize$handle() {
        return ggml_backend_event_synchronize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_synchronize(ggml_backend_event_t event)
     * }
     */
    public static MemorySegment ggml_backend_event_synchronize$address() {
        return ggml_backend_event_synchronize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_event_synchronize(ggml_backend_event_t event)
     * }
     */
    public static void ggml_backend_event_synchronize(MemorySegment event) {
        var mh$ = ggml_backend_event_synchronize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_event_synchronize", event);
            }
            mh$.invokeExact(event);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_event_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_event_wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_wait(ggml_backend_t backend, ggml_backend_event_t event)
     * }
     */
    public static FunctionDescriptor ggml_backend_event_wait$descriptor() {
        return ggml_backend_event_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_wait(ggml_backend_t backend, ggml_backend_event_t event)
     * }
     */
    public static MethodHandle ggml_backend_event_wait$handle() {
        return ggml_backend_event_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_event_wait(ggml_backend_t backend, ggml_backend_event_t event)
     * }
     */
    public static MemorySegment ggml_backend_event_wait$address() {
        return ggml_backend_event_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_event_wait(ggml_backend_t backend, ggml_backend_event_t event)
     * }
     */
    public static void ggml_backend_event_wait(MemorySegment backend, MemorySegment event) {
        var mh$ = ggml_backend_event_wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_event_wait", backend, event);
            }
            mh$.invokeExact(backend, event);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_BACKEND_DEVICE_TYPE_CPU = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_backend_dev_type.GGML_BACKEND_DEVICE_TYPE_CPU = 0
     * }
     */
    public static int GGML_BACKEND_DEVICE_TYPE_CPU() {
        return GGML_BACKEND_DEVICE_TYPE_CPU;
    }
    private static final int GGML_BACKEND_DEVICE_TYPE_GPU = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_backend_dev_type.GGML_BACKEND_DEVICE_TYPE_GPU = 1
     * }
     */
    public static int GGML_BACKEND_DEVICE_TYPE_GPU() {
        return GGML_BACKEND_DEVICE_TYPE_GPU;
    }
    private static final int GGML_BACKEND_DEVICE_TYPE_ACCEL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_backend_dev_type.GGML_BACKEND_DEVICE_TYPE_ACCEL = 2
     * }
     */
    public static int GGML_BACKEND_DEVICE_TYPE_ACCEL() {
        return GGML_BACKEND_DEVICE_TYPE_ACCEL;
    }

    private static class ggml_backend_dev_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_dev_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_name(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_name$descriptor() {
        return ggml_backend_dev_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_name(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_dev_name$handle() {
        return ggml_backend_dev_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_name(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_name$address() {
        return ggml_backend_dev_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_name(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_name(MemorySegment device) {
        var mh$ = ggml_backend_dev_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_name", device);
            }
            return (MemorySegment)mh$.invokeExact(device);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_description {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_dev_description");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_description(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_description$descriptor() {
        return ggml_backend_dev_description.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_description(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_dev_description$handle() {
        return ggml_backend_dev_description.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_description(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_description$address() {
        return ggml_backend_dev_description.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_backend_dev_description(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_description(MemorySegment device) {
        var mh$ = ggml_backend_dev_description.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_description", device);
            }
            return (MemorySegment)mh$.invokeExact(device);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_memory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_dev_memory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_dev_memory(ggml_backend_dev_t device, size_t *free, size_t *total)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_memory$descriptor() {
        return ggml_backend_dev_memory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_dev_memory(ggml_backend_dev_t device, size_t *free, size_t *total)
     * }
     */
    public static MethodHandle ggml_backend_dev_memory$handle() {
        return ggml_backend_dev_memory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_dev_memory(ggml_backend_dev_t device, size_t *free, size_t *total)
     * }
     */
    public static MemorySegment ggml_backend_dev_memory$address() {
        return ggml_backend_dev_memory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_dev_memory(ggml_backend_dev_t device, size_t *free, size_t *total)
     * }
     */
    public static void ggml_backend_dev_memory(MemorySegment device, MemorySegment free, MemorySegment total) {
        var mh$ = ggml_backend_dev_memory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_memory", device, free, total);
            }
            mh$.invokeExact(device, free, total);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_dev_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_backend_dev_type ggml_backend_dev_type(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_type$descriptor() {
        return ggml_backend_dev_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_backend_dev_type ggml_backend_dev_type(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_dev_type$handle() {
        return ggml_backend_dev_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_backend_dev_type ggml_backend_dev_type(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_type$address() {
        return ggml_backend_dev_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_backend_dev_type ggml_backend_dev_type(ggml_backend_dev_t device)
     * }
     */
    public static int ggml_backend_dev_type(MemorySegment device) {
        var mh$ = ggml_backend_dev_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_type", device);
            }
            return (int)mh$.invokeExact(device);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_get_props {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_dev_get_props");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_dev_get_props(ggml_backend_dev_t device, struct ggml_backend_dev_props *props)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_get_props$descriptor() {
        return ggml_backend_dev_get_props.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_dev_get_props(ggml_backend_dev_t device, struct ggml_backend_dev_props *props)
     * }
     */
    public static MethodHandle ggml_backend_dev_get_props$handle() {
        return ggml_backend_dev_get_props.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_dev_get_props(ggml_backend_dev_t device, struct ggml_backend_dev_props *props)
     * }
     */
    public static MemorySegment ggml_backend_dev_get_props$address() {
        return ggml_backend_dev_get_props.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_dev_get_props(ggml_backend_dev_t device, struct ggml_backend_dev_props *props)
     * }
     */
    public static void ggml_backend_dev_get_props(MemorySegment device, MemorySegment props) {
        var mh$ = ggml_backend_dev_get_props.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_get_props", device, props);
            }
            mh$.invokeExact(device, props);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_backend_reg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_dev_backend_reg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_dev_backend_reg(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_backend_reg$descriptor() {
        return ggml_backend_dev_backend_reg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_dev_backend_reg(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_dev_backend_reg$handle() {
        return ggml_backend_dev_backend_reg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_dev_backend_reg(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_backend_reg$address() {
        return ggml_backend_dev_backend_reg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_dev_backend_reg(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_backend_reg(MemorySegment device) {
        var mh$ = ggml_backend_dev_backend_reg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_backend_reg", device);
            }
            return (MemorySegment)mh$.invokeExact(device);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_dev_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_dev_init(ggml_backend_dev_t device, const char *params)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_init$descriptor() {
        return ggml_backend_dev_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_dev_init(ggml_backend_dev_t device, const char *params)
     * }
     */
    public static MethodHandle ggml_backend_dev_init$handle() {
        return ggml_backend_dev_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_dev_init(ggml_backend_dev_t device, const char *params)
     * }
     */
    public static MemorySegment ggml_backend_dev_init$address() {
        return ggml_backend_dev_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_dev_init(ggml_backend_dev_t device, const char *params)
     * }
     */
    public static MemorySegment ggml_backend_dev_init(MemorySegment device, MemorySegment params) {
        var mh$ = ggml_backend_dev_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_init", device, params);
            }
            return (MemorySegment)mh$.invokeExact(device, params);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_buffer_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_dev_buffer_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_buffer_type$descriptor() {
        return ggml_backend_dev_buffer_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_dev_buffer_type$handle() {
        return ggml_backend_dev_buffer_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_buffer_type$address() {
        return ggml_backend_dev_buffer_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_buffer_type(MemorySegment device) {
        var mh$ = ggml_backend_dev_buffer_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_buffer_type", device);
            }
            return (MemorySegment)mh$.invokeExact(device);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_host_buffer_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_dev_host_buffer_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_host_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_host_buffer_type$descriptor() {
        return ggml_backend_dev_host_buffer_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_host_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_dev_host_buffer_type$handle() {
        return ggml_backend_dev_host_buffer_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_host_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_host_buffer_type$address() {
        return ggml_backend_dev_host_buffer_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_dev_host_buffer_type(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_dev_host_buffer_type(MemorySegment device) {
        var mh$ = ggml_backend_dev_host_buffer_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_host_buffer_type", device);
            }
            return (MemorySegment)mh$.invokeExact(device);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_buffer_from_host_ptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_dev_buffer_from_host_ptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_dev_buffer_from_host_ptr(ggml_backend_dev_t device, void *ptr, size_t size, size_t max_tensor_size)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_buffer_from_host_ptr$descriptor() {
        return ggml_backend_dev_buffer_from_host_ptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_dev_buffer_from_host_ptr(ggml_backend_dev_t device, void *ptr, size_t size, size_t max_tensor_size)
     * }
     */
    public static MethodHandle ggml_backend_dev_buffer_from_host_ptr$handle() {
        return ggml_backend_dev_buffer_from_host_ptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_dev_buffer_from_host_ptr(ggml_backend_dev_t device, void *ptr, size_t size, size_t max_tensor_size)
     * }
     */
    public static MemorySegment ggml_backend_dev_buffer_from_host_ptr$address() {
        return ggml_backend_dev_buffer_from_host_ptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_dev_buffer_from_host_ptr(ggml_backend_dev_t device, void *ptr, size_t size, size_t max_tensor_size)
     * }
     */
    public static MemorySegment ggml_backend_dev_buffer_from_host_ptr(MemorySegment device, MemorySegment ptr, long size, long max_tensor_size) {
        var mh$ = ggml_backend_dev_buffer_from_host_ptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_buffer_from_host_ptr", device, ptr, size, max_tensor_size);
            }
            return (MemorySegment)mh$.invokeExact(device, ptr, size, max_tensor_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_supports_op {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_dev_supports_op");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_supports_op$descriptor() {
        return ggml_backend_dev_supports_op.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static MethodHandle ggml_backend_dev_supports_op$handle() {
        return ggml_backend_dev_supports_op.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static MemorySegment ggml_backend_dev_supports_op$address() {
        return ggml_backend_dev_supports_op.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static boolean ggml_backend_dev_supports_op(MemorySegment device, MemorySegment op) {
        var mh$ = ggml_backend_dev_supports_op.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_supports_op", device, op);
            }
            return (boolean)mh$.invokeExact(device, op);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_supports_buft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_dev_supports_buft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_buft(ggml_backend_dev_t device, ggml_backend_buffer_type_t buft)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_supports_buft$descriptor() {
        return ggml_backend_dev_supports_buft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_buft(ggml_backend_dev_t device, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MethodHandle ggml_backend_dev_supports_buft$handle() {
        return ggml_backend_dev_supports_buft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_buft(ggml_backend_dev_t device, ggml_backend_buffer_type_t buft)
     * }
     */
    public static MemorySegment ggml_backend_dev_supports_buft$address() {
        return ggml_backend_dev_supports_buft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_supports_buft(ggml_backend_dev_t device, ggml_backend_buffer_type_t buft)
     * }
     */
    public static boolean ggml_backend_dev_supports_buft(MemorySegment device, MemorySegment buft) {
        var mh$ = ggml_backend_dev_supports_buft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_supports_buft", device, buft);
            }
            return (boolean)mh$.invokeExact(device, buft);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_offload_op {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_dev_offload_op");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_offload_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_offload_op$descriptor() {
        return ggml_backend_dev_offload_op.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_offload_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static MethodHandle ggml_backend_dev_offload_op$handle() {
        return ggml_backend_dev_offload_op.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_offload_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static MemorySegment ggml_backend_dev_offload_op$address() {
        return ggml_backend_dev_offload_op.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_dev_offload_op(ggml_backend_dev_t device, const struct ggml_tensor *op)
     * }
     */
    public static boolean ggml_backend_dev_offload_op(MemorySegment device, MemorySegment op) {
        var mh$ = ggml_backend_dev_offload_op.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_offload_op", device, op);
            }
            return (boolean)mh$.invokeExact(device, op);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_reg_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_reg_name(ggml_backend_reg_t reg)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_name$descriptor() {
        return ggml_backend_reg_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_reg_name(ggml_backend_reg_t reg)
     * }
     */
    public static MethodHandle ggml_backend_reg_name$handle() {
        return ggml_backend_reg_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *ggml_backend_reg_name(ggml_backend_reg_t reg)
     * }
     */
    public static MemorySegment ggml_backend_reg_name$address() {
        return ggml_backend_reg_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *ggml_backend_reg_name(ggml_backend_reg_t reg)
     * }
     */
    public static MemorySegment ggml_backend_reg_name(MemorySegment reg) {
        var mh$ = ggml_backend_reg_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_name", reg);
            }
            return (MemorySegment)mh$.invokeExact(reg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_dev_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_reg_dev_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_dev_count(ggml_backend_reg_t reg)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_dev_count$descriptor() {
        return ggml_backend_reg_dev_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_dev_count(ggml_backend_reg_t reg)
     * }
     */
    public static MethodHandle ggml_backend_reg_dev_count$handle() {
        return ggml_backend_reg_dev_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_dev_count(ggml_backend_reg_t reg)
     * }
     */
    public static MemorySegment ggml_backend_reg_dev_count$address() {
        return ggml_backend_reg_dev_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_dev_count(ggml_backend_reg_t reg)
     * }
     */
    public static long ggml_backend_reg_dev_count(MemorySegment reg) {
        var mh$ = ggml_backend_reg_dev_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_dev_count", reg);
            }
            return (long)mh$.invokeExact(reg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_dev_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_reg_dev_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_reg_dev_get(ggml_backend_reg_t reg, size_t index)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_dev_get$descriptor() {
        return ggml_backend_reg_dev_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_reg_dev_get(ggml_backend_reg_t reg, size_t index)
     * }
     */
    public static MethodHandle ggml_backend_reg_dev_get$handle() {
        return ggml_backend_reg_dev_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_reg_dev_get(ggml_backend_reg_t reg, size_t index)
     * }
     */
    public static MemorySegment ggml_backend_reg_dev_get$address() {
        return ggml_backend_reg_dev_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_reg_dev_get(ggml_backend_reg_t reg, size_t index)
     * }
     */
    public static MemorySegment ggml_backend_reg_dev_get(MemorySegment reg, long index) {
        var mh$ = ggml_backend_reg_dev_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_dev_get", reg, index);
            }
            return (MemorySegment)mh$.invokeExact(reg, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_get_proc_address {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_reg_get_proc_address");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *ggml_backend_reg_get_proc_address(ggml_backend_reg_t reg, const char *name)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_get_proc_address$descriptor() {
        return ggml_backend_reg_get_proc_address.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *ggml_backend_reg_get_proc_address(ggml_backend_reg_t reg, const char *name)
     * }
     */
    public static MethodHandle ggml_backend_reg_get_proc_address$handle() {
        return ggml_backend_reg_get_proc_address.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *ggml_backend_reg_get_proc_address(ggml_backend_reg_t reg, const char *name)
     * }
     */
    public static MemorySegment ggml_backend_reg_get_proc_address$address() {
        return ggml_backend_reg_get_proc_address.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *ggml_backend_reg_get_proc_address(ggml_backend_reg_t reg, const char *name)
     * }
     */
    public static MemorySegment ggml_backend_reg_get_proc_address(MemorySegment reg, MemorySegment name) {
        var mh$ = ggml_backend_reg_get_proc_address.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_get_proc_address", reg, name);
            }
            return (MemorySegment)mh$.invokeExact(reg, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_device_register {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_device_register");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_device_register(ggml_backend_dev_t device)
     * }
     */
    public static FunctionDescriptor ggml_backend_device_register$descriptor() {
        return ggml_backend_device_register.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_device_register(ggml_backend_dev_t device)
     * }
     */
    public static MethodHandle ggml_backend_device_register$handle() {
        return ggml_backend_device_register.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_device_register(ggml_backend_dev_t device)
     * }
     */
    public static MemorySegment ggml_backend_device_register$address() {
        return ggml_backend_device_register.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_device_register(ggml_backend_dev_t device)
     * }
     */
    public static void ggml_backend_device_register(MemorySegment device) {
        var mh$ = ggml_backend_device_register.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_device_register", device);
            }
            mh$.invokeExact(device);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_reg_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_count(void)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_count$descriptor() {
        return ggml_backend_reg_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_count(void)
     * }
     */
    public static MethodHandle ggml_backend_reg_count$handle() {
        return ggml_backend_reg_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_count(void)
     * }
     */
    public static MemorySegment ggml_backend_reg_count$address() {
        return ggml_backend_reg_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_reg_count(void)
     * }
     */
    public static long ggml_backend_reg_count() {
        var mh$ = ggml_backend_reg_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_count");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_reg_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_get(size_t index)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_get$descriptor() {
        return ggml_backend_reg_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_get(size_t index)
     * }
     */
    public static MethodHandle ggml_backend_reg_get$handle() {
        return ggml_backend_reg_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_get(size_t index)
     * }
     */
    public static MemorySegment ggml_backend_reg_get$address() {
        return ggml_backend_reg_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_get(size_t index)
     * }
     */
    public static MemorySegment ggml_backend_reg_get(long index) {
        var mh$ = ggml_backend_reg_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_get", index);
            }
            return (MemorySegment)mh$.invokeExact(index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_reg_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_reg_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_by_name(const char *name)
     * }
     */
    public static FunctionDescriptor ggml_backend_reg_by_name$descriptor() {
        return ggml_backend_reg_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_by_name(const char *name)
     * }
     */
    public static MethodHandle ggml_backend_reg_by_name$handle() {
        return ggml_backend_reg_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_by_name(const char *name)
     * }
     */
    public static MemorySegment ggml_backend_reg_by_name$address() {
        return ggml_backend_reg_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_reg_by_name(const char *name)
     * }
     */
    public static MemorySegment ggml_backend_reg_by_name(MemorySegment name) {
        var mh$ = ggml_backend_reg_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_reg_by_name", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_dev_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_dev_count(void)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_count$descriptor() {
        return ggml_backend_dev_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_dev_count(void)
     * }
     */
    public static MethodHandle ggml_backend_dev_count$handle() {
        return ggml_backend_dev_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_dev_count(void)
     * }
     */
    public static MemorySegment ggml_backend_dev_count$address() {
        return ggml_backend_dev_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_dev_count(void)
     * }
     */
    public static long ggml_backend_dev_count() {
        var mh$ = ggml_backend_dev_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_count");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_dev_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_get(size_t index)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_get$descriptor() {
        return ggml_backend_dev_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_get(size_t index)
     * }
     */
    public static MethodHandle ggml_backend_dev_get$handle() {
        return ggml_backend_dev_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_get(size_t index)
     * }
     */
    public static MemorySegment ggml_backend_dev_get$address() {
        return ggml_backend_dev_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_get(size_t index)
     * }
     */
    public static MemorySegment ggml_backend_dev_get(long index) {
        var mh$ = ggml_backend_dev_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_get", index);
            }
            return (MemorySegment)mh$.invokeExact(index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_dev_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_name(const char *name)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_by_name$descriptor() {
        return ggml_backend_dev_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_name(const char *name)
     * }
     */
    public static MethodHandle ggml_backend_dev_by_name$handle() {
        return ggml_backend_dev_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_name(const char *name)
     * }
     */
    public static MemorySegment ggml_backend_dev_by_name$address() {
        return ggml_backend_dev_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_name(const char *name)
     * }
     */
    public static MemorySegment ggml_backend_dev_by_name(MemorySegment name) {
        var mh$ = ggml_backend_dev_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_by_name", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_dev_by_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_dev_by_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_type(enum ggml_backend_dev_type type)
     * }
     */
    public static FunctionDescriptor ggml_backend_dev_by_type$descriptor() {
        return ggml_backend_dev_by_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_type(enum ggml_backend_dev_type type)
     * }
     */
    public static MethodHandle ggml_backend_dev_by_type$handle() {
        return ggml_backend_dev_by_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_type(enum ggml_backend_dev_type type)
     * }
     */
    public static MemorySegment ggml_backend_dev_by_type$address() {
        return ggml_backend_dev_by_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_dev_t ggml_backend_dev_by_type(enum ggml_backend_dev_type type)
     * }
     */
    public static MemorySegment ggml_backend_dev_by_type(int type) {
        var mh$ = ggml_backend_dev_by_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_dev_by_type", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_init_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_init_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_name(const char *name, const char *params)
     * }
     */
    public static FunctionDescriptor ggml_backend_init_by_name$descriptor() {
        return ggml_backend_init_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_name(const char *name, const char *params)
     * }
     */
    public static MethodHandle ggml_backend_init_by_name$handle() {
        return ggml_backend_init_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_name(const char *name, const char *params)
     * }
     */
    public static MemorySegment ggml_backend_init_by_name$address() {
        return ggml_backend_init_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_name(const char *name, const char *params)
     * }
     */
    public static MemorySegment ggml_backend_init_by_name(MemorySegment name, MemorySegment params) {
        var mh$ = ggml_backend_init_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_init_by_name", name, params);
            }
            return (MemorySegment)mh$.invokeExact(name, params);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_init_by_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_init_by_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_type(enum ggml_backend_dev_type type, const char *params)
     * }
     */
    public static FunctionDescriptor ggml_backend_init_by_type$descriptor() {
        return ggml_backend_init_by_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_type(enum ggml_backend_dev_type type, const char *params)
     * }
     */
    public static MethodHandle ggml_backend_init_by_type$handle() {
        return ggml_backend_init_by_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_type(enum ggml_backend_dev_type type, const char *params)
     * }
     */
    public static MemorySegment ggml_backend_init_by_type$address() {
        return ggml_backend_init_by_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_by_type(enum ggml_backend_dev_type type, const char *params)
     * }
     */
    public static MemorySegment ggml_backend_init_by_type(int type, MemorySegment params) {
        var mh$ = ggml_backend_init_by_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_init_by_type", type, params);
            }
            return (MemorySegment)mh$.invokeExact(type, params);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_init_best {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_init_best");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_best(void)
     * }
     */
    public static FunctionDescriptor ggml_backend_init_best$descriptor() {
        return ggml_backend_init_best.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_best(void)
     * }
     */
    public static MethodHandle ggml_backend_init_best$handle() {
        return ggml_backend_init_best.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_best(void)
     * }
     */
    public static MemorySegment ggml_backend_init_best$address() {
        return ggml_backend_init_best.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_init_best(void)
     * }
     */
    public static MemorySegment ggml_backend_init_best() {
        var mh$ = ggml_backend_init_best.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_init_best");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_load {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_load");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_load(const char *path)
     * }
     */
    public static FunctionDescriptor ggml_backend_load$descriptor() {
        return ggml_backend_load.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_load(const char *path)
     * }
     */
    public static MethodHandle ggml_backend_load$handle() {
        return ggml_backend_load.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_load(const char *path)
     * }
     */
    public static MemorySegment ggml_backend_load$address() {
        return ggml_backend_load.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_load(const char *path)
     * }
     */
    public static MemorySegment ggml_backend_load(MemorySegment path) {
        var mh$ = ggml_backend_load.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_load", path);
            }
            return (MemorySegment)mh$.invokeExact(path);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_unload {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_unload");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_unload(ggml_backend_reg_t reg)
     * }
     */
    public static FunctionDescriptor ggml_backend_unload$descriptor() {
        return ggml_backend_unload.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_unload(ggml_backend_reg_t reg)
     * }
     */
    public static MethodHandle ggml_backend_unload$handle() {
        return ggml_backend_unload.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_unload(ggml_backend_reg_t reg)
     * }
     */
    public static MemorySegment ggml_backend_unload$address() {
        return ggml_backend_unload.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_unload(ggml_backend_reg_t reg)
     * }
     */
    public static void ggml_backend_unload(MemorySegment reg) {
        var mh$ = ggml_backend_unload.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_unload", reg);
            }
            mh$.invokeExact(reg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_load_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_load_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_load_all(void)
     * }
     */
    public static FunctionDescriptor ggml_backend_load_all$descriptor() {
        return ggml_backend_load_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_load_all(void)
     * }
     */
    public static MethodHandle ggml_backend_load_all$handle() {
        return ggml_backend_load_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_load_all(void)
     * }
     */
    public static MemorySegment ggml_backend_load_all$address() {
        return ggml_backend_load_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_load_all(void)
     * }
     */
    public static void ggml_backend_load_all() {
        var mh$ = ggml_backend_load_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_load_all");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_load_all_from_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_load_all_from_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_load_all_from_path(const char *dir_path)
     * }
     */
    public static FunctionDescriptor ggml_backend_load_all_from_path$descriptor() {
        return ggml_backend_load_all_from_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_load_all_from_path(const char *dir_path)
     * }
     */
    public static MethodHandle ggml_backend_load_all_from_path$handle() {
        return ggml_backend_load_all_from_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_load_all_from_path(const char *dir_path)
     * }
     */
    public static MemorySegment ggml_backend_load_all_from_path$address() {
        return ggml_backend_load_all_from_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_load_all_from_path(const char *dir_path)
     * }
     */
    public static void ggml_backend_load_all_from_path(MemorySegment dir_path) {
        var mh$ = ggml_backend_load_all_from_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_load_all_from_path", dir_path);
            }
            mh$.invokeExact(dir_path);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct ggml_backend_sched *ggml_backend_sched_t
     * }
     */
    public static final AddressLayout ggml_backend_sched_t = llama_h.C_POINTER;

    private static class ggml_backend_sched_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_LONG,
            llama_h.C_BOOL,
            llama_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_sched_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_sched_t ggml_backend_sched_new(ggml_backend_t *backends, ggml_backend_buffer_type_t *bufts, int n_backends, size_t graph_size, bool parallel, bool op_offload)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_new$descriptor() {
        return ggml_backend_sched_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_sched_t ggml_backend_sched_new(ggml_backend_t *backends, ggml_backend_buffer_type_t *bufts, int n_backends, size_t graph_size, bool parallel, bool op_offload)
     * }
     */
    public static MethodHandle ggml_backend_sched_new$handle() {
        return ggml_backend_sched_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_sched_t ggml_backend_sched_new(ggml_backend_t *backends, ggml_backend_buffer_type_t *bufts, int n_backends, size_t graph_size, bool parallel, bool op_offload)
     * }
     */
    public static MemorySegment ggml_backend_sched_new$address() {
        return ggml_backend_sched_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_sched_t ggml_backend_sched_new(ggml_backend_t *backends, ggml_backend_buffer_type_t *bufts, int n_backends, size_t graph_size, bool parallel, bool op_offload)
     * }
     */
    public static MemorySegment ggml_backend_sched_new(MemorySegment backends, MemorySegment bufts, int n_backends, long graph_size, boolean parallel, boolean op_offload) {
        var mh$ = ggml_backend_sched_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_new", backends, bufts, n_backends, graph_size, parallel, op_offload);
            }
            return (MemorySegment)mh$.invokeExact(backends, bufts, n_backends, graph_size, parallel, op_offload);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_sched_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_free(ggml_backend_sched_t sched)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_free$descriptor() {
        return ggml_backend_sched_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_free(ggml_backend_sched_t sched)
     * }
     */
    public static MethodHandle ggml_backend_sched_free$handle() {
        return ggml_backend_sched_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_free(ggml_backend_sched_t sched)
     * }
     */
    public static MemorySegment ggml_backend_sched_free$address() {
        return ggml_backend_sched_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_sched_free(ggml_backend_sched_t sched)
     * }
     */
    public static void ggml_backend_sched_free(MemorySegment sched) {
        var mh$ = ggml_backend_sched_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_free", sched);
            }
            mh$.invokeExact(sched);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_reserve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_sched_reserve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_reserve(ggml_backend_sched_t sched, struct ggml_cgraph *measure_graph)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_reserve$descriptor() {
        return ggml_backend_sched_reserve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_reserve(ggml_backend_sched_t sched, struct ggml_cgraph *measure_graph)
     * }
     */
    public static MethodHandle ggml_backend_sched_reserve$handle() {
        return ggml_backend_sched_reserve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_reserve(ggml_backend_sched_t sched, struct ggml_cgraph *measure_graph)
     * }
     */
    public static MemorySegment ggml_backend_sched_reserve$address() {
        return ggml_backend_sched_reserve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_reserve(ggml_backend_sched_t sched, struct ggml_cgraph *measure_graph)
     * }
     */
    public static boolean ggml_backend_sched_reserve(MemorySegment sched, MemorySegment measure_graph) {
        var mh$ = ggml_backend_sched_reserve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_reserve", sched, measure_graph);
            }
            return (boolean)mh$.invokeExact(sched, measure_graph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_get_n_backends {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_sched_get_n_backends");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_backends(ggml_backend_sched_t sched)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_get_n_backends$descriptor() {
        return ggml_backend_sched_get_n_backends.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_backends(ggml_backend_sched_t sched)
     * }
     */
    public static MethodHandle ggml_backend_sched_get_n_backends$handle() {
        return ggml_backend_sched_get_n_backends.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_backends(ggml_backend_sched_t sched)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_n_backends$address() {
        return ggml_backend_sched_get_n_backends.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_backends(ggml_backend_sched_t sched)
     * }
     */
    public static int ggml_backend_sched_get_n_backends(MemorySegment sched) {
        var mh$ = ggml_backend_sched_get_n_backends.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_get_n_backends", sched);
            }
            return (int)mh$.invokeExact(sched);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_get_backend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_sched_get_backend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_backend(ggml_backend_sched_t sched, int i)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_get_backend$descriptor() {
        return ggml_backend_sched_get_backend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_backend(ggml_backend_sched_t sched, int i)
     * }
     */
    public static MethodHandle ggml_backend_sched_get_backend$handle() {
        return ggml_backend_sched_get_backend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_backend(ggml_backend_sched_t sched, int i)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_backend$address() {
        return ggml_backend_sched_get_backend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_backend(ggml_backend_sched_t sched, int i)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_backend(MemorySegment sched, int i) {
        var mh$ = ggml_backend_sched_get_backend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_get_backend", sched, i);
            }
            return (MemorySegment)mh$.invokeExact(sched, i);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_get_n_splits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_sched_get_n_splits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_splits(ggml_backend_sched_t sched)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_get_n_splits$descriptor() {
        return ggml_backend_sched_get_n_splits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_splits(ggml_backend_sched_t sched)
     * }
     */
    public static MethodHandle ggml_backend_sched_get_n_splits$handle() {
        return ggml_backend_sched_get_n_splits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_splits(ggml_backend_sched_t sched)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_n_splits$address() {
        return ggml_backend_sched_get_n_splits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_splits(ggml_backend_sched_t sched)
     * }
     */
    public static int ggml_backend_sched_get_n_splits(MemorySegment sched) {
        var mh$ = ggml_backend_sched_get_n_splits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_get_n_splits", sched);
            }
            return (int)mh$.invokeExact(sched);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_get_n_copies {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_sched_get_n_copies");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_copies(ggml_backend_sched_t sched)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_get_n_copies$descriptor() {
        return ggml_backend_sched_get_n_copies.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_copies(ggml_backend_sched_t sched)
     * }
     */
    public static MethodHandle ggml_backend_sched_get_n_copies$handle() {
        return ggml_backend_sched_get_n_copies.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_copies(ggml_backend_sched_t sched)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_n_copies$address() {
        return ggml_backend_sched_get_n_copies.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_backend_sched_get_n_copies(ggml_backend_sched_t sched)
     * }
     */
    public static int ggml_backend_sched_get_n_copies(MemorySegment sched) {
        var mh$ = ggml_backend_sched_get_n_copies.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_get_n_copies", sched);
            }
            return (int)mh$.invokeExact(sched);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_get_buffer_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_sched_get_buffer_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_sched_get_buffer_size(ggml_backend_sched_t sched, ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_get_buffer_size$descriptor() {
        return ggml_backend_sched_get_buffer_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_sched_get_buffer_size(ggml_backend_sched_t sched, ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_sched_get_buffer_size$handle() {
        return ggml_backend_sched_get_buffer_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t ggml_backend_sched_get_buffer_size(ggml_backend_sched_t sched, ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_buffer_size$address() {
        return ggml_backend_sched_get_buffer_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t ggml_backend_sched_get_buffer_size(ggml_backend_sched_t sched, ggml_backend_t backend)
     * }
     */
    public static long ggml_backend_sched_get_buffer_size(MemorySegment sched, MemorySegment backend) {
        var mh$ = ggml_backend_sched_get_buffer_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_get_buffer_size", sched, backend);
            }
            return (long)mh$.invokeExact(sched, backend);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_set_tensor_backend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_sched_set_tensor_backend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node, ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_set_tensor_backend$descriptor() {
        return ggml_backend_sched_set_tensor_backend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node, ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_sched_set_tensor_backend$handle() {
        return ggml_backend_sched_set_tensor_backend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node, ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_sched_set_tensor_backend$address() {
        return ggml_backend_sched_set_tensor_backend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node, ggml_backend_t backend)
     * }
     */
    public static void ggml_backend_sched_set_tensor_backend(MemorySegment sched, MemorySegment node, MemorySegment backend) {
        var mh$ = ggml_backend_sched_set_tensor_backend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_set_tensor_backend", sched, node, backend);
            }
            mh$.invokeExact(sched, node, backend);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_get_tensor_backend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_sched_get_tensor_backend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_get_tensor_backend$descriptor() {
        return ggml_backend_sched_get_tensor_backend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node)
     * }
     */
    public static MethodHandle ggml_backend_sched_get_tensor_backend$handle() {
        return ggml_backend_sched_get_tensor_backend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_tensor_backend$address() {
        return ggml_backend_sched_get_tensor_backend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_sched_get_tensor_backend(ggml_backend_sched_t sched, struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_backend_sched_get_tensor_backend(MemorySegment sched, MemorySegment node) {
        var mh$ = ggml_backend_sched_get_tensor_backend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_get_tensor_backend", sched, node);
            }
            return (MemorySegment)mh$.invokeExact(sched, node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_alloc_graph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_sched_alloc_graph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_alloc_graph(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_alloc_graph$descriptor() {
        return ggml_backend_sched_alloc_graph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_alloc_graph(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static MethodHandle ggml_backend_sched_alloc_graph$handle() {
        return ggml_backend_sched_alloc_graph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_alloc_graph(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static MemorySegment ggml_backend_sched_alloc_graph$address() {
        return ggml_backend_sched_alloc_graph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_sched_alloc_graph(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static boolean ggml_backend_sched_alloc_graph(MemorySegment sched, MemorySegment graph) {
        var mh$ = ggml_backend_sched_alloc_graph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_alloc_graph", sched, graph);
            }
            return (boolean)mh$.invokeExact(sched, graph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_graph_compute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_sched_graph_compute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_graph_compute$descriptor() {
        return ggml_backend_sched_graph_compute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static MethodHandle ggml_backend_sched_graph_compute$handle() {
        return ggml_backend_sched_graph_compute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static MemorySegment ggml_backend_sched_graph_compute$address() {
        return ggml_backend_sched_graph_compute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static int ggml_backend_sched_graph_compute(MemorySegment sched, MemorySegment graph) {
        var mh$ = ggml_backend_sched_graph_compute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_graph_compute", sched, graph);
            }
            return (int)mh$.invokeExact(sched, graph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_graph_compute_async {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_sched_graph_compute_async");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute_async(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_graph_compute_async$descriptor() {
        return ggml_backend_sched_graph_compute_async.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute_async(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static MethodHandle ggml_backend_sched_graph_compute_async$handle() {
        return ggml_backend_sched_graph_compute_async.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute_async(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static MemorySegment ggml_backend_sched_graph_compute_async$address() {
        return ggml_backend_sched_graph_compute_async.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_sched_graph_compute_async(ggml_backend_sched_t sched, struct ggml_cgraph *graph)
     * }
     */
    public static int ggml_backend_sched_graph_compute_async(MemorySegment sched, MemorySegment graph) {
        var mh$ = ggml_backend_sched_graph_compute_async.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_graph_compute_async", sched, graph);
            }
            return (int)mh$.invokeExact(sched, graph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_synchronize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_sched_synchronize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_synchronize(ggml_backend_sched_t sched)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_synchronize$descriptor() {
        return ggml_backend_sched_synchronize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_synchronize(ggml_backend_sched_t sched)
     * }
     */
    public static MethodHandle ggml_backend_sched_synchronize$handle() {
        return ggml_backend_sched_synchronize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_synchronize(ggml_backend_sched_t sched)
     * }
     */
    public static MemorySegment ggml_backend_sched_synchronize$address() {
        return ggml_backend_sched_synchronize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_sched_synchronize(ggml_backend_sched_t sched)
     * }
     */
    public static void ggml_backend_sched_synchronize(MemorySegment sched) {
        var mh$ = ggml_backend_sched_synchronize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_synchronize", sched);
            }
            mh$.invokeExact(sched);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_sched_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_reset(ggml_backend_sched_t sched)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_reset$descriptor() {
        return ggml_backend_sched_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_reset(ggml_backend_sched_t sched)
     * }
     */
    public static MethodHandle ggml_backend_sched_reset$handle() {
        return ggml_backend_sched_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_reset(ggml_backend_sched_t sched)
     * }
     */
    public static MemorySegment ggml_backend_sched_reset$address() {
        return ggml_backend_sched_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_sched_reset(ggml_backend_sched_t sched)
     * }
     */
    public static void ggml_backend_sched_reset(MemorySegment sched) {
        var mh$ = ggml_backend_sched_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_reset", sched);
            }
            mh$.invokeExact(sched);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_sched_set_eval_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_sched_set_eval_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_eval_callback(ggml_backend_sched_t sched, ggml_backend_sched_eval_callback callback, void *user_data)
     * }
     */
    public static FunctionDescriptor ggml_backend_sched_set_eval_callback$descriptor() {
        return ggml_backend_sched_set_eval_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_eval_callback(ggml_backend_sched_t sched, ggml_backend_sched_eval_callback callback, void *user_data)
     * }
     */
    public static MethodHandle ggml_backend_sched_set_eval_callback$handle() {
        return ggml_backend_sched_set_eval_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_eval_callback(ggml_backend_sched_t sched, ggml_backend_sched_eval_callback callback, void *user_data)
     * }
     */
    public static MemorySegment ggml_backend_sched_set_eval_callback$address() {
        return ggml_backend_sched_set_eval_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_sched_set_eval_callback(ggml_backend_sched_t sched, ggml_backend_sched_eval_callback callback, void *user_data)
     * }
     */
    public static void ggml_backend_sched_set_eval_callback(MemorySegment sched, MemorySegment callback, MemorySegment user_data) {
        var mh$ = ggml_backend_sched_set_eval_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_sched_set_eval_callback", sched, callback, user_data);
            }
            mh$.invokeExact(sched, callback, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_graph_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ggml_backend_graph_copy.layout(),
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_graph_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_backend_graph_copy ggml_backend_graph_copy(ggml_backend_t backend, struct ggml_cgraph *graph)
     * }
     */
    public static FunctionDescriptor ggml_backend_graph_copy$descriptor() {
        return ggml_backend_graph_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_backend_graph_copy ggml_backend_graph_copy(ggml_backend_t backend, struct ggml_cgraph *graph)
     * }
     */
    public static MethodHandle ggml_backend_graph_copy$handle() {
        return ggml_backend_graph_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_backend_graph_copy ggml_backend_graph_copy(ggml_backend_t backend, struct ggml_cgraph *graph)
     * }
     */
    public static MemorySegment ggml_backend_graph_copy$address() {
        return ggml_backend_graph_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_backend_graph_copy ggml_backend_graph_copy(ggml_backend_t backend, struct ggml_cgraph *graph)
     * }
     */
    public static MemorySegment ggml_backend_graph_copy(SegmentAllocator allocator, MemorySegment backend, MemorySegment graph) {
        var mh$ = ggml_backend_graph_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_graph_copy", allocator, backend, graph);
            }
            return (MemorySegment)mh$.invokeExact(allocator, backend, graph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_graph_copy_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            ggml_backend_graph_copy.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_graph_copy_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_graph_copy_free(struct ggml_backend_graph_copy copy)
     * }
     */
    public static FunctionDescriptor ggml_backend_graph_copy_free$descriptor() {
        return ggml_backend_graph_copy_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_graph_copy_free(struct ggml_backend_graph_copy copy)
     * }
     */
    public static MethodHandle ggml_backend_graph_copy_free$handle() {
        return ggml_backend_graph_copy_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_graph_copy_free(struct ggml_backend_graph_copy copy)
     * }
     */
    public static MemorySegment ggml_backend_graph_copy_free$address() {
        return ggml_backend_graph_copy_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_graph_copy_free(struct ggml_backend_graph_copy copy)
     * }
     */
    public static void ggml_backend_graph_copy_free(MemorySegment copy) {
        var mh$ = ggml_backend_graph_copy_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_graph_copy_free", copy);
            }
            mh$.invokeExact(copy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_compare_graph_backend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_compare_graph_backend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_compare_graph_backend(ggml_backend_t backend1, ggml_backend_t backend2, struct ggml_cgraph *graph, ggml_backend_eval_callback callback, void *user_data)
     * }
     */
    public static FunctionDescriptor ggml_backend_compare_graph_backend$descriptor() {
        return ggml_backend_compare_graph_backend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_compare_graph_backend(ggml_backend_t backend1, ggml_backend_t backend2, struct ggml_cgraph *graph, ggml_backend_eval_callback callback, void *user_data)
     * }
     */
    public static MethodHandle ggml_backend_compare_graph_backend$handle() {
        return ggml_backend_compare_graph_backend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_compare_graph_backend(ggml_backend_t backend1, ggml_backend_t backend2, struct ggml_cgraph *graph, ggml_backend_eval_callback callback, void *user_data)
     * }
     */
    public static MemorySegment ggml_backend_compare_graph_backend$address() {
        return ggml_backend_compare_graph_backend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_compare_graph_backend(ggml_backend_t backend1, ggml_backend_t backend2, struct ggml_cgraph *graph, ggml_backend_eval_callback callback, void *user_data)
     * }
     */
    public static boolean ggml_backend_compare_graph_backend(MemorySegment backend1, MemorySegment backend2, MemorySegment graph, MemorySegment callback, MemorySegment user_data) {
        var mh$ = ggml_backend_compare_graph_backend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_compare_graph_backend", backend1, backend2, graph, callback, user_data);
            }
            return (boolean)mh$.invokeExact(backend1, backend2, graph, callback, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_tensor_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_tensor_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_tensor_alloc(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor, void *addr)
     * }
     */
    public static FunctionDescriptor ggml_backend_tensor_alloc$descriptor() {
        return ggml_backend_tensor_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_tensor_alloc(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor, void *addr)
     * }
     */
    public static MethodHandle ggml_backend_tensor_alloc$handle() {
        return ggml_backend_tensor_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_tensor_alloc(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor, void *addr)
     * }
     */
    public static MemorySegment ggml_backend_tensor_alloc$address() {
        return ggml_backend_tensor_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_tensor_alloc(ggml_backend_buffer_t buffer, struct ggml_tensor *tensor, void *addr)
     * }
     */
    public static int ggml_backend_tensor_alloc(MemorySegment buffer, MemorySegment tensor, MemorySegment addr) {
        var mh$ = ggml_backend_tensor_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_tensor_alloc", buffer, tensor, addr);
            }
            return (int)mh$.invokeExact(buffer, tensor, addr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_view_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_view_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_view_init(struct ggml_tensor *tensor)
     * }
     */
    public static FunctionDescriptor ggml_backend_view_init$descriptor() {
        return ggml_backend_view_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_view_init(struct ggml_tensor *tensor)
     * }
     */
    public static MethodHandle ggml_backend_view_init$handle() {
        return ggml_backend_view_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_view_init(struct ggml_tensor *tensor)
     * }
     */
    public static MemorySegment ggml_backend_view_init$address() {
        return ggml_backend_view_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_backend_view_init(struct ggml_tensor *tensor)
     * }
     */
    public static int ggml_backend_view_init(MemorySegment tensor) {
        var mh$ = ggml_backend_view_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_view_init", tensor);
            }
            return (int)mh$.invokeExact(tensor);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_cpu_buffer_from_ptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_cpu_buffer_from_ptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_cpu_buffer_from_ptr(void *ptr, size_t size)
     * }
     */
    public static FunctionDescriptor ggml_backend_cpu_buffer_from_ptr$descriptor() {
        return ggml_backend_cpu_buffer_from_ptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_cpu_buffer_from_ptr(void *ptr, size_t size)
     * }
     */
    public static MethodHandle ggml_backend_cpu_buffer_from_ptr$handle() {
        return ggml_backend_cpu_buffer_from_ptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_cpu_buffer_from_ptr(void *ptr, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_cpu_buffer_from_ptr$address() {
        return ggml_backend_cpu_buffer_from_ptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_t ggml_backend_cpu_buffer_from_ptr(void *ptr, size_t size)
     * }
     */
    public static MemorySegment ggml_backend_cpu_buffer_from_ptr(MemorySegment ptr, long size) {
        var mh$ = ggml_backend_cpu_buffer_from_ptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_cpu_buffer_from_ptr", ptr, size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_cpu_buffer_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_cpu_buffer_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_cpu_buffer_type(void)
     * }
     */
    public static FunctionDescriptor ggml_backend_cpu_buffer_type$descriptor() {
        return ggml_backend_cpu_buffer_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_cpu_buffer_type(void)
     * }
     */
    public static MethodHandle ggml_backend_cpu_buffer_type$handle() {
        return ggml_backend_cpu_buffer_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_cpu_buffer_type(void)
     * }
     */
    public static MemorySegment ggml_backend_cpu_buffer_type$address() {
        return ggml_backend_cpu_buffer_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_buffer_type_t ggml_backend_cpu_buffer_type(void)
     * }
     */
    public static MemorySegment ggml_backend_cpu_buffer_type() {
        var mh$ = ggml_backend_cpu_buffer_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_cpu_buffer_type");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_NUMA_STRATEGY_DISABLED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_numa_strategy.GGML_NUMA_STRATEGY_DISABLED = 0
     * }
     */
    public static int GGML_NUMA_STRATEGY_DISABLED() {
        return GGML_NUMA_STRATEGY_DISABLED;
    }
    private static final int GGML_NUMA_STRATEGY_DISTRIBUTE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_numa_strategy.GGML_NUMA_STRATEGY_DISTRIBUTE = 1
     * }
     */
    public static int GGML_NUMA_STRATEGY_DISTRIBUTE() {
        return GGML_NUMA_STRATEGY_DISTRIBUTE;
    }
    private static final int GGML_NUMA_STRATEGY_ISOLATE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_numa_strategy.GGML_NUMA_STRATEGY_ISOLATE = 2
     * }
     */
    public static int GGML_NUMA_STRATEGY_ISOLATE() {
        return GGML_NUMA_STRATEGY_ISOLATE;
    }
    private static final int GGML_NUMA_STRATEGY_NUMACTL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_numa_strategy.GGML_NUMA_STRATEGY_NUMACTL = 3
     * }
     */
    public static int GGML_NUMA_STRATEGY_NUMACTL() {
        return GGML_NUMA_STRATEGY_NUMACTL;
    }
    private static final int GGML_NUMA_STRATEGY_MIRROR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ggml_numa_strategy.GGML_NUMA_STRATEGY_MIRROR = 4
     * }
     */
    public static int GGML_NUMA_STRATEGY_MIRROR() {
        return GGML_NUMA_STRATEGY_MIRROR;
    }
    private static final int GGML_NUMA_STRATEGY_COUNT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ggml_numa_strategy.GGML_NUMA_STRATEGY_COUNT = 5
     * }
     */
    public static int GGML_NUMA_STRATEGY_COUNT() {
        return GGML_NUMA_STRATEGY_COUNT;
    }

    private static class ggml_numa_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_numa_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_numa_init(enum ggml_numa_strategy numa)
     * }
     */
    public static FunctionDescriptor ggml_numa_init$descriptor() {
        return ggml_numa_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_numa_init(enum ggml_numa_strategy numa)
     * }
     */
    public static MethodHandle ggml_numa_init$handle() {
        return ggml_numa_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_numa_init(enum ggml_numa_strategy numa)
     * }
     */
    public static MemorySegment ggml_numa_init$address() {
        return ggml_numa_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_numa_init(enum ggml_numa_strategy numa)
     * }
     */
    public static void ggml_numa_init(int numa) {
        var mh$ = ggml_numa_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_numa_init", numa);
            }
            mh$.invokeExact(numa);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_is_numa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_is_numa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_is_numa(void)
     * }
     */
    public static FunctionDescriptor ggml_is_numa$descriptor() {
        return ggml_is_numa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_is_numa(void)
     * }
     */
    public static MethodHandle ggml_is_numa$handle() {
        return ggml_is_numa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_is_numa(void)
     * }
     */
    public static MemorySegment ggml_is_numa$address() {
        return ggml_is_numa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_is_numa(void)
     * }
     */
    public static boolean ggml_is_numa() {
        var mh$ = ggml_is_numa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_is_numa");
            }
            return (boolean)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_i32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_new_i32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_i32(struct ggml_context *ctx, int32_t value)
     * }
     */
    public static FunctionDescriptor ggml_new_i32$descriptor() {
        return ggml_new_i32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_i32(struct ggml_context *ctx, int32_t value)
     * }
     */
    public static MethodHandle ggml_new_i32$handle() {
        return ggml_new_i32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_i32(struct ggml_context *ctx, int32_t value)
     * }
     */
    public static MemorySegment ggml_new_i32$address() {
        return ggml_new_i32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_i32(struct ggml_context *ctx, int32_t value)
     * }
     */
    public static MemorySegment ggml_new_i32(MemorySegment ctx, int value) {
        var mh$ = ggml_new_i32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_i32", ctx, value);
            }
            return (MemorySegment)mh$.invokeExact(ctx, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_new_f32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_new_f32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_f32(struct ggml_context *ctx, float value)
     * }
     */
    public static FunctionDescriptor ggml_new_f32$descriptor() {
        return ggml_new_f32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_f32(struct ggml_context *ctx, float value)
     * }
     */
    public static MethodHandle ggml_new_f32$handle() {
        return ggml_new_f32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_f32(struct ggml_context *ctx, float value)
     * }
     */
    public static MemorySegment ggml_new_f32$address() {
        return ggml_new_f32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_new_f32(struct ggml_context *ctx, float value)
     * }
     */
    public static MemorySegment ggml_new_f32(MemorySegment ctx, float value) {
        var mh$ = ggml_new_f32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_new_f32", ctx, value);
            }
            return (MemorySegment)mh$.invokeExact(ctx, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_i32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_set_i32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_i32(struct ggml_tensor *tensor, int32_t value)
     * }
     */
    public static FunctionDescriptor ggml_set_i32$descriptor() {
        return ggml_set_i32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_i32(struct ggml_tensor *tensor, int32_t value)
     * }
     */
    public static MethodHandle ggml_set_i32$handle() {
        return ggml_set_i32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_i32(struct ggml_tensor *tensor, int32_t value)
     * }
     */
    public static MemorySegment ggml_set_i32$address() {
        return ggml_set_i32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_i32(struct ggml_tensor *tensor, int32_t value)
     * }
     */
    public static MemorySegment ggml_set_i32(MemorySegment tensor, int value) {
        var mh$ = ggml_set_i32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_i32", tensor, value);
            }
            return (MemorySegment)mh$.invokeExact(tensor, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_f32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_set_f32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_f32(struct ggml_tensor *tensor, float value)
     * }
     */
    public static FunctionDescriptor ggml_set_f32$descriptor() {
        return ggml_set_f32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_f32(struct ggml_tensor *tensor, float value)
     * }
     */
    public static MethodHandle ggml_set_f32$handle() {
        return ggml_set_f32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_f32(struct ggml_tensor *tensor, float value)
     * }
     */
    public static MemorySegment ggml_set_f32$address() {
        return ggml_set_f32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_set_f32(struct ggml_tensor *tensor, float value)
     * }
     */
    public static MemorySegment ggml_set_f32(MemorySegment tensor, float value) {
        var mh$ = ggml_set_f32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_f32", tensor, value);
            }
            return (MemorySegment)mh$.invokeExact(tensor, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_i32_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_get_i32_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static FunctionDescriptor ggml_get_i32_1d$descriptor() {
        return ggml_get_i32_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static MethodHandle ggml_get_i32_1d$handle() {
        return ggml_get_i32_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static MemorySegment ggml_get_i32_1d$address() {
        return ggml_get_i32_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static int ggml_get_i32_1d(MemorySegment tensor, int i) {
        var mh$ = ggml_get_i32_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_i32_1d", tensor, i);
            }
            return (int)mh$.invokeExact(tensor, i);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_i32_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_set_i32_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_i32_1d(const struct ggml_tensor *tensor, int i, int32_t value)
     * }
     */
    public static FunctionDescriptor ggml_set_i32_1d$descriptor() {
        return ggml_set_i32_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_i32_1d(const struct ggml_tensor *tensor, int i, int32_t value)
     * }
     */
    public static MethodHandle ggml_set_i32_1d$handle() {
        return ggml_set_i32_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_i32_1d(const struct ggml_tensor *tensor, int i, int32_t value)
     * }
     */
    public static MemorySegment ggml_set_i32_1d$address() {
        return ggml_set_i32_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_i32_1d(const struct ggml_tensor *tensor, int i, int32_t value)
     * }
     */
    public static void ggml_set_i32_1d(MemorySegment tensor, int i, int value) {
        var mh$ = ggml_set_i32_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_i32_1d", tensor, i, value);
            }
            mh$.invokeExact(tensor, i, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_i32_nd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_get_i32_nd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static FunctionDescriptor ggml_get_i32_nd$descriptor() {
        return ggml_get_i32_nd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static MethodHandle ggml_get_i32_nd$handle() {
        return ggml_get_i32_nd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static MemorySegment ggml_get_i32_nd$address() {
        return ggml_get_i32_nd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int32_t ggml_get_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static int ggml_get_i32_nd(MemorySegment tensor, int i0, int i1, int i2, int i3) {
        var mh$ = ggml_get_i32_nd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_i32_nd", tensor, i0, i1, i2, i3);
            }
            return (int)mh$.invokeExact(tensor, i0, i1, i2, i3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_i32_nd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_set_i32_nd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, int32_t value)
     * }
     */
    public static FunctionDescriptor ggml_set_i32_nd$descriptor() {
        return ggml_set_i32_nd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, int32_t value)
     * }
     */
    public static MethodHandle ggml_set_i32_nd$handle() {
        return ggml_set_i32_nd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, int32_t value)
     * }
     */
    public static MemorySegment ggml_set_i32_nd$address() {
        return ggml_set_i32_nd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_i32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, int32_t value)
     * }
     */
    public static void ggml_set_i32_nd(MemorySegment tensor, int i0, int i1, int i2, int i3, int value) {
        var mh$ = ggml_set_i32_nd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_i32_nd", tensor, i0, i1, i2, i3, value);
            }
            mh$.invokeExact(tensor, i0, i1, i2, i3, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_f32_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_FLOAT,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_get_f32_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ggml_get_f32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static FunctionDescriptor ggml_get_f32_1d$descriptor() {
        return ggml_get_f32_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ggml_get_f32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static MethodHandle ggml_get_f32_1d$handle() {
        return ggml_get_f32_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ggml_get_f32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static MemorySegment ggml_get_f32_1d$address() {
        return ggml_get_f32_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ggml_get_f32_1d(const struct ggml_tensor *tensor, int i)
     * }
     */
    public static float ggml_get_f32_1d(MemorySegment tensor, int i) {
        var mh$ = ggml_get_f32_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_f32_1d", tensor, i);
            }
            return (float)mh$.invokeExact(tensor, i);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_f32_1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_set_f32_1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_f32_1d(const struct ggml_tensor *tensor, int i, float value)
     * }
     */
    public static FunctionDescriptor ggml_set_f32_1d$descriptor() {
        return ggml_set_f32_1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_f32_1d(const struct ggml_tensor *tensor, int i, float value)
     * }
     */
    public static MethodHandle ggml_set_f32_1d$handle() {
        return ggml_set_f32_1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_f32_1d(const struct ggml_tensor *tensor, int i, float value)
     * }
     */
    public static MemorySegment ggml_set_f32_1d$address() {
        return ggml_set_f32_1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_f32_1d(const struct ggml_tensor *tensor, int i, float value)
     * }
     */
    public static void ggml_set_f32_1d(MemorySegment tensor, int i, float value) {
        var mh$ = ggml_set_f32_1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_f32_1d", tensor, i, value);
            }
            mh$.invokeExact(tensor, i, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_f32_nd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_FLOAT,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_get_f32_nd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ggml_get_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static FunctionDescriptor ggml_get_f32_nd$descriptor() {
        return ggml_get_f32_nd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ggml_get_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static MethodHandle ggml_get_f32_nd$handle() {
        return ggml_get_f32_nd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ggml_get_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static MemorySegment ggml_get_f32_nd$address() {
        return ggml_get_f32_nd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ggml_get_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3)
     * }
     */
    public static float ggml_get_f32_nd(MemorySegment tensor, int i0, int i1, int i2, int i3) {
        var mh$ = ggml_get_f32_nd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_f32_nd", tensor, i0, i1, i2, i3);
            }
            return (float)mh$.invokeExact(tensor, i0, i1, i2, i3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_set_f32_nd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_set_f32_nd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_set_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, float value)
     * }
     */
    public static FunctionDescriptor ggml_set_f32_nd$descriptor() {
        return ggml_set_f32_nd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_set_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, float value)
     * }
     */
    public static MethodHandle ggml_set_f32_nd$handle() {
        return ggml_set_f32_nd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_set_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, float value)
     * }
     */
    public static MemorySegment ggml_set_f32_nd$address() {
        return ggml_set_f32_nd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_set_f32_nd(const struct ggml_tensor *tensor, int i0, int i1, int i2, int i3, float value)
     * }
     */
    public static void ggml_set_f32_nd(MemorySegment tensor, int i0, int i1, int i2, int i3, float value) {
        var mh$ = ggml_set_f32_nd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_set_f32_nd", tensor, i0, i1, i2, i3, value);
            }
            mh$.invokeExact(tensor, i0, i1, i2, i3, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_threadpool_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_threadpool *ggml_threadpool_new(struct ggml_threadpool_params *params)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_new$descriptor() {
        return ggml_threadpool_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_threadpool *ggml_threadpool_new(struct ggml_threadpool_params *params)
     * }
     */
    public static MethodHandle ggml_threadpool_new$handle() {
        return ggml_threadpool_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_threadpool *ggml_threadpool_new(struct ggml_threadpool_params *params)
     * }
     */
    public static MemorySegment ggml_threadpool_new$address() {
        return ggml_threadpool_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_threadpool *ggml_threadpool_new(struct ggml_threadpool_params *params)
     * }
     */
    public static MemorySegment ggml_threadpool_new(MemorySegment params) {
        var mh$ = ggml_threadpool_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_new", params);
            }
            return (MemorySegment)mh$.invokeExact(params);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_threadpool_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_free(struct ggml_threadpool *threadpool)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_free$descriptor() {
        return ggml_threadpool_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_free(struct ggml_threadpool *threadpool)
     * }
     */
    public static MethodHandle ggml_threadpool_free$handle() {
        return ggml_threadpool_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_free(struct ggml_threadpool *threadpool)
     * }
     */
    public static MemorySegment ggml_threadpool_free$address() {
        return ggml_threadpool_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_threadpool_free(struct ggml_threadpool *threadpool)
     * }
     */
    public static void ggml_threadpool_free(MemorySegment threadpool) {
        var mh$ = ggml_threadpool_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_free", threadpool);
            }
            mh$.invokeExact(threadpool);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_get_n_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_threadpool_get_n_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_threadpool_get_n_threads(struct ggml_threadpool *threadpool)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_get_n_threads$descriptor() {
        return ggml_threadpool_get_n_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_threadpool_get_n_threads(struct ggml_threadpool *threadpool)
     * }
     */
    public static MethodHandle ggml_threadpool_get_n_threads$handle() {
        return ggml_threadpool_get_n_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_threadpool_get_n_threads(struct ggml_threadpool *threadpool)
     * }
     */
    public static MemorySegment ggml_threadpool_get_n_threads$address() {
        return ggml_threadpool_get_n_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_threadpool_get_n_threads(struct ggml_threadpool *threadpool)
     * }
     */
    public static int ggml_threadpool_get_n_threads(MemorySegment threadpool) {
        var mh$ = ggml_threadpool_get_n_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_get_n_threads", threadpool);
            }
            return (int)mh$.invokeExact(threadpool);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_pause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_threadpool_pause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_pause(struct ggml_threadpool *threadpool)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_pause$descriptor() {
        return ggml_threadpool_pause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_pause(struct ggml_threadpool *threadpool)
     * }
     */
    public static MethodHandle ggml_threadpool_pause$handle() {
        return ggml_threadpool_pause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_pause(struct ggml_threadpool *threadpool)
     * }
     */
    public static MemorySegment ggml_threadpool_pause$address() {
        return ggml_threadpool_pause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_threadpool_pause(struct ggml_threadpool *threadpool)
     * }
     */
    public static void ggml_threadpool_pause(MemorySegment threadpool) {
        var mh$ = ggml_threadpool_pause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_pause", threadpool);
            }
            mh$.invokeExact(threadpool);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_threadpool_resume {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_threadpool_resume");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_resume(struct ggml_threadpool *threadpool)
     * }
     */
    public static FunctionDescriptor ggml_threadpool_resume$descriptor() {
        return ggml_threadpool_resume.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_resume(struct ggml_threadpool *threadpool)
     * }
     */
    public static MethodHandle ggml_threadpool_resume$handle() {
        return ggml_threadpool_resume.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_threadpool_resume(struct ggml_threadpool *threadpool)
     * }
     */
    public static MemorySegment ggml_threadpool_resume$address() {
        return ggml_threadpool_resume.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_threadpool_resume(struct ggml_threadpool *threadpool)
     * }
     */
    public static void ggml_threadpool_resume(MemorySegment threadpool) {
        var mh$ = ggml_threadpool_resume.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_threadpool_resume", threadpool);
            }
            mh$.invokeExact(threadpool);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_plan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ggml_cplan.layout(),
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_plan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_cplan ggml_graph_plan(const struct ggml_cgraph *cgraph, int n_threads, struct ggml_threadpool *threadpool)
     * }
     */
    public static FunctionDescriptor ggml_graph_plan$descriptor() {
        return ggml_graph_plan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_cplan ggml_graph_plan(const struct ggml_cgraph *cgraph, int n_threads, struct ggml_threadpool *threadpool)
     * }
     */
    public static MethodHandle ggml_graph_plan$handle() {
        return ggml_graph_plan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_cplan ggml_graph_plan(const struct ggml_cgraph *cgraph, int n_threads, struct ggml_threadpool *threadpool)
     * }
     */
    public static MemorySegment ggml_graph_plan$address() {
        return ggml_graph_plan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_cplan ggml_graph_plan(const struct ggml_cgraph *cgraph, int n_threads, struct ggml_threadpool *threadpool)
     * }
     */
    public static MemorySegment ggml_graph_plan(SegmentAllocator allocator, MemorySegment cgraph, int n_threads, MemorySegment threadpool) {
        var mh$ = ggml_graph_plan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_plan", allocator, cgraph, n_threads, threadpool);
            }
            return (MemorySegment)mh$.invokeExact(allocator, cgraph, n_threads, threadpool);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_compute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_compute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_graph_compute(struct ggml_cgraph *cgraph, struct ggml_cplan *cplan)
     * }
     */
    public static FunctionDescriptor ggml_graph_compute$descriptor() {
        return ggml_graph_compute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_graph_compute(struct ggml_cgraph *cgraph, struct ggml_cplan *cplan)
     * }
     */
    public static MethodHandle ggml_graph_compute$handle() {
        return ggml_graph_compute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_graph_compute(struct ggml_cgraph *cgraph, struct ggml_cplan *cplan)
     * }
     */
    public static MemorySegment ggml_graph_compute$address() {
        return ggml_graph_compute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_graph_compute(struct ggml_cgraph *cgraph, struct ggml_cplan *cplan)
     * }
     */
    public static int ggml_graph_compute(MemorySegment cgraph, MemorySegment cplan) {
        var mh$ = ggml_graph_compute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_compute", cgraph, cplan);
            }
            return (int)mh$.invokeExact(cgraph, cplan);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_graph_compute_with_ctx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_graph_compute_with_ctx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_graph_compute_with_ctx(struct ggml_context *ctx, struct ggml_cgraph *cgraph, int n_threads)
     * }
     */
    public static FunctionDescriptor ggml_graph_compute_with_ctx$descriptor() {
        return ggml_graph_compute_with_ctx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_graph_compute_with_ctx(struct ggml_context *ctx, struct ggml_cgraph *cgraph, int n_threads)
     * }
     */
    public static MethodHandle ggml_graph_compute_with_ctx$handle() {
        return ggml_graph_compute_with_ctx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern enum ggml_status ggml_graph_compute_with_ctx(struct ggml_context *ctx, struct ggml_cgraph *cgraph, int n_threads)
     * }
     */
    public static MemorySegment ggml_graph_compute_with_ctx$address() {
        return ggml_graph_compute_with_ctx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern enum ggml_status ggml_graph_compute_with_ctx(struct ggml_context *ctx, struct ggml_cgraph *cgraph, int n_threads)
     * }
     */
    public static int ggml_graph_compute_with_ctx(MemorySegment ctx, MemorySegment cgraph, int n_threads) {
        var mh$ = ggml_graph_compute_with_ctx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_graph_compute_with_ctx", ctx, cgraph, n_threads);
            }
            return (int)mh$.invokeExact(ctx, cgraph, n_threads);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_sse3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_sse3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sse3(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_sse3$descriptor() {
        return ggml_cpu_has_sse3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sse3(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_sse3$handle() {
        return ggml_cpu_has_sse3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sse3(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_sse3$address() {
        return ggml_cpu_has_sse3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sse3(void)
     * }
     */
    public static int ggml_cpu_has_sse3() {
        var mh$ = ggml_cpu_has_sse3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_sse3");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_ssse3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_ssse3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_ssse3(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_ssse3$descriptor() {
        return ggml_cpu_has_ssse3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_ssse3(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_ssse3$handle() {
        return ggml_cpu_has_ssse3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_ssse3(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_ssse3$address() {
        return ggml_cpu_has_ssse3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_ssse3(void)
     * }
     */
    public static int ggml_cpu_has_ssse3() {
        var mh$ = ggml_cpu_has_ssse3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_ssse3");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_avx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_avx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_avx$descriptor() {
        return ggml_cpu_has_avx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_avx$handle() {
        return ggml_cpu_has_avx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_avx$address() {
        return ggml_cpu_has_avx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx(void)
     * }
     */
    public static int ggml_cpu_has_avx() {
        var mh$ = ggml_cpu_has_avx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_avx");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_avx_vnni {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_avx_vnni");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx_vnni(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_avx_vnni$descriptor() {
        return ggml_cpu_has_avx_vnni.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx_vnni(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_avx_vnni$handle() {
        return ggml_cpu_has_avx_vnni.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx_vnni(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_avx_vnni$address() {
        return ggml_cpu_has_avx_vnni.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx_vnni(void)
     * }
     */
    public static int ggml_cpu_has_avx_vnni() {
        var mh$ = ggml_cpu_has_avx_vnni.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_avx_vnni");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_avx2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_avx2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx2(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_avx2$descriptor() {
        return ggml_cpu_has_avx2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx2(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_avx2$handle() {
        return ggml_cpu_has_avx2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx2(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_avx2$address() {
        return ggml_cpu_has_avx2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx2(void)
     * }
     */
    public static int ggml_cpu_has_avx2() {
        var mh$ = ggml_cpu_has_avx2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_avx2");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_bmi2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_bmi2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_bmi2(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_bmi2$descriptor() {
        return ggml_cpu_has_bmi2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_bmi2(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_bmi2$handle() {
        return ggml_cpu_has_bmi2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_bmi2(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_bmi2$address() {
        return ggml_cpu_has_bmi2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_bmi2(void)
     * }
     */
    public static int ggml_cpu_has_bmi2() {
        var mh$ = ggml_cpu_has_bmi2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_bmi2");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_f16c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_f16c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_f16c(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_f16c$descriptor() {
        return ggml_cpu_has_f16c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_f16c(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_f16c$handle() {
        return ggml_cpu_has_f16c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_f16c(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_f16c$address() {
        return ggml_cpu_has_f16c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_f16c(void)
     * }
     */
    public static int ggml_cpu_has_f16c() {
        var mh$ = ggml_cpu_has_f16c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_f16c");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_fma(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_fma$descriptor() {
        return ggml_cpu_has_fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_fma(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_fma$handle() {
        return ggml_cpu_has_fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_fma(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_fma$address() {
        return ggml_cpu_has_fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_fma(void)
     * }
     */
    public static int ggml_cpu_has_fma() {
        var mh$ = ggml_cpu_has_fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_fma");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_avx512 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_avx512");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_avx512$descriptor() {
        return ggml_cpu_has_avx512.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_avx512$handle() {
        return ggml_cpu_has_avx512.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_avx512$address() {
        return ggml_cpu_has_avx512.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512(void)
     * }
     */
    public static int ggml_cpu_has_avx512() {
        var mh$ = ggml_cpu_has_avx512.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_avx512");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_avx512_vbmi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_avx512_vbmi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_vbmi(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_avx512_vbmi$descriptor() {
        return ggml_cpu_has_avx512_vbmi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_vbmi(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_avx512_vbmi$handle() {
        return ggml_cpu_has_avx512_vbmi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_vbmi(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_avx512_vbmi$address() {
        return ggml_cpu_has_avx512_vbmi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_vbmi(void)
     * }
     */
    public static int ggml_cpu_has_avx512_vbmi() {
        var mh$ = ggml_cpu_has_avx512_vbmi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_avx512_vbmi");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_avx512_vnni {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_avx512_vnni");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_vnni(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_avx512_vnni$descriptor() {
        return ggml_cpu_has_avx512_vnni.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_vnni(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_avx512_vnni$handle() {
        return ggml_cpu_has_avx512_vnni.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_vnni(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_avx512_vnni$address() {
        return ggml_cpu_has_avx512_vnni.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_vnni(void)
     * }
     */
    public static int ggml_cpu_has_avx512_vnni() {
        var mh$ = ggml_cpu_has_avx512_vnni.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_avx512_vnni");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_avx512_bf16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_avx512_bf16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_bf16(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_avx512_bf16$descriptor() {
        return ggml_cpu_has_avx512_bf16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_bf16(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_avx512_bf16$handle() {
        return ggml_cpu_has_avx512_bf16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_bf16(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_avx512_bf16$address() {
        return ggml_cpu_has_avx512_bf16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_avx512_bf16(void)
     * }
     */
    public static int ggml_cpu_has_avx512_bf16() {
        var mh$ = ggml_cpu_has_avx512_bf16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_avx512_bf16");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_amx_int8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_amx_int8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_amx_int8(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_amx_int8$descriptor() {
        return ggml_cpu_has_amx_int8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_amx_int8(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_amx_int8$handle() {
        return ggml_cpu_has_amx_int8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_amx_int8(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_amx_int8$address() {
        return ggml_cpu_has_amx_int8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_amx_int8(void)
     * }
     */
    public static int ggml_cpu_has_amx_int8() {
        var mh$ = ggml_cpu_has_amx_int8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_amx_int8");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_neon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_neon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_neon(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_neon$descriptor() {
        return ggml_cpu_has_neon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_neon(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_neon$handle() {
        return ggml_cpu_has_neon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_neon(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_neon$address() {
        return ggml_cpu_has_neon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_neon(void)
     * }
     */
    public static int ggml_cpu_has_neon() {
        var mh$ = ggml_cpu_has_neon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_neon");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_arm_fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_arm_fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_arm_fma(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_arm_fma$descriptor() {
        return ggml_cpu_has_arm_fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_arm_fma(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_arm_fma$handle() {
        return ggml_cpu_has_arm_fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_arm_fma(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_arm_fma$address() {
        return ggml_cpu_has_arm_fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_arm_fma(void)
     * }
     */
    public static int ggml_cpu_has_arm_fma() {
        var mh$ = ggml_cpu_has_arm_fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_arm_fma");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_fp16_va {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_fp16_va");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_fp16_va(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_fp16_va$descriptor() {
        return ggml_cpu_has_fp16_va.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_fp16_va(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_fp16_va$handle() {
        return ggml_cpu_has_fp16_va.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_fp16_va(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_fp16_va$address() {
        return ggml_cpu_has_fp16_va.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_fp16_va(void)
     * }
     */
    public static int ggml_cpu_has_fp16_va() {
        var mh$ = ggml_cpu_has_fp16_va.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_fp16_va");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_dotprod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_dotprod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_dotprod(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_dotprod$descriptor() {
        return ggml_cpu_has_dotprod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_dotprod(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_dotprod$handle() {
        return ggml_cpu_has_dotprod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_dotprod(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_dotprod$address() {
        return ggml_cpu_has_dotprod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_dotprod(void)
     * }
     */
    public static int ggml_cpu_has_dotprod() {
        var mh$ = ggml_cpu_has_dotprod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_dotprod");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_matmul_int8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_matmul_int8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_matmul_int8(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_matmul_int8$descriptor() {
        return ggml_cpu_has_matmul_int8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_matmul_int8(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_matmul_int8$handle() {
        return ggml_cpu_has_matmul_int8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_matmul_int8(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_matmul_int8$address() {
        return ggml_cpu_has_matmul_int8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_matmul_int8(void)
     * }
     */
    public static int ggml_cpu_has_matmul_int8() {
        var mh$ = ggml_cpu_has_matmul_int8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_matmul_int8");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_sve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_sve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sve(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_sve$descriptor() {
        return ggml_cpu_has_sve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sve(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_sve$handle() {
        return ggml_cpu_has_sve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sve(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_sve$address() {
        return ggml_cpu_has_sve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sve(void)
     * }
     */
    public static int ggml_cpu_has_sve() {
        var mh$ = ggml_cpu_has_sve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_sve");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_get_sve_cnt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_get_sve_cnt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_get_sve_cnt(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_get_sve_cnt$descriptor() {
        return ggml_cpu_get_sve_cnt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_get_sve_cnt(void)
     * }
     */
    public static MethodHandle ggml_cpu_get_sve_cnt$handle() {
        return ggml_cpu_get_sve_cnt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_get_sve_cnt(void)
     * }
     */
    public static MemorySegment ggml_cpu_get_sve_cnt$address() {
        return ggml_cpu_get_sve_cnt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_get_sve_cnt(void)
     * }
     */
    public static int ggml_cpu_get_sve_cnt() {
        var mh$ = ggml_cpu_get_sve_cnt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_get_sve_cnt");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_sme {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_sme");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sme(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_sme$descriptor() {
        return ggml_cpu_has_sme.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sme(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_sme$handle() {
        return ggml_cpu_has_sme.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sme(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_sme$address() {
        return ggml_cpu_has_sme.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_sme(void)
     * }
     */
    public static int ggml_cpu_has_sme() {
        var mh$ = ggml_cpu_has_sme.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_sme");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_riscv_v {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_riscv_v");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_riscv_v(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_riscv_v$descriptor() {
        return ggml_cpu_has_riscv_v.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_riscv_v(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_riscv_v$handle() {
        return ggml_cpu_has_riscv_v.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_riscv_v(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_riscv_v$address() {
        return ggml_cpu_has_riscv_v.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_riscv_v(void)
     * }
     */
    public static int ggml_cpu_has_riscv_v() {
        var mh$ = ggml_cpu_has_riscv_v.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_riscv_v");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_vsx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_vsx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_vsx(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_vsx$descriptor() {
        return ggml_cpu_has_vsx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_vsx(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_vsx$handle() {
        return ggml_cpu_has_vsx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_vsx(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_vsx$address() {
        return ggml_cpu_has_vsx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_vsx(void)
     * }
     */
    public static int ggml_cpu_has_vsx() {
        var mh$ = ggml_cpu_has_vsx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_vsx");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_vxe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_vxe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_vxe(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_vxe$descriptor() {
        return ggml_cpu_has_vxe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_vxe(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_vxe$handle() {
        return ggml_cpu_has_vxe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_vxe(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_vxe$address() {
        return ggml_cpu_has_vxe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_vxe(void)
     * }
     */
    public static int ggml_cpu_has_vxe() {
        var mh$ = ggml_cpu_has_vxe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_vxe");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_wasm_simd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_wasm_simd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_wasm_simd(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_wasm_simd$descriptor() {
        return ggml_cpu_has_wasm_simd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_wasm_simd(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_wasm_simd$handle() {
        return ggml_cpu_has_wasm_simd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_wasm_simd(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_wasm_simd$address() {
        return ggml_cpu_has_wasm_simd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_wasm_simd(void)
     * }
     */
    public static int ggml_cpu_has_wasm_simd() {
        var mh$ = ggml_cpu_has_wasm_simd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_wasm_simd");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_has_llamafile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_has_llamafile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_llamafile(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_has_llamafile$descriptor() {
        return ggml_cpu_has_llamafile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_llamafile(void)
     * }
     */
    public static MethodHandle ggml_cpu_has_llamafile$handle() {
        return ggml_cpu_has_llamafile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ggml_cpu_has_llamafile(void)
     * }
     */
    public static MemorySegment ggml_cpu_has_llamafile$address() {
        return ggml_cpu_has_llamafile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ggml_cpu_has_llamafile(void)
     * }
     */
    public static int ggml_cpu_has_llamafile() {
        var mh$ = ggml_cpu_has_llamafile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_has_llamafile");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_get_type_traits_cpu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_get_type_traits_cpu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const struct ggml_type_traits_cpu *ggml_get_type_traits_cpu(enum ggml_type type)
     * }
     */
    public static FunctionDescriptor ggml_get_type_traits_cpu$descriptor() {
        return ggml_get_type_traits_cpu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const struct ggml_type_traits_cpu *ggml_get_type_traits_cpu(enum ggml_type type)
     * }
     */
    public static MethodHandle ggml_get_type_traits_cpu$handle() {
        return ggml_get_type_traits_cpu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const struct ggml_type_traits_cpu *ggml_get_type_traits_cpu(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_get_type_traits_cpu$address() {
        return ggml_get_type_traits_cpu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const struct ggml_type_traits_cpu *ggml_get_type_traits_cpu(enum ggml_type type)
     * }
     */
    public static MemorySegment ggml_get_type_traits_cpu(int type) {
        var mh$ = ggml_get_type_traits_cpu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_get_type_traits_cpu", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_cpu_init(void)
     * }
     */
    public static FunctionDescriptor ggml_cpu_init$descriptor() {
        return ggml_cpu_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_cpu_init(void)
     * }
     */
    public static MethodHandle ggml_cpu_init$handle() {
        return ggml_cpu_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_cpu_init(void)
     * }
     */
    public static MemorySegment ggml_cpu_init$address() {
        return ggml_cpu_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_cpu_init(void)
     * }
     */
    public static void ggml_cpu_init() {
        var mh$ = ggml_cpu_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_init");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_cpu_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_cpu_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_cpu_init(void)
     * }
     */
    public static FunctionDescriptor ggml_backend_cpu_init$descriptor() {
        return ggml_backend_cpu_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_cpu_init(void)
     * }
     */
    public static MethodHandle ggml_backend_cpu_init$handle() {
        return ggml_backend_cpu_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_cpu_init(void)
     * }
     */
    public static MemorySegment ggml_backend_cpu_init$address() {
        return ggml_backend_cpu_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_t ggml_backend_cpu_init(void)
     * }
     */
    public static MemorySegment ggml_backend_cpu_init() {
        var mh$ = ggml_backend_cpu_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_cpu_init");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_is_cpu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_is_cpu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_backend_is_cpu(ggml_backend_t backend)
     * }
     */
    public static FunctionDescriptor ggml_backend_is_cpu$descriptor() {
        return ggml_backend_is_cpu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_backend_is_cpu(ggml_backend_t backend)
     * }
     */
    public static MethodHandle ggml_backend_is_cpu$handle() {
        return ggml_backend_is_cpu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_backend_is_cpu(ggml_backend_t backend)
     * }
     */
    public static MemorySegment ggml_backend_is_cpu$address() {
        return ggml_backend_is_cpu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_backend_is_cpu(ggml_backend_t backend)
     * }
     */
    public static boolean ggml_backend_is_cpu(MemorySegment backend) {
        var mh$ = ggml_backend_is_cpu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_is_cpu", backend);
            }
            return (boolean)mh$.invokeExact(backend);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_cpu_set_n_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_cpu_set_n_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_n_threads(ggml_backend_t backend_cpu, int n_threads)
     * }
     */
    public static FunctionDescriptor ggml_backend_cpu_set_n_threads$descriptor() {
        return ggml_backend_cpu_set_n_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_n_threads(ggml_backend_t backend_cpu, int n_threads)
     * }
     */
    public static MethodHandle ggml_backend_cpu_set_n_threads$handle() {
        return ggml_backend_cpu_set_n_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_n_threads(ggml_backend_t backend_cpu, int n_threads)
     * }
     */
    public static MemorySegment ggml_backend_cpu_set_n_threads$address() {
        return ggml_backend_cpu_set_n_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_n_threads(ggml_backend_t backend_cpu, int n_threads)
     * }
     */
    public static void ggml_backend_cpu_set_n_threads(MemorySegment backend_cpu, int n_threads) {
        var mh$ = ggml_backend_cpu_set_n_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_cpu_set_n_threads", backend_cpu, n_threads);
            }
            mh$.invokeExact(backend_cpu, n_threads);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_cpu_set_threadpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_cpu_set_threadpool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_threadpool(ggml_backend_t backend_cpu, ggml_threadpool_t threadpool)
     * }
     */
    public static FunctionDescriptor ggml_backend_cpu_set_threadpool$descriptor() {
        return ggml_backend_cpu_set_threadpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_threadpool(ggml_backend_t backend_cpu, ggml_threadpool_t threadpool)
     * }
     */
    public static MethodHandle ggml_backend_cpu_set_threadpool$handle() {
        return ggml_backend_cpu_set_threadpool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_threadpool(ggml_backend_t backend_cpu, ggml_threadpool_t threadpool)
     * }
     */
    public static MemorySegment ggml_backend_cpu_set_threadpool$address() {
        return ggml_backend_cpu_set_threadpool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_threadpool(ggml_backend_t backend_cpu, ggml_threadpool_t threadpool)
     * }
     */
    public static void ggml_backend_cpu_set_threadpool(MemorySegment backend_cpu, MemorySegment threadpool) {
        var mh$ = ggml_backend_cpu_set_threadpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_cpu_set_threadpool", backend_cpu, threadpool);
            }
            mh$.invokeExact(backend_cpu, threadpool);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_cpu_set_abort_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_cpu_set_abort_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_abort_callback(ggml_backend_t backend_cpu, ggml_abort_callback abort_callback, void *abort_callback_data)
     * }
     */
    public static FunctionDescriptor ggml_backend_cpu_set_abort_callback$descriptor() {
        return ggml_backend_cpu_set_abort_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_abort_callback(ggml_backend_t backend_cpu, ggml_abort_callback abort_callback, void *abort_callback_data)
     * }
     */
    public static MethodHandle ggml_backend_cpu_set_abort_callback$handle() {
        return ggml_backend_cpu_set_abort_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_abort_callback(ggml_backend_t backend_cpu, ggml_abort_callback abort_callback, void *abort_callback_data)
     * }
     */
    public static MemorySegment ggml_backend_cpu_set_abort_callback$address() {
        return ggml_backend_cpu_set_abort_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_backend_cpu_set_abort_callback(ggml_backend_t backend_cpu, ggml_abort_callback abort_callback, void *abort_callback_data)
     * }
     */
    public static void ggml_backend_cpu_set_abort_callback(MemorySegment backend_cpu, MemorySegment abort_callback, MemorySegment abort_callback_data) {
        var mh$ = ggml_backend_cpu_set_abort_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_cpu_set_abort_callback", backend_cpu, abort_callback, abort_callback_data);
            }
            mh$.invokeExact(backend_cpu, abort_callback, abort_callback_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_backend_cpu_reg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_backend_cpu_reg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_cpu_reg(void)
     * }
     */
    public static FunctionDescriptor ggml_backend_cpu_reg$descriptor() {
        return ggml_backend_cpu_reg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_cpu_reg(void)
     * }
     */
    public static MethodHandle ggml_backend_cpu_reg$handle() {
        return ggml_backend_cpu_reg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_cpu_reg(void)
     * }
     */
    public static MemorySegment ggml_backend_cpu_reg$address() {
        return ggml_backend_cpu_reg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_backend_reg_t ggml_backend_cpu_reg(void)
     * }
     */
    public static MemorySegment ggml_backend_cpu_reg() {
        var mh$ = ggml_backend_cpu_reg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_backend_cpu_reg");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_fp32_to_fp16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_fp32_to_fp16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_fp16(const float *, ggml_fp16_t *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_cpu_fp32_to_fp16$descriptor() {
        return ggml_cpu_fp32_to_fp16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_fp16(const float *, ggml_fp16_t *, int64_t)
     * }
     */
    public static MethodHandle ggml_cpu_fp32_to_fp16$handle() {
        return ggml_cpu_fp32_to_fp16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_fp16(const float *, ggml_fp16_t *, int64_t)
     * }
     */
    public static MemorySegment ggml_cpu_fp32_to_fp16$address() {
        return ggml_cpu_fp32_to_fp16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_fp16(const float *, ggml_fp16_t *, int64_t)
     * }
     */
    public static void ggml_cpu_fp32_to_fp16(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_cpu_fp32_to_fp16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_fp32_to_fp16", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_fp16_to_fp32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_fp16_to_fp32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp16_to_fp32(const ggml_fp16_t *, float *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_cpu_fp16_to_fp32$descriptor() {
        return ggml_cpu_fp16_to_fp32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp16_to_fp32(const ggml_fp16_t *, float *, int64_t)
     * }
     */
    public static MethodHandle ggml_cpu_fp16_to_fp32$handle() {
        return ggml_cpu_fp16_to_fp32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp16_to_fp32(const ggml_fp16_t *, float *, int64_t)
     * }
     */
    public static MemorySegment ggml_cpu_fp16_to_fp32$address() {
        return ggml_cpu_fp16_to_fp32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_cpu_fp16_to_fp32(const ggml_fp16_t *, float *, int64_t)
     * }
     */
    public static void ggml_cpu_fp16_to_fp32(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_cpu_fp16_to_fp32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_fp16_to_fp32", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_fp32_to_bf16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_fp32_to_bf16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_bf16(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_cpu_fp32_to_bf16$descriptor() {
        return ggml_cpu_fp32_to_bf16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_bf16(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static MethodHandle ggml_cpu_fp32_to_bf16$handle() {
        return ggml_cpu_fp32_to_bf16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_bf16(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static MemorySegment ggml_cpu_fp32_to_bf16$address() {
        return ggml_cpu_fp32_to_bf16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_cpu_fp32_to_bf16(const float *, ggml_bf16_t *, int64_t)
     * }
     */
    public static void ggml_cpu_fp32_to_bf16(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_cpu_fp32_to_bf16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_fp32_to_bf16", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_cpu_bf16_to_fp32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_cpu_bf16_to_fp32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_cpu_bf16_to_fp32(const ggml_bf16_t *, float *, int64_t)
     * }
     */
    public static FunctionDescriptor ggml_cpu_bf16_to_fp32$descriptor() {
        return ggml_cpu_bf16_to_fp32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_cpu_bf16_to_fp32(const ggml_bf16_t *, float *, int64_t)
     * }
     */
    public static MethodHandle ggml_cpu_bf16_to_fp32$handle() {
        return ggml_cpu_bf16_to_fp32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_cpu_bf16_to_fp32(const ggml_bf16_t *, float *, int64_t)
     * }
     */
    public static MemorySegment ggml_cpu_bf16_to_fp32$address() {
        return ggml_cpu_bf16_to_fp32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_cpu_bf16_to_fp32(const ggml_bf16_t *, float *, int64_t)
     * }
     */
    public static void ggml_cpu_bf16_to_fp32(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = ggml_cpu_bf16_to_fp32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_cpu_bf16_to_fp32", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct ggml_opt_dataset *ggml_opt_dataset_t
     * }
     */
    public static final AddressLayout ggml_opt_dataset_t = llama_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ggml_opt_context *ggml_opt_context_t
     * }
     */
    public static final AddressLayout ggml_opt_context_t = llama_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct ggml_opt_result *ggml_opt_result_t
     * }
     */
    public static final AddressLayout ggml_opt_result_t = llama_h.C_POINTER;
    private static final int GGML_OPT_LOSS_TYPE_MEAN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ggml_opt_loss_type.GGML_OPT_LOSS_TYPE_MEAN = 0
     * }
     */
    public static int GGML_OPT_LOSS_TYPE_MEAN() {
        return GGML_OPT_LOSS_TYPE_MEAN;
    }
    private static final int GGML_OPT_LOSS_TYPE_SUM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ggml_opt_loss_type.GGML_OPT_LOSS_TYPE_SUM = 1
     * }
     */
    public static int GGML_OPT_LOSS_TYPE_SUM() {
        return GGML_OPT_LOSS_TYPE_SUM;
    }
    private static final int GGML_OPT_LOSS_TYPE_CROSS_ENTROPY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ggml_opt_loss_type.GGML_OPT_LOSS_TYPE_CROSS_ENTROPY = 2
     * }
     */
    public static int GGML_OPT_LOSS_TYPE_CROSS_ENTROPY() {
        return GGML_OPT_LOSS_TYPE_CROSS_ENTROPY;
    }
    private static final int GGML_OPT_LOSS_TYPE_MEAN_SQUARED_ERROR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ggml_opt_loss_type.GGML_OPT_LOSS_TYPE_MEAN_SQUARED_ERROR = 3
     * }
     */
    public static int GGML_OPT_LOSS_TYPE_MEAN_SQUARED_ERROR() {
        return GGML_OPT_LOSS_TYPE_MEAN_SQUARED_ERROR;
    }

    private static class ggml_opt_dataset_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_LONG_LONG,
            llama_h.C_LONG_LONG,
            llama_h.C_LONG_LONG,
            llama_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_dataset_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_opt_dataset_t ggml_opt_dataset_init(enum ggml_type type_data, enum ggml_type type_label, int64_t ne_datapoint, int64_t ne_label, int64_t ndata, int64_t ndata_shard)
     * }
     */
    public static FunctionDescriptor ggml_opt_dataset_init$descriptor() {
        return ggml_opt_dataset_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_opt_dataset_t ggml_opt_dataset_init(enum ggml_type type_data, enum ggml_type type_label, int64_t ne_datapoint, int64_t ne_label, int64_t ndata, int64_t ndata_shard)
     * }
     */
    public static MethodHandle ggml_opt_dataset_init$handle() {
        return ggml_opt_dataset_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_opt_dataset_t ggml_opt_dataset_init(enum ggml_type type_data, enum ggml_type type_label, int64_t ne_datapoint, int64_t ne_label, int64_t ndata, int64_t ndata_shard)
     * }
     */
    public static MemorySegment ggml_opt_dataset_init$address() {
        return ggml_opt_dataset_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_opt_dataset_t ggml_opt_dataset_init(enum ggml_type type_data, enum ggml_type type_label, int64_t ne_datapoint, int64_t ne_label, int64_t ndata, int64_t ndata_shard)
     * }
     */
    public static MemorySegment ggml_opt_dataset_init(int type_data, int type_label, long ne_datapoint, long ne_label, long ndata, long ndata_shard) {
        var mh$ = ggml_opt_dataset_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_dataset_init", type_data, type_label, ne_datapoint, ne_label, ndata, ndata_shard);
            }
            return (MemorySegment)mh$.invokeExact(type_data, type_label, ne_datapoint, ne_label, ndata, ndata_shard);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_dataset_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_dataset_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_opt_dataset_free(ggml_opt_dataset_t dataset)
     * }
     */
    public static FunctionDescriptor ggml_opt_dataset_free$descriptor() {
        return ggml_opt_dataset_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_opt_dataset_free(ggml_opt_dataset_t dataset)
     * }
     */
    public static MethodHandle ggml_opt_dataset_free$handle() {
        return ggml_opt_dataset_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_opt_dataset_free(ggml_opt_dataset_t dataset)
     * }
     */
    public static MemorySegment ggml_opt_dataset_free$address() {
        return ggml_opt_dataset_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_opt_dataset_free(ggml_opt_dataset_t dataset)
     * }
     */
    public static void ggml_opt_dataset_free(MemorySegment dataset) {
        var mh$ = ggml_opt_dataset_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_dataset_free", dataset);
            }
            mh$.invokeExact(dataset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_dataset_ndata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG_LONG,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_dataset_ndata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int64_t ggml_opt_dataset_ndata(ggml_opt_dataset_t dataset)
     * }
     */
    public static FunctionDescriptor ggml_opt_dataset_ndata$descriptor() {
        return ggml_opt_dataset_ndata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int64_t ggml_opt_dataset_ndata(ggml_opt_dataset_t dataset)
     * }
     */
    public static MethodHandle ggml_opt_dataset_ndata$handle() {
        return ggml_opt_dataset_ndata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int64_t ggml_opt_dataset_ndata(ggml_opt_dataset_t dataset)
     * }
     */
    public static MemorySegment ggml_opt_dataset_ndata$address() {
        return ggml_opt_dataset_ndata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int64_t ggml_opt_dataset_ndata(ggml_opt_dataset_t dataset)
     * }
     */
    public static long ggml_opt_dataset_ndata(MemorySegment dataset) {
        var mh$ = ggml_opt_dataset_ndata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_dataset_ndata", dataset);
            }
            return (long)mh$.invokeExact(dataset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_dataset_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_dataset_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_dataset_data(ggml_opt_dataset_t dataset)
     * }
     */
    public static FunctionDescriptor ggml_opt_dataset_data$descriptor() {
        return ggml_opt_dataset_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_dataset_data(ggml_opt_dataset_t dataset)
     * }
     */
    public static MethodHandle ggml_opt_dataset_data$handle() {
        return ggml_opt_dataset_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_dataset_data(ggml_opt_dataset_t dataset)
     * }
     */
    public static MemorySegment ggml_opt_dataset_data$address() {
        return ggml_opt_dataset_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_dataset_data(ggml_opt_dataset_t dataset)
     * }
     */
    public static MemorySegment ggml_opt_dataset_data(MemorySegment dataset) {
        var mh$ = ggml_opt_dataset_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_dataset_data", dataset);
            }
            return (MemorySegment)mh$.invokeExact(dataset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_dataset_labels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_dataset_labels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_dataset_labels(ggml_opt_dataset_t dataset)
     * }
     */
    public static FunctionDescriptor ggml_opt_dataset_labels$descriptor() {
        return ggml_opt_dataset_labels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_dataset_labels(ggml_opt_dataset_t dataset)
     * }
     */
    public static MethodHandle ggml_opt_dataset_labels$handle() {
        return ggml_opt_dataset_labels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_dataset_labels(ggml_opt_dataset_t dataset)
     * }
     */
    public static MemorySegment ggml_opt_dataset_labels$address() {
        return ggml_opt_dataset_labels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_dataset_labels(ggml_opt_dataset_t dataset)
     * }
     */
    public static MemorySegment ggml_opt_dataset_labels(MemorySegment dataset) {
        var mh$ = ggml_opt_dataset_labels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_dataset_labels", dataset);
            }
            return (MemorySegment)mh$.invokeExact(dataset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_dataset_shuffle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_dataset_shuffle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_opt_dataset_shuffle(ggml_opt_context_t opt_ctx, ggml_opt_dataset_t dataset, int64_t idata)
     * }
     */
    public static FunctionDescriptor ggml_opt_dataset_shuffle$descriptor() {
        return ggml_opt_dataset_shuffle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_opt_dataset_shuffle(ggml_opt_context_t opt_ctx, ggml_opt_dataset_t dataset, int64_t idata)
     * }
     */
    public static MethodHandle ggml_opt_dataset_shuffle$handle() {
        return ggml_opt_dataset_shuffle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_opt_dataset_shuffle(ggml_opt_context_t opt_ctx, ggml_opt_dataset_t dataset, int64_t idata)
     * }
     */
    public static MemorySegment ggml_opt_dataset_shuffle$address() {
        return ggml_opt_dataset_shuffle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_opt_dataset_shuffle(ggml_opt_context_t opt_ctx, ggml_opt_dataset_t dataset, int64_t idata)
     * }
     */
    public static void ggml_opt_dataset_shuffle(MemorySegment opt_ctx, MemorySegment dataset, long idata) {
        var mh$ = ggml_opt_dataset_shuffle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_dataset_shuffle", opt_ctx, dataset, idata);
            }
            mh$.invokeExact(opt_ctx, dataset, idata);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_dataset_get_batch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_dataset_get_batch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_opt_dataset_get_batch(ggml_opt_dataset_t dataset, struct ggml_tensor *data_batch, struct ggml_tensor *labels_batch, int64_t ibatch)
     * }
     */
    public static FunctionDescriptor ggml_opt_dataset_get_batch$descriptor() {
        return ggml_opt_dataset_get_batch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_opt_dataset_get_batch(ggml_opt_dataset_t dataset, struct ggml_tensor *data_batch, struct ggml_tensor *labels_batch, int64_t ibatch)
     * }
     */
    public static MethodHandle ggml_opt_dataset_get_batch$handle() {
        return ggml_opt_dataset_get_batch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_opt_dataset_get_batch(ggml_opt_dataset_t dataset, struct ggml_tensor *data_batch, struct ggml_tensor *labels_batch, int64_t ibatch)
     * }
     */
    public static MemorySegment ggml_opt_dataset_get_batch$address() {
        return ggml_opt_dataset_get_batch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_opt_dataset_get_batch(ggml_opt_dataset_t dataset, struct ggml_tensor *data_batch, struct ggml_tensor *labels_batch, int64_t ibatch)
     * }
     */
    public static void ggml_opt_dataset_get_batch(MemorySegment dataset, MemorySegment data_batch, MemorySegment labels_batch, long ibatch) {
        var mh$ = ggml_opt_dataset_get_batch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_dataset_get_batch", dataset, data_batch, labels_batch, ibatch);
            }
            mh$.invokeExact(dataset, data_batch, labels_batch, ibatch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_dataset_get_batch_host {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_h.C_POINTER,
            llama_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_dataset_get_batch_host");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_opt_dataset_get_batch_host(ggml_opt_dataset_t dataset, void *data_batch, size_t nb_data_batch, void *labels_batch, int64_t ibatch)
     * }
     */
    public static FunctionDescriptor ggml_opt_dataset_get_batch_host$descriptor() {
        return ggml_opt_dataset_get_batch_host.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_opt_dataset_get_batch_host(ggml_opt_dataset_t dataset, void *data_batch, size_t nb_data_batch, void *labels_batch, int64_t ibatch)
     * }
     */
    public static MethodHandle ggml_opt_dataset_get_batch_host$handle() {
        return ggml_opt_dataset_get_batch_host.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_opt_dataset_get_batch_host(ggml_opt_dataset_t dataset, void *data_batch, size_t nb_data_batch, void *labels_batch, int64_t ibatch)
     * }
     */
    public static MemorySegment ggml_opt_dataset_get_batch_host$address() {
        return ggml_opt_dataset_get_batch_host.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_opt_dataset_get_batch_host(ggml_opt_dataset_t dataset, void *data_batch, size_t nb_data_batch, void *labels_batch, int64_t ibatch)
     * }
     */
    public static void ggml_opt_dataset_get_batch_host(MemorySegment dataset, MemorySegment data_batch, long nb_data_batch, MemorySegment labels_batch, long ibatch) {
        var mh$ = ggml_opt_dataset_get_batch_host.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_dataset_get_batch_host", dataset, data_batch, nb_data_batch, labels_batch, ibatch);
            }
            mh$.invokeExact(dataset, data_batch, nb_data_batch, labels_batch, ibatch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GGML_OPT_BUILD_TYPE_FORWARD = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ggml_opt_build_type.GGML_OPT_BUILD_TYPE_FORWARD = 10
     * }
     */
    public static int GGML_OPT_BUILD_TYPE_FORWARD() {
        return GGML_OPT_BUILD_TYPE_FORWARD;
    }
    private static final int GGML_OPT_BUILD_TYPE_GRAD = (int)20L;
    /**
     * {@snippet lang=c :
     * enum ggml_opt_build_type.GGML_OPT_BUILD_TYPE_GRAD = 20
     * }
     */
    public static int GGML_OPT_BUILD_TYPE_GRAD() {
        return GGML_OPT_BUILD_TYPE_GRAD;
    }
    private static final int GGML_OPT_BUILD_TYPE_OPT = (int)30L;
    /**
     * {@snippet lang=c :
     * enum ggml_opt_build_type.GGML_OPT_BUILD_TYPE_OPT = 30
     * }
     */
    public static int GGML_OPT_BUILD_TYPE_OPT() {
        return GGML_OPT_BUILD_TYPE_OPT;
    }

    private static class ggml_opt_get_default_optimizer_params {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ggml_opt_optimizer_params.layout(),
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_get_default_optimizer_params");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_opt_optimizer_params ggml_opt_get_default_optimizer_params(void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_opt_get_default_optimizer_params$descriptor() {
        return ggml_opt_get_default_optimizer_params.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_opt_optimizer_params ggml_opt_get_default_optimizer_params(void *userdata)
     * }
     */
    public static MethodHandle ggml_opt_get_default_optimizer_params$handle() {
        return ggml_opt_get_default_optimizer_params.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_opt_optimizer_params ggml_opt_get_default_optimizer_params(void *userdata)
     * }
     */
    public static MemorySegment ggml_opt_get_default_optimizer_params$address() {
        return ggml_opt_get_default_optimizer_params.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_opt_optimizer_params ggml_opt_get_default_optimizer_params(void *userdata)
     * }
     */
    public static MemorySegment ggml_opt_get_default_optimizer_params(SegmentAllocator allocator, MemorySegment userdata) {
        var mh$ = ggml_opt_get_default_optimizer_params.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_get_default_optimizer_params", allocator, userdata);
            }
            return (MemorySegment)mh$.invokeExact(allocator, userdata);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_get_constant_optimizer_params {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ggml_opt_optimizer_params.layout(),
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_get_constant_optimizer_params");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_opt_optimizer_params ggml_opt_get_constant_optimizer_params(void *userdata)
     * }
     */
    public static FunctionDescriptor ggml_opt_get_constant_optimizer_params$descriptor() {
        return ggml_opt_get_constant_optimizer_params.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_opt_optimizer_params ggml_opt_get_constant_optimizer_params(void *userdata)
     * }
     */
    public static MethodHandle ggml_opt_get_constant_optimizer_params$handle() {
        return ggml_opt_get_constant_optimizer_params.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_opt_optimizer_params ggml_opt_get_constant_optimizer_params(void *userdata)
     * }
     */
    public static MemorySegment ggml_opt_get_constant_optimizer_params$address() {
        return ggml_opt_get_constant_optimizer_params.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_opt_optimizer_params ggml_opt_get_constant_optimizer_params(void *userdata)
     * }
     */
    public static MemorySegment ggml_opt_get_constant_optimizer_params(SegmentAllocator allocator, MemorySegment userdata) {
        var mh$ = ggml_opt_get_constant_optimizer_params.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_get_constant_optimizer_params", allocator, userdata);
            }
            return (MemorySegment)mh$.invokeExact(allocator, userdata);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_default_params {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ggml_opt_params.layout(),
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_default_params");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_opt_params ggml_opt_default_params(ggml_backend_sched_t backend_sched, enum ggml_opt_loss_type loss_type)
     * }
     */
    public static FunctionDescriptor ggml_opt_default_params$descriptor() {
        return ggml_opt_default_params.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_opt_params ggml_opt_default_params(ggml_backend_sched_t backend_sched, enum ggml_opt_loss_type loss_type)
     * }
     */
    public static MethodHandle ggml_opt_default_params$handle() {
        return ggml_opt_default_params.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_opt_params ggml_opt_default_params(ggml_backend_sched_t backend_sched, enum ggml_opt_loss_type loss_type)
     * }
     */
    public static MemorySegment ggml_opt_default_params$address() {
        return ggml_opt_default_params.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_opt_params ggml_opt_default_params(ggml_backend_sched_t backend_sched, enum ggml_opt_loss_type loss_type)
     * }
     */
    public static MemorySegment ggml_opt_default_params(SegmentAllocator allocator, MemorySegment backend_sched, int loss_type) {
        var mh$ = ggml_opt_default_params.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_default_params", allocator, backend_sched, loss_type);
            }
            return (MemorySegment)mh$.invokeExact(allocator, backend_sched, loss_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            ggml_opt_params.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_opt_context_t ggml_opt_init(struct ggml_opt_params params)
     * }
     */
    public static FunctionDescriptor ggml_opt_init$descriptor() {
        return ggml_opt_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_opt_context_t ggml_opt_init(struct ggml_opt_params params)
     * }
     */
    public static MethodHandle ggml_opt_init$handle() {
        return ggml_opt_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_opt_context_t ggml_opt_init(struct ggml_opt_params params)
     * }
     */
    public static MemorySegment ggml_opt_init$address() {
        return ggml_opt_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_opt_context_t ggml_opt_init(struct ggml_opt_params params)
     * }
     */
    public static MemorySegment ggml_opt_init(MemorySegment params) {
        var mh$ = ggml_opt_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_init", params);
            }
            return (MemorySegment)mh$.invokeExact(params);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_opt_free(ggml_opt_context_t opt_ctx)
     * }
     */
    public static FunctionDescriptor ggml_opt_free$descriptor() {
        return ggml_opt_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_opt_free(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MethodHandle ggml_opt_free$handle() {
        return ggml_opt_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_opt_free(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MemorySegment ggml_opt_free$address() {
        return ggml_opt_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_opt_free(ggml_opt_context_t opt_ctx)
     * }
     */
    public static void ggml_opt_free(MemorySegment opt_ctx) {
        var mh$ = ggml_opt_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_free", opt_ctx);
            }
            mh$.invokeExact(opt_ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_opt_reset(ggml_opt_context_t opt_ctx, bool optimizer)
     * }
     */
    public static FunctionDescriptor ggml_opt_reset$descriptor() {
        return ggml_opt_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_opt_reset(ggml_opt_context_t opt_ctx, bool optimizer)
     * }
     */
    public static MethodHandle ggml_opt_reset$handle() {
        return ggml_opt_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_opt_reset(ggml_opt_context_t opt_ctx, bool optimizer)
     * }
     */
    public static MemorySegment ggml_opt_reset$address() {
        return ggml_opt_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_opt_reset(ggml_opt_context_t opt_ctx, bool optimizer)
     * }
     */
    public static void ggml_opt_reset(MemorySegment opt_ctx, boolean optimizer) {
        var mh$ = ggml_opt_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_reset", opt_ctx, optimizer);
            }
            mh$.invokeExact(opt_ctx, optimizer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_static_graphs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_static_graphs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern bool ggml_opt_static_graphs(ggml_opt_context_t opt_ctx)
     * }
     */
    public static FunctionDescriptor ggml_opt_static_graphs$descriptor() {
        return ggml_opt_static_graphs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern bool ggml_opt_static_graphs(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MethodHandle ggml_opt_static_graphs$handle() {
        return ggml_opt_static_graphs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern bool ggml_opt_static_graphs(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MemorySegment ggml_opt_static_graphs$address() {
        return ggml_opt_static_graphs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern bool ggml_opt_static_graphs(ggml_opt_context_t opt_ctx)
     * }
     */
    public static boolean ggml_opt_static_graphs(MemorySegment opt_ctx) {
        var mh$ = ggml_opt_static_graphs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_static_graphs", opt_ctx);
            }
            return (boolean)mh$.invokeExact(opt_ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_inputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_inputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_inputs(ggml_opt_context_t opt_ctx)
     * }
     */
    public static FunctionDescriptor ggml_opt_inputs$descriptor() {
        return ggml_opt_inputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_inputs(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MethodHandle ggml_opt_inputs$handle() {
        return ggml_opt_inputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_inputs(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MemorySegment ggml_opt_inputs$address() {
        return ggml_opt_inputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_inputs(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MemorySegment ggml_opt_inputs(MemorySegment opt_ctx) {
        var mh$ = ggml_opt_inputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_inputs", opt_ctx);
            }
            return (MemorySegment)mh$.invokeExact(opt_ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_outputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_outputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_outputs(ggml_opt_context_t opt_ctx)
     * }
     */
    public static FunctionDescriptor ggml_opt_outputs$descriptor() {
        return ggml_opt_outputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_outputs(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MethodHandle ggml_opt_outputs$handle() {
        return ggml_opt_outputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_outputs(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MemorySegment ggml_opt_outputs$address() {
        return ggml_opt_outputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_outputs(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MemorySegment ggml_opt_outputs(MemorySegment opt_ctx) {
        var mh$ = ggml_opt_outputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_outputs", opt_ctx);
            }
            return (MemorySegment)mh$.invokeExact(opt_ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_labels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_labels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_labels(ggml_opt_context_t opt_ctx)
     * }
     */
    public static FunctionDescriptor ggml_opt_labels$descriptor() {
        return ggml_opt_labels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_labels(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MethodHandle ggml_opt_labels$handle() {
        return ggml_opt_labels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_labels(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MemorySegment ggml_opt_labels$address() {
        return ggml_opt_labels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_labels(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MemorySegment ggml_opt_labels(MemorySegment opt_ctx) {
        var mh$ = ggml_opt_labels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_labels", opt_ctx);
            }
            return (MemorySegment)mh$.invokeExact(opt_ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_loss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_loss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_loss(ggml_opt_context_t opt_ctx)
     * }
     */
    public static FunctionDescriptor ggml_opt_loss$descriptor() {
        return ggml_opt_loss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_loss(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MethodHandle ggml_opt_loss$handle() {
        return ggml_opt_loss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_loss(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MemorySegment ggml_opt_loss$address() {
        return ggml_opt_loss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_loss(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MemorySegment ggml_opt_loss(MemorySegment opt_ctx) {
        var mh$ = ggml_opt_loss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_loss", opt_ctx);
            }
            return (MemorySegment)mh$.invokeExact(opt_ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_pred {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_pred");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_pred(ggml_opt_context_t opt_ctx)
     * }
     */
    public static FunctionDescriptor ggml_opt_pred$descriptor() {
        return ggml_opt_pred.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_pred(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MethodHandle ggml_opt_pred$handle() {
        return ggml_opt_pred.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_pred(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MemorySegment ggml_opt_pred$address() {
        return ggml_opt_pred.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_pred(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MemorySegment ggml_opt_pred(MemorySegment opt_ctx) {
        var mh$ = ggml_opt_pred.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_pred", opt_ctx);
            }
            return (MemorySegment)mh$.invokeExact(opt_ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_ncorrect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_ncorrect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_ncorrect(ggml_opt_context_t opt_ctx)
     * }
     */
    public static FunctionDescriptor ggml_opt_ncorrect$descriptor() {
        return ggml_opt_ncorrect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_ncorrect(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MethodHandle ggml_opt_ncorrect$handle() {
        return ggml_opt_ncorrect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_ncorrect(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MemorySegment ggml_opt_ncorrect$address() {
        return ggml_opt_ncorrect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_ncorrect(ggml_opt_context_t opt_ctx)
     * }
     */
    public static MemorySegment ggml_opt_ncorrect(MemorySegment opt_ctx) {
        var mh$ = ggml_opt_ncorrect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_ncorrect", opt_ctx);
            }
            return (MemorySegment)mh$.invokeExact(opt_ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_grad_acc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_grad_acc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_grad_acc(ggml_opt_context_t opt_ctx, struct ggml_tensor *node)
     * }
     */
    public static FunctionDescriptor ggml_opt_grad_acc$descriptor() {
        return ggml_opt_grad_acc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_grad_acc(ggml_opt_context_t opt_ctx, struct ggml_tensor *node)
     * }
     */
    public static MethodHandle ggml_opt_grad_acc$handle() {
        return ggml_opt_grad_acc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_grad_acc(ggml_opt_context_t opt_ctx, struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_opt_grad_acc$address() {
        return ggml_opt_grad_acc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern struct ggml_tensor *ggml_opt_grad_acc(ggml_opt_context_t opt_ctx, struct ggml_tensor *node)
     * }
     */
    public static MemorySegment ggml_opt_grad_acc(MemorySegment opt_ctx, MemorySegment node) {
        var mh$ = ggml_opt_grad_acc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_grad_acc", opt_ctx, node);
            }
            return (MemorySegment)mh$.invokeExact(opt_ctx, node);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_result_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_result_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ggml_opt_result_t ggml_opt_result_init(void)
     * }
     */
    public static FunctionDescriptor ggml_opt_result_init$descriptor() {
        return ggml_opt_result_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ggml_opt_result_t ggml_opt_result_init(void)
     * }
     */
    public static MethodHandle ggml_opt_result_init$handle() {
        return ggml_opt_result_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ggml_opt_result_t ggml_opt_result_init(void)
     * }
     */
    public static MemorySegment ggml_opt_result_init$address() {
        return ggml_opt_result_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ggml_opt_result_t ggml_opt_result_init(void)
     * }
     */
    public static MemorySegment ggml_opt_result_init() {
        var mh$ = ggml_opt_result_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_result_init");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_result_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_result_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_opt_result_free(ggml_opt_result_t result)
     * }
     */
    public static FunctionDescriptor ggml_opt_result_free$descriptor() {
        return ggml_opt_result_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_opt_result_free(ggml_opt_result_t result)
     * }
     */
    public static MethodHandle ggml_opt_result_free$handle() {
        return ggml_opt_result_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_opt_result_free(ggml_opt_result_t result)
     * }
     */
    public static MemorySegment ggml_opt_result_free$address() {
        return ggml_opt_result_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_opt_result_free(ggml_opt_result_t result)
     * }
     */
    public static void ggml_opt_result_free(MemorySegment result) {
        var mh$ = ggml_opt_result_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_result_free", result);
            }
            mh$.invokeExact(result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_result_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_result_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_opt_result_reset(ggml_opt_result_t result)
     * }
     */
    public static FunctionDescriptor ggml_opt_result_reset$descriptor() {
        return ggml_opt_result_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_opt_result_reset(ggml_opt_result_t result)
     * }
     */
    public static MethodHandle ggml_opt_result_reset$handle() {
        return ggml_opt_result_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_opt_result_reset(ggml_opt_result_t result)
     * }
     */
    public static MemorySegment ggml_opt_result_reset$address() {
        return ggml_opt_result_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_opt_result_reset(ggml_opt_result_t result)
     * }
     */
    public static void ggml_opt_result_reset(MemorySegment result) {
        var mh$ = ggml_opt_result_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_result_reset", result);
            }
            mh$.invokeExact(result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_result_ndata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_result_ndata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_opt_result_ndata(ggml_opt_result_t result, int64_t *ndata)
     * }
     */
    public static FunctionDescriptor ggml_opt_result_ndata$descriptor() {
        return ggml_opt_result_ndata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_opt_result_ndata(ggml_opt_result_t result, int64_t *ndata)
     * }
     */
    public static MethodHandle ggml_opt_result_ndata$handle() {
        return ggml_opt_result_ndata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_opt_result_ndata(ggml_opt_result_t result, int64_t *ndata)
     * }
     */
    public static MemorySegment ggml_opt_result_ndata$address() {
        return ggml_opt_result_ndata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_opt_result_ndata(ggml_opt_result_t result, int64_t *ndata)
     * }
     */
    public static void ggml_opt_result_ndata(MemorySegment result, MemorySegment ndata) {
        var mh$ = ggml_opt_result_ndata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_result_ndata", result, ndata);
            }
            mh$.invokeExact(result, ndata);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_result_loss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_result_loss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_opt_result_loss(ggml_opt_result_t result, double *loss, double *unc)
     * }
     */
    public static FunctionDescriptor ggml_opt_result_loss$descriptor() {
        return ggml_opt_result_loss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_opt_result_loss(ggml_opt_result_t result, double *loss, double *unc)
     * }
     */
    public static MethodHandle ggml_opt_result_loss$handle() {
        return ggml_opt_result_loss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_opt_result_loss(ggml_opt_result_t result, double *loss, double *unc)
     * }
     */
    public static MemorySegment ggml_opt_result_loss$address() {
        return ggml_opt_result_loss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_opt_result_loss(ggml_opt_result_t result, double *loss, double *unc)
     * }
     */
    public static void ggml_opt_result_loss(MemorySegment result, MemorySegment loss, MemorySegment unc) {
        var mh$ = ggml_opt_result_loss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_result_loss", result, loss, unc);
            }
            mh$.invokeExact(result, loss, unc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_result_pred {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_result_pred");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_opt_result_pred(ggml_opt_result_t result, int32_t *pred)
     * }
     */
    public static FunctionDescriptor ggml_opt_result_pred$descriptor() {
        return ggml_opt_result_pred.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_opt_result_pred(ggml_opt_result_t result, int32_t *pred)
     * }
     */
    public static MethodHandle ggml_opt_result_pred$handle() {
        return ggml_opt_result_pred.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_opt_result_pred(ggml_opt_result_t result, int32_t *pred)
     * }
     */
    public static MemorySegment ggml_opt_result_pred$address() {
        return ggml_opt_result_pred.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_opt_result_pred(ggml_opt_result_t result, int32_t *pred)
     * }
     */
    public static void ggml_opt_result_pred(MemorySegment result, MemorySegment pred) {
        var mh$ = ggml_opt_result_pred.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_result_pred", result, pred);
            }
            mh$.invokeExact(result, pred);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_result_accuracy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_result_accuracy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_opt_result_accuracy(ggml_opt_result_t result, double *accuracy, double *unc)
     * }
     */
    public static FunctionDescriptor ggml_opt_result_accuracy$descriptor() {
        return ggml_opt_result_accuracy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_opt_result_accuracy(ggml_opt_result_t result, double *accuracy, double *unc)
     * }
     */
    public static MethodHandle ggml_opt_result_accuracy$handle() {
        return ggml_opt_result_accuracy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_opt_result_accuracy(ggml_opt_result_t result, double *accuracy, double *unc)
     * }
     */
    public static MemorySegment ggml_opt_result_accuracy$address() {
        return ggml_opt_result_accuracy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_opt_result_accuracy(ggml_opt_result_t result, double *accuracy, double *unc)
     * }
     */
    public static void ggml_opt_result_accuracy(MemorySegment result, MemorySegment accuracy, MemorySegment unc) {
        var mh$ = ggml_opt_result_accuracy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_result_accuracy", result, accuracy, unc);
            }
            mh$.invokeExact(result, accuracy, unc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_prepare_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_prepare_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_opt_prepare_alloc(ggml_opt_context_t opt_ctx, struct ggml_context *ctx_compute, struct ggml_cgraph *gf, struct ggml_tensor *inputs, struct ggml_tensor *outputs)
     * }
     */
    public static FunctionDescriptor ggml_opt_prepare_alloc$descriptor() {
        return ggml_opt_prepare_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_opt_prepare_alloc(ggml_opt_context_t opt_ctx, struct ggml_context *ctx_compute, struct ggml_cgraph *gf, struct ggml_tensor *inputs, struct ggml_tensor *outputs)
     * }
     */
    public static MethodHandle ggml_opt_prepare_alloc$handle() {
        return ggml_opt_prepare_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_opt_prepare_alloc(ggml_opt_context_t opt_ctx, struct ggml_context *ctx_compute, struct ggml_cgraph *gf, struct ggml_tensor *inputs, struct ggml_tensor *outputs)
     * }
     */
    public static MemorySegment ggml_opt_prepare_alloc$address() {
        return ggml_opt_prepare_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_opt_prepare_alloc(ggml_opt_context_t opt_ctx, struct ggml_context *ctx_compute, struct ggml_cgraph *gf, struct ggml_tensor *inputs, struct ggml_tensor *outputs)
     * }
     */
    public static void ggml_opt_prepare_alloc(MemorySegment opt_ctx, MemorySegment ctx_compute, MemorySegment gf, MemorySegment inputs, MemorySegment outputs) {
        var mh$ = ggml_opt_prepare_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_prepare_alloc", opt_ctx, ctx_compute, gf, inputs, outputs);
            }
            mh$.invokeExact(opt_ctx, ctx_compute, gf, inputs, outputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_opt_alloc(ggml_opt_context_t opt_ctx, bool backward)
     * }
     */
    public static FunctionDescriptor ggml_opt_alloc$descriptor() {
        return ggml_opt_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_opt_alloc(ggml_opt_context_t opt_ctx, bool backward)
     * }
     */
    public static MethodHandle ggml_opt_alloc$handle() {
        return ggml_opt_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_opt_alloc(ggml_opt_context_t opt_ctx, bool backward)
     * }
     */
    public static MemorySegment ggml_opt_alloc$address() {
        return ggml_opt_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_opt_alloc(ggml_opt_context_t opt_ctx, bool backward)
     * }
     */
    public static void ggml_opt_alloc(MemorySegment opt_ctx, boolean backward) {
        var mh$ = ggml_opt_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_alloc", opt_ctx, backward);
            }
            mh$.invokeExact(opt_ctx, backward);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_eval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_eval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_opt_eval(ggml_opt_context_t opt_ctx, ggml_opt_result_t result)
     * }
     */
    public static FunctionDescriptor ggml_opt_eval$descriptor() {
        return ggml_opt_eval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_opt_eval(ggml_opt_context_t opt_ctx, ggml_opt_result_t result)
     * }
     */
    public static MethodHandle ggml_opt_eval$handle() {
        return ggml_opt_eval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_opt_eval(ggml_opt_context_t opt_ctx, ggml_opt_result_t result)
     * }
     */
    public static MemorySegment ggml_opt_eval$address() {
        return ggml_opt_eval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_opt_eval(ggml_opt_context_t opt_ctx, ggml_opt_result_t result)
     * }
     */
    public static void ggml_opt_eval(MemorySegment opt_ctx, MemorySegment result) {
        var mh$ = ggml_opt_eval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_eval", opt_ctx, result);
            }
            mh$.invokeExact(opt_ctx, result);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_epoch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG_LONG,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_epoch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_opt_epoch(ggml_opt_context_t opt_ctx, ggml_opt_dataset_t dataset, ggml_opt_result_t result_train, ggml_opt_result_t result_eval, int64_t idata_split, ggml_opt_epoch_callback callback_train, ggml_opt_epoch_callback callback_eval)
     * }
     */
    public static FunctionDescriptor ggml_opt_epoch$descriptor() {
        return ggml_opt_epoch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_opt_epoch(ggml_opt_context_t opt_ctx, ggml_opt_dataset_t dataset, ggml_opt_result_t result_train, ggml_opt_result_t result_eval, int64_t idata_split, ggml_opt_epoch_callback callback_train, ggml_opt_epoch_callback callback_eval)
     * }
     */
    public static MethodHandle ggml_opt_epoch$handle() {
        return ggml_opt_epoch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_opt_epoch(ggml_opt_context_t opt_ctx, ggml_opt_dataset_t dataset, ggml_opt_result_t result_train, ggml_opt_result_t result_eval, int64_t idata_split, ggml_opt_epoch_callback callback_train, ggml_opt_epoch_callback callback_eval)
     * }
     */
    public static MemorySegment ggml_opt_epoch$address() {
        return ggml_opt_epoch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_opt_epoch(ggml_opt_context_t opt_ctx, ggml_opt_dataset_t dataset, ggml_opt_result_t result_train, ggml_opt_result_t result_eval, int64_t idata_split, ggml_opt_epoch_callback callback_train, ggml_opt_epoch_callback callback_eval)
     * }
     */
    public static void ggml_opt_epoch(MemorySegment opt_ctx, MemorySegment dataset, MemorySegment result_train, MemorySegment result_eval, long idata_split, MemorySegment callback_train, MemorySegment callback_eval) {
        var mh$ = ggml_opt_epoch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_epoch", opt_ctx, dataset, result_train, result_eval, idata_split, callback_train, callback_eval);
            }
            mh$.invokeExact(opt_ctx, dataset, result_train, result_eval, idata_split, callback_train, callback_eval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_epoch_callback_progress_bar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG_LONG,
            llama_h.C_LONG_LONG,
            llama_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_epoch_callback_progress_bar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_opt_epoch_callback_progress_bar(bool train, ggml_opt_context_t opt_ctx, ggml_opt_dataset_t dataset, ggml_opt_result_t result, int64_t ibatch, int64_t ibatch_max, int64_t t_start_us)
     * }
     */
    public static FunctionDescriptor ggml_opt_epoch_callback_progress_bar$descriptor() {
        return ggml_opt_epoch_callback_progress_bar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_opt_epoch_callback_progress_bar(bool train, ggml_opt_context_t opt_ctx, ggml_opt_dataset_t dataset, ggml_opt_result_t result, int64_t ibatch, int64_t ibatch_max, int64_t t_start_us)
     * }
     */
    public static MethodHandle ggml_opt_epoch_callback_progress_bar$handle() {
        return ggml_opt_epoch_callback_progress_bar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_opt_epoch_callback_progress_bar(bool train, ggml_opt_context_t opt_ctx, ggml_opt_dataset_t dataset, ggml_opt_result_t result, int64_t ibatch, int64_t ibatch_max, int64_t t_start_us)
     * }
     */
    public static MemorySegment ggml_opt_epoch_callback_progress_bar$address() {
        return ggml_opt_epoch_callback_progress_bar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_opt_epoch_callback_progress_bar(bool train, ggml_opt_context_t opt_ctx, ggml_opt_dataset_t dataset, ggml_opt_result_t result, int64_t ibatch, int64_t ibatch_max, int64_t t_start_us)
     * }
     */
    public static void ggml_opt_epoch_callback_progress_bar(boolean train, MemorySegment opt_ctx, MemorySegment dataset, MemorySegment result, long ibatch, long ibatch_max, long t_start_us) {
        var mh$ = ggml_opt_epoch_callback_progress_bar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_epoch_callback_progress_bar", train, opt_ctx, dataset, result, ibatch, ibatch_max, t_start_us);
            }
            mh$.invokeExact(train, opt_ctx, dataset, result, ibatch, ibatch_max, t_start_us);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ggml_opt_fit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_LONG_LONG,
            llama_h.C_LONG_LONG,
            llama_h.C_FLOAT,
            llama_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ggml_opt_fit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void ggml_opt_fit(ggml_backend_sched_t backend_sched, struct ggml_context *ctx_compute, struct ggml_tensor *inputs, struct ggml_tensor *outputs, ggml_opt_dataset_t dataset, enum ggml_opt_loss_type loss_type, ggml_opt_get_optimizer_params get_opt_pars, int64_t nepoch, int64_t nbatch_logical, float val_split, bool silent)
     * }
     */
    public static FunctionDescriptor ggml_opt_fit$descriptor() {
        return ggml_opt_fit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void ggml_opt_fit(ggml_backend_sched_t backend_sched, struct ggml_context *ctx_compute, struct ggml_tensor *inputs, struct ggml_tensor *outputs, ggml_opt_dataset_t dataset, enum ggml_opt_loss_type loss_type, ggml_opt_get_optimizer_params get_opt_pars, int64_t nepoch, int64_t nbatch_logical, float val_split, bool silent)
     * }
     */
    public static MethodHandle ggml_opt_fit$handle() {
        return ggml_opt_fit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void ggml_opt_fit(ggml_backend_sched_t backend_sched, struct ggml_context *ctx_compute, struct ggml_tensor *inputs, struct ggml_tensor *outputs, ggml_opt_dataset_t dataset, enum ggml_opt_loss_type loss_type, ggml_opt_get_optimizer_params get_opt_pars, int64_t nepoch, int64_t nbatch_logical, float val_split, bool silent)
     * }
     */
    public static MemorySegment ggml_opt_fit$address() {
        return ggml_opt_fit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void ggml_opt_fit(ggml_backend_sched_t backend_sched, struct ggml_context *ctx_compute, struct ggml_tensor *inputs, struct ggml_tensor *outputs, ggml_opt_dataset_t dataset, enum ggml_opt_loss_type loss_type, ggml_opt_get_optimizer_params get_opt_pars, int64_t nepoch, int64_t nbatch_logical, float val_split, bool silent)
     * }
     */
    public static void ggml_opt_fit(MemorySegment backend_sched, MemorySegment ctx_compute, MemorySegment inputs, MemorySegment outputs, MemorySegment dataset, int loss_type, MemorySegment get_opt_pars, long nepoch, long nbatch_logical, float val_split, boolean silent) {
        var mh$ = ggml_opt_fit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ggml_opt_fit", backend_sched, ctx_compute, inputs, outputs, dataset, loss_type, get_opt_pars, nepoch, nbatch_logical, val_split, silent);
            }
            mh$.invokeExact(backend_sched, ctx_compute, inputs, outputs, dataset, loss_type, get_opt_pars, nepoch, nbatch_logical, val_split, silent);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long rsize_t
     * }
     */
    public static final OfLong rsize_t = llama_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct llama_memory_i *llama_memory_t
     * }
     */
    public static final AddressLayout llama_memory_t = llama_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int32_t llama_pos
     * }
     */
    public static final OfInt llama_pos = llama_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t llama_token
     * }
     */
    public static final OfInt llama_token = llama_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t llama_seq_id
     * }
     */
    public static final OfInt llama_seq_id = llama_h.C_INT;
    private static final int LLAMA_VOCAB_TYPE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_type.LLAMA_VOCAB_TYPE_NONE = 0
     * }
     */
    public static int LLAMA_VOCAB_TYPE_NONE() {
        return LLAMA_VOCAB_TYPE_NONE;
    }
    private static final int LLAMA_VOCAB_TYPE_SPM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_type.LLAMA_VOCAB_TYPE_SPM = 1
     * }
     */
    public static int LLAMA_VOCAB_TYPE_SPM() {
        return LLAMA_VOCAB_TYPE_SPM;
    }
    private static final int LLAMA_VOCAB_TYPE_BPE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_type.LLAMA_VOCAB_TYPE_BPE = 2
     * }
     */
    public static int LLAMA_VOCAB_TYPE_BPE() {
        return LLAMA_VOCAB_TYPE_BPE;
    }
    private static final int LLAMA_VOCAB_TYPE_WPM = (int)3L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_type.LLAMA_VOCAB_TYPE_WPM = 3
     * }
     */
    public static int LLAMA_VOCAB_TYPE_WPM() {
        return LLAMA_VOCAB_TYPE_WPM;
    }
    private static final int LLAMA_VOCAB_TYPE_UGM = (int)4L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_type.LLAMA_VOCAB_TYPE_UGM = 4
     * }
     */
    public static int LLAMA_VOCAB_TYPE_UGM() {
        return LLAMA_VOCAB_TYPE_UGM;
    }
    private static final int LLAMA_VOCAB_TYPE_RWKV = (int)5L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_type.LLAMA_VOCAB_TYPE_RWKV = 5
     * }
     */
    public static int LLAMA_VOCAB_TYPE_RWKV() {
        return LLAMA_VOCAB_TYPE_RWKV;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_DEFAULT = 0
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_DEFAULT() {
        return LLAMA_VOCAB_PRE_TYPE_DEFAULT;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_LLAMA3 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_LLAMA3 = 1
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_LLAMA3() {
        return LLAMA_VOCAB_PRE_TYPE_LLAMA3;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_DEEPSEEK_LLM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_DEEPSEEK_LLM = 2
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_DEEPSEEK_LLM() {
        return LLAMA_VOCAB_PRE_TYPE_DEEPSEEK_LLM;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_DEEPSEEK_CODER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_DEEPSEEK_CODER = 3
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_DEEPSEEK_CODER() {
        return LLAMA_VOCAB_PRE_TYPE_DEEPSEEK_CODER;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_FALCON = (int)4L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_FALCON = 4
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_FALCON() {
        return LLAMA_VOCAB_PRE_TYPE_FALCON;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_MPT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_MPT = 5
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_MPT() {
        return LLAMA_VOCAB_PRE_TYPE_MPT;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_STARCODER = (int)6L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_STARCODER = 6
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_STARCODER() {
        return LLAMA_VOCAB_PRE_TYPE_STARCODER;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_GPT2 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_GPT2 = 7
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_GPT2() {
        return LLAMA_VOCAB_PRE_TYPE_GPT2;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_REFACT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_REFACT = 8
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_REFACT() {
        return LLAMA_VOCAB_PRE_TYPE_REFACT;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_COMMAND_R = (int)9L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_COMMAND_R = 9
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_COMMAND_R() {
        return LLAMA_VOCAB_PRE_TYPE_COMMAND_R;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_STABLELM2 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_STABLELM2 = 10
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_STABLELM2() {
        return LLAMA_VOCAB_PRE_TYPE_STABLELM2;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_QWEN2 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_QWEN2 = 11
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_QWEN2() {
        return LLAMA_VOCAB_PRE_TYPE_QWEN2;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_OLMO = (int)12L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_OLMO = 12
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_OLMO() {
        return LLAMA_VOCAB_PRE_TYPE_OLMO;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_DBRX = (int)13L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_DBRX = 13
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_DBRX() {
        return LLAMA_VOCAB_PRE_TYPE_DBRX;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_SMAUG = (int)14L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_SMAUG = 14
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_SMAUG() {
        return LLAMA_VOCAB_PRE_TYPE_SMAUG;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_PORO = (int)15L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_PORO = 15
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_PORO() {
        return LLAMA_VOCAB_PRE_TYPE_PORO;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_CHATGLM3 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_CHATGLM3 = 16
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_CHATGLM3() {
        return LLAMA_VOCAB_PRE_TYPE_CHATGLM3;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_CHATGLM4 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_CHATGLM4 = 17
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_CHATGLM4() {
        return LLAMA_VOCAB_PRE_TYPE_CHATGLM4;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_VIKING = (int)18L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_VIKING = 18
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_VIKING() {
        return LLAMA_VOCAB_PRE_TYPE_VIKING;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_JAIS = (int)19L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_JAIS = 19
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_JAIS() {
        return LLAMA_VOCAB_PRE_TYPE_JAIS;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_TEKKEN = (int)20L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_TEKKEN = 20
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_TEKKEN() {
        return LLAMA_VOCAB_PRE_TYPE_TEKKEN;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_SMOLLM = (int)21L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_SMOLLM = 21
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_SMOLLM() {
        return LLAMA_VOCAB_PRE_TYPE_SMOLLM;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_CODESHELL = (int)22L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_CODESHELL = 22
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_CODESHELL() {
        return LLAMA_VOCAB_PRE_TYPE_CODESHELL;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_BLOOM = (int)23L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_BLOOM = 23
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_BLOOM() {
        return LLAMA_VOCAB_PRE_TYPE_BLOOM;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_GPT3_FINNISH = (int)24L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_GPT3_FINNISH = 24
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_GPT3_FINNISH() {
        return LLAMA_VOCAB_PRE_TYPE_GPT3_FINNISH;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_EXAONE = (int)25L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_EXAONE = 25
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_EXAONE() {
        return LLAMA_VOCAB_PRE_TYPE_EXAONE;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_CHAMELEON = (int)26L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_CHAMELEON = 26
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_CHAMELEON() {
        return LLAMA_VOCAB_PRE_TYPE_CHAMELEON;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_MINERVA = (int)27L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_MINERVA = 27
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_MINERVA() {
        return LLAMA_VOCAB_PRE_TYPE_MINERVA;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_DEEPSEEK3_LLM = (int)28L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_DEEPSEEK3_LLM = 28
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_DEEPSEEK3_LLM() {
        return LLAMA_VOCAB_PRE_TYPE_DEEPSEEK3_LLM;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_GPT4O = (int)29L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_GPT4O = 29
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_GPT4O() {
        return LLAMA_VOCAB_PRE_TYPE_GPT4O;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_SUPERBPE = (int)30L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_SUPERBPE = 30
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_SUPERBPE() {
        return LLAMA_VOCAB_PRE_TYPE_SUPERBPE;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_TRILLION = (int)31L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_TRILLION = 31
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_TRILLION() {
        return LLAMA_VOCAB_PRE_TYPE_TRILLION;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_BAILINGMOE = (int)32L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_BAILINGMOE = 32
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_BAILINGMOE() {
        return LLAMA_VOCAB_PRE_TYPE_BAILINGMOE;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_LLAMA4 = (int)33L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_LLAMA4 = 33
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_LLAMA4() {
        return LLAMA_VOCAB_PRE_TYPE_LLAMA4;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_PIXTRAL = (int)34L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_PIXTRAL = 34
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_PIXTRAL() {
        return LLAMA_VOCAB_PRE_TYPE_PIXTRAL;
    }
    private static final int LLAMA_VOCAB_PRE_TYPE_SEED_CODER = (int)35L;
    /**
     * {@snippet lang=c :
     * enum llama_vocab_pre_type.LLAMA_VOCAB_PRE_TYPE_SEED_CODER = 35
     * }
     */
    public static int LLAMA_VOCAB_PRE_TYPE_SEED_CODER() {
        return LLAMA_VOCAB_PRE_TYPE_SEED_CODER;
    }
    private static final int LLAMA_ROPE_TYPE_NONE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum llama_rope_type.LLAMA_ROPE_TYPE_NONE = -1
     * }
     */
    public static int LLAMA_ROPE_TYPE_NONE() {
        return LLAMA_ROPE_TYPE_NONE;
    }
    private static final int LLAMA_ROPE_TYPE_NORM = (int)0L;
    /**
     * {@snippet lang=c :
     * enum llama_rope_type.LLAMA_ROPE_TYPE_NORM = 0
     * }
     */
    public static int LLAMA_ROPE_TYPE_NORM() {
        return LLAMA_ROPE_TYPE_NORM;
    }
    private static final int LLAMA_ROPE_TYPE_NEOX = (int)2L;
    /**
     * {@snippet lang=c :
     * enum llama_rope_type.LLAMA_ROPE_TYPE_NEOX = 2
     * }
     */
    public static int LLAMA_ROPE_TYPE_NEOX() {
        return LLAMA_ROPE_TYPE_NEOX;
    }
    private static final int LLAMA_ROPE_TYPE_MROPE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum llama_rope_type.LLAMA_ROPE_TYPE_MROPE = 8
     * }
     */
    public static int LLAMA_ROPE_TYPE_MROPE() {
        return LLAMA_ROPE_TYPE_MROPE;
    }
    private static final int LLAMA_ROPE_TYPE_VISION = (int)24L;
    /**
     * {@snippet lang=c :
     * enum llama_rope_type.LLAMA_ROPE_TYPE_VISION = 24
     * }
     */
    public static int LLAMA_ROPE_TYPE_VISION() {
        return LLAMA_ROPE_TYPE_VISION;
    }
    private static final int LLAMA_TOKEN_TYPE_UNDEFINED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum llama_token_type.LLAMA_TOKEN_TYPE_UNDEFINED = 0
     * }
     */
    public static int LLAMA_TOKEN_TYPE_UNDEFINED() {
        return LLAMA_TOKEN_TYPE_UNDEFINED;
    }
    private static final int LLAMA_TOKEN_TYPE_NORMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum llama_token_type.LLAMA_TOKEN_TYPE_NORMAL = 1
     * }
     */
    public static int LLAMA_TOKEN_TYPE_NORMAL() {
        return LLAMA_TOKEN_TYPE_NORMAL;
    }
    private static final int LLAMA_TOKEN_TYPE_UNKNOWN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum llama_token_type.LLAMA_TOKEN_TYPE_UNKNOWN = 2
     * }
     */
    public static int LLAMA_TOKEN_TYPE_UNKNOWN() {
        return LLAMA_TOKEN_TYPE_UNKNOWN;
    }
    private static final int LLAMA_TOKEN_TYPE_CONTROL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum llama_token_type.LLAMA_TOKEN_TYPE_CONTROL = 3
     * }
     */
    public static int LLAMA_TOKEN_TYPE_CONTROL() {
        return LLAMA_TOKEN_TYPE_CONTROL;
    }
    private static final int LLAMA_TOKEN_TYPE_USER_DEFINED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum llama_token_type.LLAMA_TOKEN_TYPE_USER_DEFINED = 4
     * }
     */
    public static int LLAMA_TOKEN_TYPE_USER_DEFINED() {
        return LLAMA_TOKEN_TYPE_USER_DEFINED;
    }
    private static final int LLAMA_TOKEN_TYPE_UNUSED = (int)5L;
    /**
     * {@snippet lang=c :
     * enum llama_token_type.LLAMA_TOKEN_TYPE_UNUSED = 5
     * }
     */
    public static int LLAMA_TOKEN_TYPE_UNUSED() {
        return LLAMA_TOKEN_TYPE_UNUSED;
    }
    private static final int LLAMA_TOKEN_TYPE_BYTE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum llama_token_type.LLAMA_TOKEN_TYPE_BYTE = 6
     * }
     */
    public static int LLAMA_TOKEN_TYPE_BYTE() {
        return LLAMA_TOKEN_TYPE_BYTE;
    }
    private static final int LLAMA_TOKEN_ATTR_UNDEFINED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum llama_token_attr.LLAMA_TOKEN_ATTR_UNDEFINED = 0
     * }
     */
    public static int LLAMA_TOKEN_ATTR_UNDEFINED() {
        return LLAMA_TOKEN_ATTR_UNDEFINED;
    }
    private static final int LLAMA_TOKEN_ATTR_UNKNOWN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum llama_token_attr.LLAMA_TOKEN_ATTR_UNKNOWN = 1
     * }
     */
    public static int LLAMA_TOKEN_ATTR_UNKNOWN() {
        return LLAMA_TOKEN_ATTR_UNKNOWN;
    }
    private static final int LLAMA_TOKEN_ATTR_UNUSED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum llama_token_attr.LLAMA_TOKEN_ATTR_UNUSED = 2
     * }
     */
    public static int LLAMA_TOKEN_ATTR_UNUSED() {
        return LLAMA_TOKEN_ATTR_UNUSED;
    }
    private static final int LLAMA_TOKEN_ATTR_NORMAL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum llama_token_attr.LLAMA_TOKEN_ATTR_NORMAL = 4
     * }
     */
    public static int LLAMA_TOKEN_ATTR_NORMAL() {
        return LLAMA_TOKEN_ATTR_NORMAL;
    }
    private static final int LLAMA_TOKEN_ATTR_CONTROL = (int)8L;
    /**
     * {@snippet lang=c :
     * enum llama_token_attr.LLAMA_TOKEN_ATTR_CONTROL = 8
     * }
     */
    public static int LLAMA_TOKEN_ATTR_CONTROL() {
        return LLAMA_TOKEN_ATTR_CONTROL;
    }
    private static final int LLAMA_TOKEN_ATTR_USER_DEFINED = (int)16L;
    /**
     * {@snippet lang=c :
     * enum llama_token_attr.LLAMA_TOKEN_ATTR_USER_DEFINED = 16
     * }
     */
    public static int LLAMA_TOKEN_ATTR_USER_DEFINED() {
        return LLAMA_TOKEN_ATTR_USER_DEFINED;
    }
    private static final int LLAMA_TOKEN_ATTR_BYTE = (int)32L;
    /**
     * {@snippet lang=c :
     * enum llama_token_attr.LLAMA_TOKEN_ATTR_BYTE = 32
     * }
     */
    public static int LLAMA_TOKEN_ATTR_BYTE() {
        return LLAMA_TOKEN_ATTR_BYTE;
    }
    private static final int LLAMA_TOKEN_ATTR_NORMALIZED = (int)64L;
    /**
     * {@snippet lang=c :
     * enum llama_token_attr.LLAMA_TOKEN_ATTR_NORMALIZED = 64
     * }
     */
    public static int LLAMA_TOKEN_ATTR_NORMALIZED() {
        return LLAMA_TOKEN_ATTR_NORMALIZED;
    }
    private static final int LLAMA_TOKEN_ATTR_LSTRIP = (int)128L;
    /**
     * {@snippet lang=c :
     * enum llama_token_attr.LLAMA_TOKEN_ATTR_LSTRIP = 128
     * }
     */
    public static int LLAMA_TOKEN_ATTR_LSTRIP() {
        return LLAMA_TOKEN_ATTR_LSTRIP;
    }
    private static final int LLAMA_TOKEN_ATTR_RSTRIP = (int)256L;
    /**
     * {@snippet lang=c :
     * enum llama_token_attr.LLAMA_TOKEN_ATTR_RSTRIP = 256
     * }
     */
    public static int LLAMA_TOKEN_ATTR_RSTRIP() {
        return LLAMA_TOKEN_ATTR_RSTRIP;
    }
    private static final int LLAMA_TOKEN_ATTR_SINGLE_WORD = (int)512L;
    /**
     * {@snippet lang=c :
     * enum llama_token_attr.LLAMA_TOKEN_ATTR_SINGLE_WORD = 512
     * }
     */
    public static int LLAMA_TOKEN_ATTR_SINGLE_WORD() {
        return LLAMA_TOKEN_ATTR_SINGLE_WORD;
    }
    private static final int LLAMA_FTYPE_ALL_F32 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_ALL_F32 = 0
     * }
     */
    public static int LLAMA_FTYPE_ALL_F32() {
        return LLAMA_FTYPE_ALL_F32;
    }
    private static final int LLAMA_FTYPE_MOSTLY_F16 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_F16 = 1
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_F16() {
        return LLAMA_FTYPE_MOSTLY_F16;
    }
    private static final int LLAMA_FTYPE_MOSTLY_Q4_0 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_Q4_0 = 2
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_Q4_0() {
        return LLAMA_FTYPE_MOSTLY_Q4_0;
    }
    private static final int LLAMA_FTYPE_MOSTLY_Q4_1 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_Q4_1 = 3
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_Q4_1() {
        return LLAMA_FTYPE_MOSTLY_Q4_1;
    }
    private static final int LLAMA_FTYPE_MOSTLY_Q8_0 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_Q8_0 = 7
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_Q8_0() {
        return LLAMA_FTYPE_MOSTLY_Q8_0;
    }
    private static final int LLAMA_FTYPE_MOSTLY_Q5_0 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_Q5_0 = 8
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_Q5_0() {
        return LLAMA_FTYPE_MOSTLY_Q5_0;
    }
    private static final int LLAMA_FTYPE_MOSTLY_Q5_1 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_Q5_1 = 9
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_Q5_1() {
        return LLAMA_FTYPE_MOSTLY_Q5_1;
    }
    private static final int LLAMA_FTYPE_MOSTLY_Q2_K = (int)10L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_Q2_K = 10
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_Q2_K() {
        return LLAMA_FTYPE_MOSTLY_Q2_K;
    }
    private static final int LLAMA_FTYPE_MOSTLY_Q3_K_S = (int)11L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_Q3_K_S = 11
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_Q3_K_S() {
        return LLAMA_FTYPE_MOSTLY_Q3_K_S;
    }
    private static final int LLAMA_FTYPE_MOSTLY_Q3_K_M = (int)12L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_Q3_K_M = 12
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_Q3_K_M() {
        return LLAMA_FTYPE_MOSTLY_Q3_K_M;
    }
    private static final int LLAMA_FTYPE_MOSTLY_Q3_K_L = (int)13L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_Q3_K_L = 13
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_Q3_K_L() {
        return LLAMA_FTYPE_MOSTLY_Q3_K_L;
    }
    private static final int LLAMA_FTYPE_MOSTLY_Q4_K_S = (int)14L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_Q4_K_S = 14
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_Q4_K_S() {
        return LLAMA_FTYPE_MOSTLY_Q4_K_S;
    }
    private static final int LLAMA_FTYPE_MOSTLY_Q4_K_M = (int)15L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_Q4_K_M = 15
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_Q4_K_M() {
        return LLAMA_FTYPE_MOSTLY_Q4_K_M;
    }
    private static final int LLAMA_FTYPE_MOSTLY_Q5_K_S = (int)16L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_Q5_K_S = 16
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_Q5_K_S() {
        return LLAMA_FTYPE_MOSTLY_Q5_K_S;
    }
    private static final int LLAMA_FTYPE_MOSTLY_Q5_K_M = (int)17L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_Q5_K_M = 17
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_Q5_K_M() {
        return LLAMA_FTYPE_MOSTLY_Q5_K_M;
    }
    private static final int LLAMA_FTYPE_MOSTLY_Q6_K = (int)18L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_Q6_K = 18
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_Q6_K() {
        return LLAMA_FTYPE_MOSTLY_Q6_K;
    }
    private static final int LLAMA_FTYPE_MOSTLY_IQ2_XXS = (int)19L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_IQ2_XXS = 19
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_IQ2_XXS() {
        return LLAMA_FTYPE_MOSTLY_IQ2_XXS;
    }
    private static final int LLAMA_FTYPE_MOSTLY_IQ2_XS = (int)20L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_IQ2_XS = 20
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_IQ2_XS() {
        return LLAMA_FTYPE_MOSTLY_IQ2_XS;
    }
    private static final int LLAMA_FTYPE_MOSTLY_Q2_K_S = (int)21L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_Q2_K_S = 21
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_Q2_K_S() {
        return LLAMA_FTYPE_MOSTLY_Q2_K_S;
    }
    private static final int LLAMA_FTYPE_MOSTLY_IQ3_XS = (int)22L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_IQ3_XS = 22
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_IQ3_XS() {
        return LLAMA_FTYPE_MOSTLY_IQ3_XS;
    }
    private static final int LLAMA_FTYPE_MOSTLY_IQ3_XXS = (int)23L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_IQ3_XXS = 23
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_IQ3_XXS() {
        return LLAMA_FTYPE_MOSTLY_IQ3_XXS;
    }
    private static final int LLAMA_FTYPE_MOSTLY_IQ1_S = (int)24L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_IQ1_S = 24
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_IQ1_S() {
        return LLAMA_FTYPE_MOSTLY_IQ1_S;
    }
    private static final int LLAMA_FTYPE_MOSTLY_IQ4_NL = (int)25L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_IQ4_NL = 25
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_IQ4_NL() {
        return LLAMA_FTYPE_MOSTLY_IQ4_NL;
    }
    private static final int LLAMA_FTYPE_MOSTLY_IQ3_S = (int)26L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_IQ3_S = 26
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_IQ3_S() {
        return LLAMA_FTYPE_MOSTLY_IQ3_S;
    }
    private static final int LLAMA_FTYPE_MOSTLY_IQ3_M = (int)27L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_IQ3_M = 27
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_IQ3_M() {
        return LLAMA_FTYPE_MOSTLY_IQ3_M;
    }
    private static final int LLAMA_FTYPE_MOSTLY_IQ2_S = (int)28L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_IQ2_S = 28
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_IQ2_S() {
        return LLAMA_FTYPE_MOSTLY_IQ2_S;
    }
    private static final int LLAMA_FTYPE_MOSTLY_IQ2_M = (int)29L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_IQ2_M = 29
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_IQ2_M() {
        return LLAMA_FTYPE_MOSTLY_IQ2_M;
    }
    private static final int LLAMA_FTYPE_MOSTLY_IQ4_XS = (int)30L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_IQ4_XS = 30
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_IQ4_XS() {
        return LLAMA_FTYPE_MOSTLY_IQ4_XS;
    }
    private static final int LLAMA_FTYPE_MOSTLY_IQ1_M = (int)31L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_IQ1_M = 31
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_IQ1_M() {
        return LLAMA_FTYPE_MOSTLY_IQ1_M;
    }
    private static final int LLAMA_FTYPE_MOSTLY_BF16 = (int)32L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_BF16 = 32
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_BF16() {
        return LLAMA_FTYPE_MOSTLY_BF16;
    }
    private static final int LLAMA_FTYPE_MOSTLY_TQ1_0 = (int)36L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_TQ1_0 = 36
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_TQ1_0() {
        return LLAMA_FTYPE_MOSTLY_TQ1_0;
    }
    private static final int LLAMA_FTYPE_MOSTLY_TQ2_0 = (int)37L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_MOSTLY_TQ2_0 = 37
     * }
     */
    public static int LLAMA_FTYPE_MOSTLY_TQ2_0() {
        return LLAMA_FTYPE_MOSTLY_TQ2_0;
    }
    private static final int LLAMA_FTYPE_GUESSED = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum llama_ftype.LLAMA_FTYPE_GUESSED = 1024
     * }
     */
    public static int LLAMA_FTYPE_GUESSED() {
        return LLAMA_FTYPE_GUESSED;
    }
    private static final int LLAMA_ROPE_SCALING_TYPE_UNSPECIFIED = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum llama_rope_scaling_type.LLAMA_ROPE_SCALING_TYPE_UNSPECIFIED = -1
     * }
     */
    public static int LLAMA_ROPE_SCALING_TYPE_UNSPECIFIED() {
        return LLAMA_ROPE_SCALING_TYPE_UNSPECIFIED;
    }
    private static final int LLAMA_ROPE_SCALING_TYPE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum llama_rope_scaling_type.LLAMA_ROPE_SCALING_TYPE_NONE = 0
     * }
     */
    public static int LLAMA_ROPE_SCALING_TYPE_NONE() {
        return LLAMA_ROPE_SCALING_TYPE_NONE;
    }
    private static final int LLAMA_ROPE_SCALING_TYPE_LINEAR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum llama_rope_scaling_type.LLAMA_ROPE_SCALING_TYPE_LINEAR = 1
     * }
     */
    public static int LLAMA_ROPE_SCALING_TYPE_LINEAR() {
        return LLAMA_ROPE_SCALING_TYPE_LINEAR;
    }
    private static final int LLAMA_ROPE_SCALING_TYPE_YARN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum llama_rope_scaling_type.LLAMA_ROPE_SCALING_TYPE_YARN = 2
     * }
     */
    public static int LLAMA_ROPE_SCALING_TYPE_YARN() {
        return LLAMA_ROPE_SCALING_TYPE_YARN;
    }
    private static final int LLAMA_ROPE_SCALING_TYPE_LONGROPE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum llama_rope_scaling_type.LLAMA_ROPE_SCALING_TYPE_LONGROPE = 3
     * }
     */
    public static int LLAMA_ROPE_SCALING_TYPE_LONGROPE() {
        return LLAMA_ROPE_SCALING_TYPE_LONGROPE;
    }
    private static final int LLAMA_ROPE_SCALING_TYPE_MAX_VALUE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum llama_rope_scaling_type.LLAMA_ROPE_SCALING_TYPE_MAX_VALUE = 3
     * }
     */
    public static int LLAMA_ROPE_SCALING_TYPE_MAX_VALUE() {
        return LLAMA_ROPE_SCALING_TYPE_MAX_VALUE;
    }
    private static final int LLAMA_POOLING_TYPE_UNSPECIFIED = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum llama_pooling_type.LLAMA_POOLING_TYPE_UNSPECIFIED = -1
     * }
     */
    public static int LLAMA_POOLING_TYPE_UNSPECIFIED() {
        return LLAMA_POOLING_TYPE_UNSPECIFIED;
    }
    private static final int LLAMA_POOLING_TYPE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum llama_pooling_type.LLAMA_POOLING_TYPE_NONE = 0
     * }
     */
    public static int LLAMA_POOLING_TYPE_NONE() {
        return LLAMA_POOLING_TYPE_NONE;
    }
    private static final int LLAMA_POOLING_TYPE_MEAN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum llama_pooling_type.LLAMA_POOLING_TYPE_MEAN = 1
     * }
     */
    public static int LLAMA_POOLING_TYPE_MEAN() {
        return LLAMA_POOLING_TYPE_MEAN;
    }
    private static final int LLAMA_POOLING_TYPE_CLS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum llama_pooling_type.LLAMA_POOLING_TYPE_CLS = 2
     * }
     */
    public static int LLAMA_POOLING_TYPE_CLS() {
        return LLAMA_POOLING_TYPE_CLS;
    }
    private static final int LLAMA_POOLING_TYPE_LAST = (int)3L;
    /**
     * {@snippet lang=c :
     * enum llama_pooling_type.LLAMA_POOLING_TYPE_LAST = 3
     * }
     */
    public static int LLAMA_POOLING_TYPE_LAST() {
        return LLAMA_POOLING_TYPE_LAST;
    }
    private static final int LLAMA_POOLING_TYPE_RANK = (int)4L;
    /**
     * {@snippet lang=c :
     * enum llama_pooling_type.LLAMA_POOLING_TYPE_RANK = 4
     * }
     */
    public static int LLAMA_POOLING_TYPE_RANK() {
        return LLAMA_POOLING_TYPE_RANK;
    }
    private static final int LLAMA_ATTENTION_TYPE_UNSPECIFIED = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum llama_attention_type.LLAMA_ATTENTION_TYPE_UNSPECIFIED = -1
     * }
     */
    public static int LLAMA_ATTENTION_TYPE_UNSPECIFIED() {
        return LLAMA_ATTENTION_TYPE_UNSPECIFIED;
    }
    private static final int LLAMA_ATTENTION_TYPE_CAUSAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum llama_attention_type.LLAMA_ATTENTION_TYPE_CAUSAL = 0
     * }
     */
    public static int LLAMA_ATTENTION_TYPE_CAUSAL() {
        return LLAMA_ATTENTION_TYPE_CAUSAL;
    }
    private static final int LLAMA_ATTENTION_TYPE_NON_CAUSAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum llama_attention_type.LLAMA_ATTENTION_TYPE_NON_CAUSAL = 1
     * }
     */
    public static int LLAMA_ATTENTION_TYPE_NON_CAUSAL() {
        return LLAMA_ATTENTION_TYPE_NON_CAUSAL;
    }
    private static final int LLAMA_SPLIT_MODE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum llama_split_mode.LLAMA_SPLIT_MODE_NONE = 0
     * }
     */
    public static int LLAMA_SPLIT_MODE_NONE() {
        return LLAMA_SPLIT_MODE_NONE;
    }
    private static final int LLAMA_SPLIT_MODE_LAYER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum llama_split_mode.LLAMA_SPLIT_MODE_LAYER = 1
     * }
     */
    public static int LLAMA_SPLIT_MODE_LAYER() {
        return LLAMA_SPLIT_MODE_LAYER;
    }
    private static final int LLAMA_SPLIT_MODE_ROW = (int)2L;
    /**
     * {@snippet lang=c :
     * enum llama_split_mode.LLAMA_SPLIT_MODE_ROW = 2
     * }
     */
    public static int LLAMA_SPLIT_MODE_ROW() {
        return LLAMA_SPLIT_MODE_ROW;
    }
    private static final int LLAMA_KV_OVERRIDE_TYPE_INT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum llama_model_kv_override_type.LLAMA_KV_OVERRIDE_TYPE_INT = 0
     * }
     */
    public static int LLAMA_KV_OVERRIDE_TYPE_INT() {
        return LLAMA_KV_OVERRIDE_TYPE_INT;
    }
    private static final int LLAMA_KV_OVERRIDE_TYPE_FLOAT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum llama_model_kv_override_type.LLAMA_KV_OVERRIDE_TYPE_FLOAT = 1
     * }
     */
    public static int LLAMA_KV_OVERRIDE_TYPE_FLOAT() {
        return LLAMA_KV_OVERRIDE_TYPE_FLOAT;
    }
    private static final int LLAMA_KV_OVERRIDE_TYPE_BOOL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum llama_model_kv_override_type.LLAMA_KV_OVERRIDE_TYPE_BOOL = 2
     * }
     */
    public static int LLAMA_KV_OVERRIDE_TYPE_BOOL() {
        return LLAMA_KV_OVERRIDE_TYPE_BOOL;
    }
    private static final int LLAMA_KV_OVERRIDE_TYPE_STR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum llama_model_kv_override_type.LLAMA_KV_OVERRIDE_TYPE_STR = 3
     * }
     */
    public static int LLAMA_KV_OVERRIDE_TYPE_STR() {
        return LLAMA_KV_OVERRIDE_TYPE_STR;
    }

    private static class llama_model_default_params {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_model_params.layout()    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_default_params");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_model_params llama_model_default_params(void)
     * }
     */
    public static FunctionDescriptor llama_model_default_params$descriptor() {
        return llama_model_default_params.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_model_params llama_model_default_params(void)
     * }
     */
    public static MethodHandle llama_model_default_params$handle() {
        return llama_model_default_params.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_model_params llama_model_default_params(void)
     * }
     */
    public static MemorySegment llama_model_default_params$address() {
        return llama_model_default_params.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_model_params llama_model_default_params(void)
     * }
     */
    public static MemorySegment llama_model_default_params(SegmentAllocator allocator) {
        var mh$ = llama_model_default_params.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_default_params", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_context_default_params {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_context_params.layout()    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_context_default_params");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_context_params llama_context_default_params(void)
     * }
     */
    public static FunctionDescriptor llama_context_default_params$descriptor() {
        return llama_context_default_params.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_context_params llama_context_default_params(void)
     * }
     */
    public static MethodHandle llama_context_default_params$handle() {
        return llama_context_default_params.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_context_params llama_context_default_params(void)
     * }
     */
    public static MemorySegment llama_context_default_params$address() {
        return llama_context_default_params.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_context_params llama_context_default_params(void)
     * }
     */
    public static MemorySegment llama_context_default_params(SegmentAllocator allocator) {
        var mh$ = llama_context_default_params.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_context_default_params", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_chain_default_params {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_sampler_chain_params.layout()    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_chain_default_params");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler_chain_params llama_sampler_chain_default_params(void)
     * }
     */
    public static FunctionDescriptor llama_sampler_chain_default_params$descriptor() {
        return llama_sampler_chain_default_params.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler_chain_params llama_sampler_chain_default_params(void)
     * }
     */
    public static MethodHandle llama_sampler_chain_default_params$handle() {
        return llama_sampler_chain_default_params.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler_chain_params llama_sampler_chain_default_params(void)
     * }
     */
    public static MemorySegment llama_sampler_chain_default_params$address() {
        return llama_sampler_chain_default_params.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler_chain_params llama_sampler_chain_default_params(void)
     * }
     */
    public static MemorySegment llama_sampler_chain_default_params(SegmentAllocator allocator) {
        var mh$ = llama_sampler_chain_default_params.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_chain_default_params", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_quantize_default_params {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_model_quantize_params.layout()    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_quantize_default_params");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_model_quantize_params llama_model_quantize_default_params(void)
     * }
     */
    public static FunctionDescriptor llama_model_quantize_default_params$descriptor() {
        return llama_model_quantize_default_params.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_model_quantize_params llama_model_quantize_default_params(void)
     * }
     */
    public static MethodHandle llama_model_quantize_default_params$handle() {
        return llama_model_quantize_default_params.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_model_quantize_params llama_model_quantize_default_params(void)
     * }
     */
    public static MemorySegment llama_model_quantize_default_params$address() {
        return llama_model_quantize_default_params.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_model_quantize_params llama_model_quantize_default_params(void)
     * }
     */
    public static MemorySegment llama_model_quantize_default_params(SegmentAllocator allocator) {
        var mh$ = llama_model_quantize_default_params.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_quantize_default_params", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_backend_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_backend_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_backend_init(void)
     * }
     */
    public static FunctionDescriptor llama_backend_init$descriptor() {
        return llama_backend_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_backend_init(void)
     * }
     */
    public static MethodHandle llama_backend_init$handle() {
        return llama_backend_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_backend_init(void)
     * }
     */
    public static MemorySegment llama_backend_init$address() {
        return llama_backend_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_backend_init(void)
     * }
     */
    public static void llama_backend_init() {
        var mh$ = llama_backend_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_backend_init");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_backend_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_backend_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_backend_free(void)
     * }
     */
    public static FunctionDescriptor llama_backend_free$descriptor() {
        return llama_backend_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_backend_free(void)
     * }
     */
    public static MethodHandle llama_backend_free$handle() {
        return llama_backend_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_backend_free(void)
     * }
     */
    public static MemorySegment llama_backend_free$address() {
        return llama_backend_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_backend_free(void)
     * }
     */
    public static void llama_backend_free() {
        var mh$ = llama_backend_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_backend_free");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_numa_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_numa_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_numa_init(enum ggml_numa_strategy numa)
     * }
     */
    public static FunctionDescriptor llama_numa_init$descriptor() {
        return llama_numa_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_numa_init(enum ggml_numa_strategy numa)
     * }
     */
    public static MethodHandle llama_numa_init$handle() {
        return llama_numa_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_numa_init(enum ggml_numa_strategy numa)
     * }
     */
    public static MemorySegment llama_numa_init$address() {
        return llama_numa_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_numa_init(enum ggml_numa_strategy numa)
     * }
     */
    public static void llama_numa_init(int numa) {
        var mh$ = llama_numa_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_numa_init", numa);
            }
            mh$.invokeExact(numa);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_attach_threadpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_attach_threadpool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_attach_threadpool(struct llama_context *ctx, ggml_threadpool_t threadpool, ggml_threadpool_t threadpool_batch)
     * }
     */
    public static FunctionDescriptor llama_attach_threadpool$descriptor() {
        return llama_attach_threadpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_attach_threadpool(struct llama_context *ctx, ggml_threadpool_t threadpool, ggml_threadpool_t threadpool_batch)
     * }
     */
    public static MethodHandle llama_attach_threadpool$handle() {
        return llama_attach_threadpool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_attach_threadpool(struct llama_context *ctx, ggml_threadpool_t threadpool, ggml_threadpool_t threadpool_batch)
     * }
     */
    public static MemorySegment llama_attach_threadpool$address() {
        return llama_attach_threadpool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_attach_threadpool(struct llama_context *ctx, ggml_threadpool_t threadpool, ggml_threadpool_t threadpool_batch)
     * }
     */
    public static void llama_attach_threadpool(MemorySegment ctx, MemorySegment threadpool, MemorySegment threadpool_batch) {
        var mh$ = llama_attach_threadpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_attach_threadpool", ctx, threadpool, threadpool_batch);
            }
            mh$.invokeExact(ctx, threadpool, threadpool_batch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_detach_threadpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_detach_threadpool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_detach_threadpool(struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_detach_threadpool$descriptor() {
        return llama_detach_threadpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_detach_threadpool(struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_detach_threadpool$handle() {
        return llama_detach_threadpool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_detach_threadpool(struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_detach_threadpool$address() {
        return llama_detach_threadpool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_detach_threadpool(struct llama_context *ctx)
     * }
     */
    public static void llama_detach_threadpool(MemorySegment ctx) {
        var mh$ = llama_detach_threadpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_detach_threadpool", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_load_model_from_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_model_params.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_load_model_from_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_model *llama_load_model_from_file(const char *path_model, struct llama_model_params params)
     * }
     */
    public static FunctionDescriptor llama_load_model_from_file$descriptor() {
        return llama_load_model_from_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_model *llama_load_model_from_file(const char *path_model, struct llama_model_params params)
     * }
     */
    public static MethodHandle llama_load_model_from_file$handle() {
        return llama_load_model_from_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_model *llama_load_model_from_file(const char *path_model, struct llama_model_params params)
     * }
     */
    public static MemorySegment llama_load_model_from_file$address() {
        return llama_load_model_from_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_model *llama_load_model_from_file(const char *path_model, struct llama_model_params params)
     * }
     */
    public static MemorySegment llama_load_model_from_file(MemorySegment path_model, MemorySegment params) {
        var mh$ = llama_load_model_from_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_load_model_from_file", path_model, params);
            }
            return (MemorySegment)mh$.invokeExact(path_model, params);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_load_from_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_model_params.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_load_from_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_model *llama_model_load_from_file(const char *path_model, struct llama_model_params params)
     * }
     */
    public static FunctionDescriptor llama_model_load_from_file$descriptor() {
        return llama_model_load_from_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_model *llama_model_load_from_file(const char *path_model, struct llama_model_params params)
     * }
     */
    public static MethodHandle llama_model_load_from_file$handle() {
        return llama_model_load_from_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_model *llama_model_load_from_file(const char *path_model, struct llama_model_params params)
     * }
     */
    public static MemorySegment llama_model_load_from_file$address() {
        return llama_model_load_from_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_model *llama_model_load_from_file(const char *path_model, struct llama_model_params params)
     * }
     */
    public static MemorySegment llama_model_load_from_file(MemorySegment path_model, MemorySegment params) {
        var mh$ = llama_model_load_from_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_load_from_file", path_model, params);
            }
            return (MemorySegment)mh$.invokeExact(path_model, params);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_load_from_splits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_model_params.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_load_from_splits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_model *llama_model_load_from_splits(const char **paths, size_t n_paths, struct llama_model_params params)
     * }
     */
    public static FunctionDescriptor llama_model_load_from_splits$descriptor() {
        return llama_model_load_from_splits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_model *llama_model_load_from_splits(const char **paths, size_t n_paths, struct llama_model_params params)
     * }
     */
    public static MethodHandle llama_model_load_from_splits$handle() {
        return llama_model_load_from_splits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_model *llama_model_load_from_splits(const char **paths, size_t n_paths, struct llama_model_params params)
     * }
     */
    public static MemorySegment llama_model_load_from_splits$address() {
        return llama_model_load_from_splits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_model *llama_model_load_from_splits(const char **paths, size_t n_paths, struct llama_model_params params)
     * }
     */
    public static MemorySegment llama_model_load_from_splits(MemorySegment paths, long n_paths, MemorySegment params) {
        var mh$ = llama_model_load_from_splits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_load_from_splits", paths, n_paths, params);
            }
            return (MemorySegment)mh$.invokeExact(paths, n_paths, params);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_save_to_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_save_to_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_model_save_to_file(const struct llama_model *model, const char *path_model)
     * }
     */
    public static FunctionDescriptor llama_model_save_to_file$descriptor() {
        return llama_model_save_to_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_model_save_to_file(const struct llama_model *model, const char *path_model)
     * }
     */
    public static MethodHandle llama_model_save_to_file$handle() {
        return llama_model_save_to_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_model_save_to_file(const struct llama_model *model, const char *path_model)
     * }
     */
    public static MemorySegment llama_model_save_to_file$address() {
        return llama_model_save_to_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_model_save_to_file(const struct llama_model *model, const char *path_model)
     * }
     */
    public static void llama_model_save_to_file(MemorySegment model, MemorySegment path_model) {
        var mh$ = llama_model_save_to_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_save_to_file", model, path_model);
            }
            mh$.invokeExact(model, path_model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_free_model {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_free_model");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_free_model(struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_free_model$descriptor() {
        return llama_free_model.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_free_model(struct llama_model *model)
     * }
     */
    public static MethodHandle llama_free_model$handle() {
        return llama_free_model.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_free_model(struct llama_model *model)
     * }
     */
    public static MemorySegment llama_free_model$address() {
        return llama_free_model.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_free_model(struct llama_model *model)
     * }
     */
    public static void llama_free_model(MemorySegment model) {
        var mh$ = llama_free_model.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_free_model", model);
            }
            mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_model_free(struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_model_free$descriptor() {
        return llama_model_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_model_free(struct llama_model *model)
     * }
     */
    public static MethodHandle llama_model_free$handle() {
        return llama_model_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_model_free(struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_free$address() {
        return llama_model_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_model_free(struct llama_model *model)
     * }
     */
    public static void llama_model_free(MemorySegment model) {
        var mh$ = llama_model_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_free", model);
            }
            mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_init_from_model {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_context_params.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_init_from_model");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_context *llama_init_from_model(struct llama_model *model, struct llama_context_params params)
     * }
     */
    public static FunctionDescriptor llama_init_from_model$descriptor() {
        return llama_init_from_model.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_context *llama_init_from_model(struct llama_model *model, struct llama_context_params params)
     * }
     */
    public static MethodHandle llama_init_from_model$handle() {
        return llama_init_from_model.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_context *llama_init_from_model(struct llama_model *model, struct llama_context_params params)
     * }
     */
    public static MemorySegment llama_init_from_model$address() {
        return llama_init_from_model.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_context *llama_init_from_model(struct llama_model *model, struct llama_context_params params)
     * }
     */
    public static MemorySegment llama_init_from_model(MemorySegment model, MemorySegment params) {
        var mh$ = llama_init_from_model.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_init_from_model", model, params);
            }
            return (MemorySegment)mh$.invokeExact(model, params);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_new_context_with_model {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_context_params.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_new_context_with_model");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_context *llama_new_context_with_model(struct llama_model *model, struct llama_context_params params)
     * }
     */
    public static FunctionDescriptor llama_new_context_with_model$descriptor() {
        return llama_new_context_with_model.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_context *llama_new_context_with_model(struct llama_model *model, struct llama_context_params params)
     * }
     */
    public static MethodHandle llama_new_context_with_model$handle() {
        return llama_new_context_with_model.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_context *llama_new_context_with_model(struct llama_model *model, struct llama_context_params params)
     * }
     */
    public static MemorySegment llama_new_context_with_model$address() {
        return llama_new_context_with_model.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_context *llama_new_context_with_model(struct llama_model *model, struct llama_context_params params)
     * }
     */
    public static MemorySegment llama_new_context_with_model(MemorySegment model, MemorySegment params) {
        var mh$ = llama_new_context_with_model.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_new_context_with_model", model, params);
            }
            return (MemorySegment)mh$.invokeExact(model, params);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_free(struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_free$descriptor() {
        return llama_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_free(struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_free$handle() {
        return llama_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_free(struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_free$address() {
        return llama_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_free(struct llama_context *ctx)
     * }
     */
    public static void llama_free(MemorySegment ctx) {
        var mh$ = llama_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_free", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_time_us {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_time_us");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t llama_time_us(void)
     * }
     */
    public static FunctionDescriptor llama_time_us$descriptor() {
        return llama_time_us.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t llama_time_us(void)
     * }
     */
    public static MethodHandle llama_time_us$handle() {
        return llama_time_us.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t llama_time_us(void)
     * }
     */
    public static MemorySegment llama_time_us$address() {
        return llama_time_us.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t llama_time_us(void)
     * }
     */
    public static long llama_time_us() {
        var mh$ = llama_time_us.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_time_us");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_max_devices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_max_devices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t llama_max_devices(void)
     * }
     */
    public static FunctionDescriptor llama_max_devices$descriptor() {
        return llama_max_devices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t llama_max_devices(void)
     * }
     */
    public static MethodHandle llama_max_devices$handle() {
        return llama_max_devices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t llama_max_devices(void)
     * }
     */
    public static MemorySegment llama_max_devices$address() {
        return llama_max_devices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t llama_max_devices(void)
     * }
     */
    public static long llama_max_devices() {
        var mh$ = llama_max_devices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_max_devices");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_max_parallel_sequences {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_max_parallel_sequences");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t llama_max_parallel_sequences(void)
     * }
     */
    public static FunctionDescriptor llama_max_parallel_sequences$descriptor() {
        return llama_max_parallel_sequences.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t llama_max_parallel_sequences(void)
     * }
     */
    public static MethodHandle llama_max_parallel_sequences$handle() {
        return llama_max_parallel_sequences.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t llama_max_parallel_sequences(void)
     * }
     */
    public static MemorySegment llama_max_parallel_sequences$address() {
        return llama_max_parallel_sequences.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t llama_max_parallel_sequences(void)
     * }
     */
    public static long llama_max_parallel_sequences() {
        var mh$ = llama_max_parallel_sequences.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_max_parallel_sequences");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_supports_mmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_supports_mmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_supports_mmap(void)
     * }
     */
    public static FunctionDescriptor llama_supports_mmap$descriptor() {
        return llama_supports_mmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_supports_mmap(void)
     * }
     */
    public static MethodHandle llama_supports_mmap$handle() {
        return llama_supports_mmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_supports_mmap(void)
     * }
     */
    public static MemorySegment llama_supports_mmap$address() {
        return llama_supports_mmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_supports_mmap(void)
     * }
     */
    public static boolean llama_supports_mmap() {
        var mh$ = llama_supports_mmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_supports_mmap");
            }
            return (boolean)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_supports_mlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_supports_mlock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_supports_mlock(void)
     * }
     */
    public static FunctionDescriptor llama_supports_mlock$descriptor() {
        return llama_supports_mlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_supports_mlock(void)
     * }
     */
    public static MethodHandle llama_supports_mlock$handle() {
        return llama_supports_mlock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_supports_mlock(void)
     * }
     */
    public static MemorySegment llama_supports_mlock$address() {
        return llama_supports_mlock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_supports_mlock(void)
     * }
     */
    public static boolean llama_supports_mlock() {
        var mh$ = llama_supports_mlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_supports_mlock");
            }
            return (boolean)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_supports_gpu_offload {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_supports_gpu_offload");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_supports_gpu_offload(void)
     * }
     */
    public static FunctionDescriptor llama_supports_gpu_offload$descriptor() {
        return llama_supports_gpu_offload.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_supports_gpu_offload(void)
     * }
     */
    public static MethodHandle llama_supports_gpu_offload$handle() {
        return llama_supports_gpu_offload.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_supports_gpu_offload(void)
     * }
     */
    public static MemorySegment llama_supports_gpu_offload$address() {
        return llama_supports_gpu_offload.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_supports_gpu_offload(void)
     * }
     */
    public static boolean llama_supports_gpu_offload() {
        var mh$ = llama_supports_gpu_offload.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_supports_gpu_offload");
            }
            return (boolean)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_supports_rpc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_supports_rpc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_supports_rpc(void)
     * }
     */
    public static FunctionDescriptor llama_supports_rpc$descriptor() {
        return llama_supports_rpc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_supports_rpc(void)
     * }
     */
    public static MethodHandle llama_supports_rpc$handle() {
        return llama_supports_rpc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_supports_rpc(void)
     * }
     */
    public static MemorySegment llama_supports_rpc$address() {
        return llama_supports_rpc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_supports_rpc(void)
     * }
     */
    public static boolean llama_supports_rpc() {
        var mh$ = llama_supports_rpc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_supports_rpc");
            }
            return (boolean)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_n_ctx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_n_ctx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t llama_n_ctx(const struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_n_ctx$descriptor() {
        return llama_n_ctx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t llama_n_ctx(const struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_n_ctx$handle() {
        return llama_n_ctx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t llama_n_ctx(const struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_n_ctx$address() {
        return llama_n_ctx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t llama_n_ctx(const struct llama_context *ctx)
     * }
     */
    public static int llama_n_ctx(MemorySegment ctx) {
        var mh$ = llama_n_ctx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_n_ctx", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_n_batch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_n_batch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t llama_n_batch(const struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_n_batch$descriptor() {
        return llama_n_batch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t llama_n_batch(const struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_n_batch$handle() {
        return llama_n_batch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t llama_n_batch(const struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_n_batch$address() {
        return llama_n_batch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t llama_n_batch(const struct llama_context *ctx)
     * }
     */
    public static int llama_n_batch(MemorySegment ctx) {
        var mh$ = llama_n_batch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_n_batch", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_n_ubatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_n_ubatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t llama_n_ubatch(const struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_n_ubatch$descriptor() {
        return llama_n_ubatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t llama_n_ubatch(const struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_n_ubatch$handle() {
        return llama_n_ubatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t llama_n_ubatch(const struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_n_ubatch$address() {
        return llama_n_ubatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t llama_n_ubatch(const struct llama_context *ctx)
     * }
     */
    public static int llama_n_ubatch(MemorySegment ctx) {
        var mh$ = llama_n_ubatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_n_ubatch", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_n_seq_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_n_seq_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t llama_n_seq_max(const struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_n_seq_max$descriptor() {
        return llama_n_seq_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t llama_n_seq_max(const struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_n_seq_max$handle() {
        return llama_n_seq_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t llama_n_seq_max(const struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_n_seq_max$address() {
        return llama_n_seq_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t llama_n_seq_max(const struct llama_context *ctx)
     * }
     */
    public static int llama_n_seq_max(MemorySegment ctx) {
        var mh$ = llama_n_seq_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_n_seq_max", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_n_ctx_train {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_n_ctx_train");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_n_ctx_train(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_n_ctx_train$descriptor() {
        return llama_n_ctx_train.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_n_ctx_train(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_n_ctx_train$handle() {
        return llama_n_ctx_train.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_n_ctx_train(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_n_ctx_train$address() {
        return llama_n_ctx_train.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_n_ctx_train(const struct llama_model *model)
     * }
     */
    public static int llama_n_ctx_train(MemorySegment model) {
        var mh$ = llama_n_ctx_train.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_n_ctx_train", model);
            }
            return (int)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_n_embd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_n_embd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_n_embd(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_n_embd$descriptor() {
        return llama_n_embd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_n_embd(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_n_embd$handle() {
        return llama_n_embd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_n_embd(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_n_embd$address() {
        return llama_n_embd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_n_embd(const struct llama_model *model)
     * }
     */
    public static int llama_n_embd(MemorySegment model) {
        var mh$ = llama_n_embd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_n_embd", model);
            }
            return (int)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_n_layer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_n_layer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_n_layer(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_n_layer$descriptor() {
        return llama_n_layer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_n_layer(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_n_layer$handle() {
        return llama_n_layer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_n_layer(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_n_layer$address() {
        return llama_n_layer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_n_layer(const struct llama_model *model)
     * }
     */
    public static int llama_n_layer(MemorySegment model) {
        var mh$ = llama_n_layer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_n_layer", model);
            }
            return (int)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_n_head {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_n_head");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_n_head(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_n_head$descriptor() {
        return llama_n_head.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_n_head(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_n_head$handle() {
        return llama_n_head.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_n_head(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_n_head$address() {
        return llama_n_head.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_n_head(const struct llama_model *model)
     * }
     */
    public static int llama_n_head(MemorySegment model) {
        var mh$ = llama_n_head.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_n_head", model);
            }
            return (int)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_n_vocab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_n_vocab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_n_vocab(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_n_vocab$descriptor() {
        return llama_n_vocab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_n_vocab(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_n_vocab$handle() {
        return llama_n_vocab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_n_vocab(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_n_vocab$address() {
        return llama_n_vocab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_n_vocab(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_n_vocab(MemorySegment vocab) {
        var mh$ = llama_n_vocab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_n_vocab", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_get_model {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_get_model");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct llama_model *llama_get_model(const struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_get_model$descriptor() {
        return llama_get_model.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct llama_model *llama_get_model(const struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_get_model$handle() {
        return llama_get_model.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct llama_model *llama_get_model(const struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_get_model$address() {
        return llama_get_model.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct llama_model *llama_get_model(const struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_get_model(MemorySegment ctx) {
        var mh$ = llama_get_model.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_get_model", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_get_memory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_get_memory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_memory_t llama_get_memory(const struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_get_memory$descriptor() {
        return llama_get_memory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_memory_t llama_get_memory(const struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_get_memory$handle() {
        return llama_get_memory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_memory_t llama_get_memory(const struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_get_memory$address() {
        return llama_get_memory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_memory_t llama_get_memory(const struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_get_memory(MemorySegment ctx) {
        var mh$ = llama_get_memory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_get_memory", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_pooling_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_pooling_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum llama_pooling_type llama_pooling_type(const struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_pooling_type$descriptor() {
        return llama_pooling_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum llama_pooling_type llama_pooling_type(const struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_pooling_type$handle() {
        return llama_pooling_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum llama_pooling_type llama_pooling_type(const struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_pooling_type$address() {
        return llama_pooling_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum llama_pooling_type llama_pooling_type(const struct llama_context *ctx)
     * }
     */
    public static int llama_pooling_type(MemorySegment ctx) {
        var mh$ = llama_pooling_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_pooling_type", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_get_kv_self {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_get_kv_self");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_kv_cache *llama_get_kv_self(struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_get_kv_self$descriptor() {
        return llama_get_kv_self.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_kv_cache *llama_get_kv_self(struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_get_kv_self$handle() {
        return llama_get_kv_self.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_kv_cache *llama_get_kv_self(struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_get_kv_self$address() {
        return llama_get_kv_self.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_kv_cache *llama_get_kv_self(struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_get_kv_self(MemorySegment ctx) {
        var mh$ = llama_get_kv_self.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_get_kv_self", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_get_vocab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_get_vocab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct llama_vocab *llama_model_get_vocab(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_model_get_vocab$descriptor() {
        return llama_model_get_vocab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct llama_vocab *llama_model_get_vocab(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_model_get_vocab$handle() {
        return llama_model_get_vocab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct llama_vocab *llama_model_get_vocab(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_get_vocab$address() {
        return llama_model_get_vocab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct llama_vocab *llama_model_get_vocab(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_get_vocab(MemorySegment model) {
        var mh$ = llama_model_get_vocab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_get_vocab", model);
            }
            return (MemorySegment)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_rope_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_rope_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum llama_rope_type llama_model_rope_type(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_model_rope_type$descriptor() {
        return llama_model_rope_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum llama_rope_type llama_model_rope_type(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_model_rope_type$handle() {
        return llama_model_rope_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum llama_rope_type llama_model_rope_type(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_rope_type$address() {
        return llama_model_rope_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum llama_rope_type llama_model_rope_type(const struct llama_model *model)
     * }
     */
    public static int llama_model_rope_type(MemorySegment model) {
        var mh$ = llama_model_rope_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_rope_type", model);
            }
            return (int)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_n_ctx_train {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_n_ctx_train");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_model_n_ctx_train(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_model_n_ctx_train$descriptor() {
        return llama_model_n_ctx_train.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_model_n_ctx_train(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_model_n_ctx_train$handle() {
        return llama_model_n_ctx_train.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_model_n_ctx_train(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_n_ctx_train$address() {
        return llama_model_n_ctx_train.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_model_n_ctx_train(const struct llama_model *model)
     * }
     */
    public static int llama_model_n_ctx_train(MemorySegment model) {
        var mh$ = llama_model_n_ctx_train.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_n_ctx_train", model);
            }
            return (int)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_n_embd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_n_embd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_model_n_embd(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_model_n_embd$descriptor() {
        return llama_model_n_embd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_model_n_embd(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_model_n_embd$handle() {
        return llama_model_n_embd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_model_n_embd(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_n_embd$address() {
        return llama_model_n_embd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_model_n_embd(const struct llama_model *model)
     * }
     */
    public static int llama_model_n_embd(MemorySegment model) {
        var mh$ = llama_model_n_embd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_n_embd", model);
            }
            return (int)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_n_layer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_n_layer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_model_n_layer(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_model_n_layer$descriptor() {
        return llama_model_n_layer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_model_n_layer(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_model_n_layer$handle() {
        return llama_model_n_layer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_model_n_layer(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_n_layer$address() {
        return llama_model_n_layer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_model_n_layer(const struct llama_model *model)
     * }
     */
    public static int llama_model_n_layer(MemorySegment model) {
        var mh$ = llama_model_n_layer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_n_layer", model);
            }
            return (int)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_n_head {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_n_head");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_model_n_head(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_model_n_head$descriptor() {
        return llama_model_n_head.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_model_n_head(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_model_n_head$handle() {
        return llama_model_n_head.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_model_n_head(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_n_head$address() {
        return llama_model_n_head.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_model_n_head(const struct llama_model *model)
     * }
     */
    public static int llama_model_n_head(MemorySegment model) {
        var mh$ = llama_model_n_head.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_n_head", model);
            }
            return (int)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_n_head_kv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_n_head_kv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_model_n_head_kv(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_model_n_head_kv$descriptor() {
        return llama_model_n_head_kv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_model_n_head_kv(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_model_n_head_kv$handle() {
        return llama_model_n_head_kv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_model_n_head_kv(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_n_head_kv$address() {
        return llama_model_n_head_kv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_model_n_head_kv(const struct llama_model *model)
     * }
     */
    public static int llama_model_n_head_kv(MemorySegment model) {
        var mh$ = llama_model_n_head_kv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_n_head_kv", model);
            }
            return (int)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_n_swa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_n_swa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_model_n_swa(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_model_n_swa$descriptor() {
        return llama_model_n_swa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_model_n_swa(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_model_n_swa$handle() {
        return llama_model_n_swa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_model_n_swa(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_n_swa$address() {
        return llama_model_n_swa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_model_n_swa(const struct llama_model *model)
     * }
     */
    public static int llama_model_n_swa(MemorySegment model) {
        var mh$ = llama_model_n_swa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_n_swa", model);
            }
            return (int)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_rope_freq_scale_train {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_FLOAT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_rope_freq_scale_train");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float llama_model_rope_freq_scale_train(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_model_rope_freq_scale_train$descriptor() {
        return llama_model_rope_freq_scale_train.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float llama_model_rope_freq_scale_train(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_model_rope_freq_scale_train$handle() {
        return llama_model_rope_freq_scale_train.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float llama_model_rope_freq_scale_train(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_rope_freq_scale_train$address() {
        return llama_model_rope_freq_scale_train.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float llama_model_rope_freq_scale_train(const struct llama_model *model)
     * }
     */
    public static float llama_model_rope_freq_scale_train(MemorySegment model) {
        var mh$ = llama_model_rope_freq_scale_train.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_rope_freq_scale_train", model);
            }
            return (float)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_n_cls_out {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_n_cls_out");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t llama_model_n_cls_out(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_model_n_cls_out$descriptor() {
        return llama_model_n_cls_out.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t llama_model_n_cls_out(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_model_n_cls_out$handle() {
        return llama_model_n_cls_out.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t llama_model_n_cls_out(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_n_cls_out$address() {
        return llama_model_n_cls_out.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t llama_model_n_cls_out(const struct llama_model *model)
     * }
     */
    public static int llama_model_n_cls_out(MemorySegment model) {
        var mh$ = llama_model_n_cls_out.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_n_cls_out", model);
            }
            return (int)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_cls_label {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_cls_label");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *llama_model_cls_label(const struct llama_model *model, uint32_t i)
     * }
     */
    public static FunctionDescriptor llama_model_cls_label$descriptor() {
        return llama_model_cls_label.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *llama_model_cls_label(const struct llama_model *model, uint32_t i)
     * }
     */
    public static MethodHandle llama_model_cls_label$handle() {
        return llama_model_cls_label.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *llama_model_cls_label(const struct llama_model *model, uint32_t i)
     * }
     */
    public static MemorySegment llama_model_cls_label$address() {
        return llama_model_cls_label.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *llama_model_cls_label(const struct llama_model *model, uint32_t i)
     * }
     */
    public static MemorySegment llama_model_cls_label(MemorySegment model, int i) {
        var mh$ = llama_model_cls_label.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_cls_label", model, i);
            }
            return (MemorySegment)mh$.invokeExact(model, i);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum llama_vocab_type llama_vocab_type(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_vocab_type$descriptor() {
        return llama_vocab_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum llama_vocab_type llama_vocab_type(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_vocab_type$handle() {
        return llama_vocab_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum llama_vocab_type llama_vocab_type(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_vocab_type$address() {
        return llama_vocab_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum llama_vocab_type llama_vocab_type(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_vocab_type(MemorySegment vocab) {
        var mh$ = llama_vocab_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_type", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_n_tokens {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_n_tokens");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_vocab_n_tokens(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_vocab_n_tokens$descriptor() {
        return llama_vocab_n_tokens.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_vocab_n_tokens(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_vocab_n_tokens$handle() {
        return llama_vocab_n_tokens.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_vocab_n_tokens(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_vocab_n_tokens$address() {
        return llama_vocab_n_tokens.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_vocab_n_tokens(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_vocab_n_tokens(MemorySegment vocab) {
        var mh$ = llama_vocab_n_tokens.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_n_tokens", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_meta_val_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_meta_val_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_model_meta_val_str(const struct llama_model *model, const char *key, char *buf, size_t buf_size)
     * }
     */
    public static FunctionDescriptor llama_model_meta_val_str$descriptor() {
        return llama_model_meta_val_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_model_meta_val_str(const struct llama_model *model, const char *key, char *buf, size_t buf_size)
     * }
     */
    public static MethodHandle llama_model_meta_val_str$handle() {
        return llama_model_meta_val_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_model_meta_val_str(const struct llama_model *model, const char *key, char *buf, size_t buf_size)
     * }
     */
    public static MemorySegment llama_model_meta_val_str$address() {
        return llama_model_meta_val_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_model_meta_val_str(const struct llama_model *model, const char *key, char *buf, size_t buf_size)
     * }
     */
    public static int llama_model_meta_val_str(MemorySegment model, MemorySegment key, MemorySegment buf, long buf_size) {
        var mh$ = llama_model_meta_val_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_meta_val_str", model, key, buf, buf_size);
            }
            return (int)mh$.invokeExact(model, key, buf, buf_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_meta_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_meta_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_model_meta_count(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_model_meta_count$descriptor() {
        return llama_model_meta_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_model_meta_count(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_model_meta_count$handle() {
        return llama_model_meta_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_model_meta_count(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_meta_count$address() {
        return llama_model_meta_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_model_meta_count(const struct llama_model *model)
     * }
     */
    public static int llama_model_meta_count(MemorySegment model) {
        var mh$ = llama_model_meta_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_meta_count", model);
            }
            return (int)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_meta_key_by_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_meta_key_by_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_model_meta_key_by_index(const struct llama_model *model, int32_t i, char *buf, size_t buf_size)
     * }
     */
    public static FunctionDescriptor llama_model_meta_key_by_index$descriptor() {
        return llama_model_meta_key_by_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_model_meta_key_by_index(const struct llama_model *model, int32_t i, char *buf, size_t buf_size)
     * }
     */
    public static MethodHandle llama_model_meta_key_by_index$handle() {
        return llama_model_meta_key_by_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_model_meta_key_by_index(const struct llama_model *model, int32_t i, char *buf, size_t buf_size)
     * }
     */
    public static MemorySegment llama_model_meta_key_by_index$address() {
        return llama_model_meta_key_by_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_model_meta_key_by_index(const struct llama_model *model, int32_t i, char *buf, size_t buf_size)
     * }
     */
    public static int llama_model_meta_key_by_index(MemorySegment model, int i, MemorySegment buf, long buf_size) {
        var mh$ = llama_model_meta_key_by_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_meta_key_by_index", model, i, buf, buf_size);
            }
            return (int)mh$.invokeExact(model, i, buf, buf_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_meta_val_str_by_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_meta_val_str_by_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_model_meta_val_str_by_index(const struct llama_model *model, int32_t i, char *buf, size_t buf_size)
     * }
     */
    public static FunctionDescriptor llama_model_meta_val_str_by_index$descriptor() {
        return llama_model_meta_val_str_by_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_model_meta_val_str_by_index(const struct llama_model *model, int32_t i, char *buf, size_t buf_size)
     * }
     */
    public static MethodHandle llama_model_meta_val_str_by_index$handle() {
        return llama_model_meta_val_str_by_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_model_meta_val_str_by_index(const struct llama_model *model, int32_t i, char *buf, size_t buf_size)
     * }
     */
    public static MemorySegment llama_model_meta_val_str_by_index$address() {
        return llama_model_meta_val_str_by_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_model_meta_val_str_by_index(const struct llama_model *model, int32_t i, char *buf, size_t buf_size)
     * }
     */
    public static int llama_model_meta_val_str_by_index(MemorySegment model, int i, MemorySegment buf, long buf_size) {
        var mh$ = llama_model_meta_val_str_by_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_meta_val_str_by_index", model, i, buf, buf_size);
            }
            return (int)mh$.invokeExact(model, i, buf, buf_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_desc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_desc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_model_desc(const struct llama_model *model, char *buf, size_t buf_size)
     * }
     */
    public static FunctionDescriptor llama_model_desc$descriptor() {
        return llama_model_desc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_model_desc(const struct llama_model *model, char *buf, size_t buf_size)
     * }
     */
    public static MethodHandle llama_model_desc$handle() {
        return llama_model_desc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_model_desc(const struct llama_model *model, char *buf, size_t buf_size)
     * }
     */
    public static MemorySegment llama_model_desc$address() {
        return llama_model_desc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_model_desc(const struct llama_model *model, char *buf, size_t buf_size)
     * }
     */
    public static int llama_model_desc(MemorySegment model, MemorySegment buf, long buf_size) {
        var mh$ = llama_model_desc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_desc", model, buf, buf_size);
            }
            return (int)mh$.invokeExact(model, buf, buf_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG_LONG,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t llama_model_size(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_model_size$descriptor() {
        return llama_model_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t llama_model_size(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_model_size$handle() {
        return llama_model_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t llama_model_size(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_size$address() {
        return llama_model_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t llama_model_size(const struct llama_model *model)
     * }
     */
    public static long llama_model_size(MemorySegment model) {
        var mh$ = llama_model_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_size", model);
            }
            return (long)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_chat_template {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_chat_template");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *llama_model_chat_template(const struct llama_model *model, const char *name)
     * }
     */
    public static FunctionDescriptor llama_model_chat_template$descriptor() {
        return llama_model_chat_template.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *llama_model_chat_template(const struct llama_model *model, const char *name)
     * }
     */
    public static MethodHandle llama_model_chat_template$handle() {
        return llama_model_chat_template.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *llama_model_chat_template(const struct llama_model *model, const char *name)
     * }
     */
    public static MemorySegment llama_model_chat_template$address() {
        return llama_model_chat_template.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *llama_model_chat_template(const struct llama_model *model, const char *name)
     * }
     */
    public static MemorySegment llama_model_chat_template(MemorySegment model, MemorySegment name) {
        var mh$ = llama_model_chat_template.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_chat_template", model, name);
            }
            return (MemorySegment)mh$.invokeExact(model, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_n_params {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG_LONG,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_n_params");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t llama_model_n_params(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_model_n_params$descriptor() {
        return llama_model_n_params.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t llama_model_n_params(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_model_n_params$handle() {
        return llama_model_n_params.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t llama_model_n_params(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_n_params$address() {
        return llama_model_n_params.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t llama_model_n_params(const struct llama_model *model)
     * }
     */
    public static long llama_model_n_params(MemorySegment model) {
        var mh$ = llama_model_n_params.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_n_params", model);
            }
            return (long)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_has_encoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_has_encoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_model_has_encoder(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_model_has_encoder$descriptor() {
        return llama_model_has_encoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_model_has_encoder(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_model_has_encoder$handle() {
        return llama_model_has_encoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_model_has_encoder(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_has_encoder$address() {
        return llama_model_has_encoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_model_has_encoder(const struct llama_model *model)
     * }
     */
    public static boolean llama_model_has_encoder(MemorySegment model) {
        var mh$ = llama_model_has_encoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_has_encoder", model);
            }
            return (boolean)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_has_decoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_has_decoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_model_has_decoder(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_model_has_decoder$descriptor() {
        return llama_model_has_decoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_model_has_decoder(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_model_has_decoder$handle() {
        return llama_model_has_decoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_model_has_decoder(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_has_decoder$address() {
        return llama_model_has_decoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_model_has_decoder(const struct llama_model *model)
     * }
     */
    public static boolean llama_model_has_decoder(MemorySegment model) {
        var mh$ = llama_model_has_decoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_has_decoder", model);
            }
            return (boolean)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_decoder_start_token {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_decoder_start_token");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_model_decoder_start_token(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_model_decoder_start_token$descriptor() {
        return llama_model_decoder_start_token.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_model_decoder_start_token(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_model_decoder_start_token$handle() {
        return llama_model_decoder_start_token.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_model_decoder_start_token(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_decoder_start_token$address() {
        return llama_model_decoder_start_token.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_model_decoder_start_token(const struct llama_model *model)
     * }
     */
    public static int llama_model_decoder_start_token(MemorySegment model) {
        var mh$ = llama_model_decoder_start_token.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_decoder_start_token", model);
            }
            return (int)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_is_recurrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_is_recurrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_model_is_recurrent(const struct llama_model *model)
     * }
     */
    public static FunctionDescriptor llama_model_is_recurrent$descriptor() {
        return llama_model_is_recurrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_model_is_recurrent(const struct llama_model *model)
     * }
     */
    public static MethodHandle llama_model_is_recurrent$handle() {
        return llama_model_is_recurrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_model_is_recurrent(const struct llama_model *model)
     * }
     */
    public static MemorySegment llama_model_is_recurrent$address() {
        return llama_model_is_recurrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_model_is_recurrent(const struct llama_model *model)
     * }
     */
    public static boolean llama_model_is_recurrent(MemorySegment model) {
        var mh$ = llama_model_is_recurrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_is_recurrent", model);
            }
            return (boolean)mh$.invokeExact(model);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_model_quantize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_model_quantize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t llama_model_quantize(const char *fname_inp, const char *fname_out, const llama_model_quantize_params *params)
     * }
     */
    public static FunctionDescriptor llama_model_quantize$descriptor() {
        return llama_model_quantize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t llama_model_quantize(const char *fname_inp, const char *fname_out, const llama_model_quantize_params *params)
     * }
     */
    public static MethodHandle llama_model_quantize$handle() {
        return llama_model_quantize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t llama_model_quantize(const char *fname_inp, const char *fname_out, const llama_model_quantize_params *params)
     * }
     */
    public static MemorySegment llama_model_quantize$address() {
        return llama_model_quantize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t llama_model_quantize(const char *fname_inp, const char *fname_out, const llama_model_quantize_params *params)
     * }
     */
    public static int llama_model_quantize(MemorySegment fname_inp, MemorySegment fname_out, MemorySegment params) {
        var mh$ = llama_model_quantize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_model_quantize", fname_inp, fname_out, params);
            }
            return (int)mh$.invokeExact(fname_inp, fname_out, params);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_adapter_lora_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_adapter_lora_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_adapter_lora *llama_adapter_lora_init(struct llama_model *model, const char *path_lora)
     * }
     */
    public static FunctionDescriptor llama_adapter_lora_init$descriptor() {
        return llama_adapter_lora_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_adapter_lora *llama_adapter_lora_init(struct llama_model *model, const char *path_lora)
     * }
     */
    public static MethodHandle llama_adapter_lora_init$handle() {
        return llama_adapter_lora_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_adapter_lora *llama_adapter_lora_init(struct llama_model *model, const char *path_lora)
     * }
     */
    public static MemorySegment llama_adapter_lora_init$address() {
        return llama_adapter_lora_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_adapter_lora *llama_adapter_lora_init(struct llama_model *model, const char *path_lora)
     * }
     */
    public static MemorySegment llama_adapter_lora_init(MemorySegment model, MemorySegment path_lora) {
        var mh$ = llama_adapter_lora_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_adapter_lora_init", model, path_lora);
            }
            return (MemorySegment)mh$.invokeExact(model, path_lora);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_adapter_lora_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_adapter_lora_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_adapter_lora_free(struct llama_adapter_lora *adapter)
     * }
     */
    public static FunctionDescriptor llama_adapter_lora_free$descriptor() {
        return llama_adapter_lora_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_adapter_lora_free(struct llama_adapter_lora *adapter)
     * }
     */
    public static MethodHandle llama_adapter_lora_free$handle() {
        return llama_adapter_lora_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_adapter_lora_free(struct llama_adapter_lora *adapter)
     * }
     */
    public static MemorySegment llama_adapter_lora_free$address() {
        return llama_adapter_lora_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_adapter_lora_free(struct llama_adapter_lora *adapter)
     * }
     */
    public static void llama_adapter_lora_free(MemorySegment adapter) {
        var mh$ = llama_adapter_lora_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_adapter_lora_free", adapter);
            }
            mh$.invokeExact(adapter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_set_adapter_lora {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_set_adapter_lora");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_set_adapter_lora(struct llama_context *ctx, struct llama_adapter_lora *adapter, float scale)
     * }
     */
    public static FunctionDescriptor llama_set_adapter_lora$descriptor() {
        return llama_set_adapter_lora.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_set_adapter_lora(struct llama_context *ctx, struct llama_adapter_lora *adapter, float scale)
     * }
     */
    public static MethodHandle llama_set_adapter_lora$handle() {
        return llama_set_adapter_lora.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_set_adapter_lora(struct llama_context *ctx, struct llama_adapter_lora *adapter, float scale)
     * }
     */
    public static MemorySegment llama_set_adapter_lora$address() {
        return llama_set_adapter_lora.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_set_adapter_lora(struct llama_context *ctx, struct llama_adapter_lora *adapter, float scale)
     * }
     */
    public static int llama_set_adapter_lora(MemorySegment ctx, MemorySegment adapter, float scale) {
        var mh$ = llama_set_adapter_lora.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_set_adapter_lora", ctx, adapter, scale);
            }
            return (int)mh$.invokeExact(ctx, adapter, scale);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_rm_adapter_lora {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_rm_adapter_lora");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_rm_adapter_lora(struct llama_context *ctx, struct llama_adapter_lora *adapter)
     * }
     */
    public static FunctionDescriptor llama_rm_adapter_lora$descriptor() {
        return llama_rm_adapter_lora.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_rm_adapter_lora(struct llama_context *ctx, struct llama_adapter_lora *adapter)
     * }
     */
    public static MethodHandle llama_rm_adapter_lora$handle() {
        return llama_rm_adapter_lora.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_rm_adapter_lora(struct llama_context *ctx, struct llama_adapter_lora *adapter)
     * }
     */
    public static MemorySegment llama_rm_adapter_lora$address() {
        return llama_rm_adapter_lora.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_rm_adapter_lora(struct llama_context *ctx, struct llama_adapter_lora *adapter)
     * }
     */
    public static int llama_rm_adapter_lora(MemorySegment ctx, MemorySegment adapter) {
        var mh$ = llama_rm_adapter_lora.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_rm_adapter_lora", ctx, adapter);
            }
            return (int)mh$.invokeExact(ctx, adapter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_clear_adapter_lora {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_clear_adapter_lora");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_clear_adapter_lora(struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_clear_adapter_lora$descriptor() {
        return llama_clear_adapter_lora.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_clear_adapter_lora(struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_clear_adapter_lora$handle() {
        return llama_clear_adapter_lora.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_clear_adapter_lora(struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_clear_adapter_lora$address() {
        return llama_clear_adapter_lora.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_clear_adapter_lora(struct llama_context *ctx)
     * }
     */
    public static void llama_clear_adapter_lora(MemorySegment ctx) {
        var mh$ = llama_clear_adapter_lora.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_clear_adapter_lora", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_apply_adapter_cvec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_apply_adapter_cvec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_apply_adapter_cvec(struct llama_context *ctx, const float *data, size_t len, int32_t n_embd, int32_t il_start, int32_t il_end)
     * }
     */
    public static FunctionDescriptor llama_apply_adapter_cvec$descriptor() {
        return llama_apply_adapter_cvec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_apply_adapter_cvec(struct llama_context *ctx, const float *data, size_t len, int32_t n_embd, int32_t il_start, int32_t il_end)
     * }
     */
    public static MethodHandle llama_apply_adapter_cvec$handle() {
        return llama_apply_adapter_cvec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_apply_adapter_cvec(struct llama_context *ctx, const float *data, size_t len, int32_t n_embd, int32_t il_start, int32_t il_end)
     * }
     */
    public static MemorySegment llama_apply_adapter_cvec$address() {
        return llama_apply_adapter_cvec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_apply_adapter_cvec(struct llama_context *ctx, const float *data, size_t len, int32_t n_embd, int32_t il_start, int32_t il_end)
     * }
     */
    public static int llama_apply_adapter_cvec(MemorySegment ctx, MemorySegment data, long len, int n_embd, int il_start, int il_end) {
        var mh$ = llama_apply_adapter_cvec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_apply_adapter_cvec", ctx, data, len, n_embd, il_start, il_end);
            }
            return (int)mh$.invokeExact(ctx, data, len, n_embd, il_start, il_end);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_memory_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_memory_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_memory_clear(llama_memory_t mem, bool data)
     * }
     */
    public static FunctionDescriptor llama_memory_clear$descriptor() {
        return llama_memory_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_memory_clear(llama_memory_t mem, bool data)
     * }
     */
    public static MethodHandle llama_memory_clear$handle() {
        return llama_memory_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_memory_clear(llama_memory_t mem, bool data)
     * }
     */
    public static MemorySegment llama_memory_clear$address() {
        return llama_memory_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_memory_clear(llama_memory_t mem, bool data)
     * }
     */
    public static void llama_memory_clear(MemorySegment mem, boolean data) {
        var mh$ = llama_memory_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_memory_clear", mem, data);
            }
            mh$.invokeExact(mem, data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_memory_seq_rm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_memory_seq_rm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_memory_seq_rm(llama_memory_t mem, llama_seq_id seq_id, llama_pos p0, llama_pos p1)
     * }
     */
    public static FunctionDescriptor llama_memory_seq_rm$descriptor() {
        return llama_memory_seq_rm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_memory_seq_rm(llama_memory_t mem, llama_seq_id seq_id, llama_pos p0, llama_pos p1)
     * }
     */
    public static MethodHandle llama_memory_seq_rm$handle() {
        return llama_memory_seq_rm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_memory_seq_rm(llama_memory_t mem, llama_seq_id seq_id, llama_pos p0, llama_pos p1)
     * }
     */
    public static MemorySegment llama_memory_seq_rm$address() {
        return llama_memory_seq_rm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_memory_seq_rm(llama_memory_t mem, llama_seq_id seq_id, llama_pos p0, llama_pos p1)
     * }
     */
    public static boolean llama_memory_seq_rm(MemorySegment mem, int seq_id, int p0, int p1) {
        var mh$ = llama_memory_seq_rm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_memory_seq_rm", mem, seq_id, p0, p1);
            }
            return (boolean)mh$.invokeExact(mem, seq_id, p0, p1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_memory_seq_cp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_memory_seq_cp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_memory_seq_cp(llama_memory_t mem, llama_seq_id seq_id_src, llama_seq_id seq_id_dst, llama_pos p0, llama_pos p1)
     * }
     */
    public static FunctionDescriptor llama_memory_seq_cp$descriptor() {
        return llama_memory_seq_cp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_memory_seq_cp(llama_memory_t mem, llama_seq_id seq_id_src, llama_seq_id seq_id_dst, llama_pos p0, llama_pos p1)
     * }
     */
    public static MethodHandle llama_memory_seq_cp$handle() {
        return llama_memory_seq_cp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_memory_seq_cp(llama_memory_t mem, llama_seq_id seq_id_src, llama_seq_id seq_id_dst, llama_pos p0, llama_pos p1)
     * }
     */
    public static MemorySegment llama_memory_seq_cp$address() {
        return llama_memory_seq_cp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_memory_seq_cp(llama_memory_t mem, llama_seq_id seq_id_src, llama_seq_id seq_id_dst, llama_pos p0, llama_pos p1)
     * }
     */
    public static void llama_memory_seq_cp(MemorySegment mem, int seq_id_src, int seq_id_dst, int p0, int p1) {
        var mh$ = llama_memory_seq_cp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_memory_seq_cp", mem, seq_id_src, seq_id_dst, p0, p1);
            }
            mh$.invokeExact(mem, seq_id_src, seq_id_dst, p0, p1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_memory_seq_keep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_memory_seq_keep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_memory_seq_keep(llama_memory_t mem, llama_seq_id seq_id)
     * }
     */
    public static FunctionDescriptor llama_memory_seq_keep$descriptor() {
        return llama_memory_seq_keep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_memory_seq_keep(llama_memory_t mem, llama_seq_id seq_id)
     * }
     */
    public static MethodHandle llama_memory_seq_keep$handle() {
        return llama_memory_seq_keep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_memory_seq_keep(llama_memory_t mem, llama_seq_id seq_id)
     * }
     */
    public static MemorySegment llama_memory_seq_keep$address() {
        return llama_memory_seq_keep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_memory_seq_keep(llama_memory_t mem, llama_seq_id seq_id)
     * }
     */
    public static void llama_memory_seq_keep(MemorySegment mem, int seq_id) {
        var mh$ = llama_memory_seq_keep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_memory_seq_keep", mem, seq_id);
            }
            mh$.invokeExact(mem, seq_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_memory_seq_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_memory_seq_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_memory_seq_add(llama_memory_t mem, llama_seq_id seq_id, llama_pos p0, llama_pos p1, llama_pos delta)
     * }
     */
    public static FunctionDescriptor llama_memory_seq_add$descriptor() {
        return llama_memory_seq_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_memory_seq_add(llama_memory_t mem, llama_seq_id seq_id, llama_pos p0, llama_pos p1, llama_pos delta)
     * }
     */
    public static MethodHandle llama_memory_seq_add$handle() {
        return llama_memory_seq_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_memory_seq_add(llama_memory_t mem, llama_seq_id seq_id, llama_pos p0, llama_pos p1, llama_pos delta)
     * }
     */
    public static MemorySegment llama_memory_seq_add$address() {
        return llama_memory_seq_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_memory_seq_add(llama_memory_t mem, llama_seq_id seq_id, llama_pos p0, llama_pos p1, llama_pos delta)
     * }
     */
    public static void llama_memory_seq_add(MemorySegment mem, int seq_id, int p0, int p1, int delta) {
        var mh$ = llama_memory_seq_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_memory_seq_add", mem, seq_id, p0, p1, delta);
            }
            mh$.invokeExact(mem, seq_id, p0, p1, delta);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_memory_seq_div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_memory_seq_div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_memory_seq_div(llama_memory_t mem, llama_seq_id seq_id, llama_pos p0, llama_pos p1, int d)
     * }
     */
    public static FunctionDescriptor llama_memory_seq_div$descriptor() {
        return llama_memory_seq_div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_memory_seq_div(llama_memory_t mem, llama_seq_id seq_id, llama_pos p0, llama_pos p1, int d)
     * }
     */
    public static MethodHandle llama_memory_seq_div$handle() {
        return llama_memory_seq_div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_memory_seq_div(llama_memory_t mem, llama_seq_id seq_id, llama_pos p0, llama_pos p1, int d)
     * }
     */
    public static MemorySegment llama_memory_seq_div$address() {
        return llama_memory_seq_div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_memory_seq_div(llama_memory_t mem, llama_seq_id seq_id, llama_pos p0, llama_pos p1, int d)
     * }
     */
    public static void llama_memory_seq_div(MemorySegment mem, int seq_id, int p0, int p1, int d) {
        var mh$ = llama_memory_seq_div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_memory_seq_div", mem, seq_id, p0, p1, d);
            }
            mh$.invokeExact(mem, seq_id, p0, p1, d);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_memory_seq_pos_min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_memory_seq_pos_min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_pos llama_memory_seq_pos_min(llama_memory_t mem, llama_seq_id seq_id)
     * }
     */
    public static FunctionDescriptor llama_memory_seq_pos_min$descriptor() {
        return llama_memory_seq_pos_min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_pos llama_memory_seq_pos_min(llama_memory_t mem, llama_seq_id seq_id)
     * }
     */
    public static MethodHandle llama_memory_seq_pos_min$handle() {
        return llama_memory_seq_pos_min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_pos llama_memory_seq_pos_min(llama_memory_t mem, llama_seq_id seq_id)
     * }
     */
    public static MemorySegment llama_memory_seq_pos_min$address() {
        return llama_memory_seq_pos_min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_pos llama_memory_seq_pos_min(llama_memory_t mem, llama_seq_id seq_id)
     * }
     */
    public static int llama_memory_seq_pos_min(MemorySegment mem, int seq_id) {
        var mh$ = llama_memory_seq_pos_min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_memory_seq_pos_min", mem, seq_id);
            }
            return (int)mh$.invokeExact(mem, seq_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_memory_seq_pos_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_memory_seq_pos_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_pos llama_memory_seq_pos_max(llama_memory_t mem, llama_seq_id seq_id)
     * }
     */
    public static FunctionDescriptor llama_memory_seq_pos_max$descriptor() {
        return llama_memory_seq_pos_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_pos llama_memory_seq_pos_max(llama_memory_t mem, llama_seq_id seq_id)
     * }
     */
    public static MethodHandle llama_memory_seq_pos_max$handle() {
        return llama_memory_seq_pos_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_pos llama_memory_seq_pos_max(llama_memory_t mem, llama_seq_id seq_id)
     * }
     */
    public static MemorySegment llama_memory_seq_pos_max$address() {
        return llama_memory_seq_pos_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_pos llama_memory_seq_pos_max(llama_memory_t mem, llama_seq_id seq_id)
     * }
     */
    public static int llama_memory_seq_pos_max(MemorySegment mem, int seq_id) {
        var mh$ = llama_memory_seq_pos_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_memory_seq_pos_max", mem, seq_id);
            }
            return (int)mh$.invokeExact(mem, seq_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_memory_can_shift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_memory_can_shift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_memory_can_shift(llama_memory_t mem)
     * }
     */
    public static FunctionDescriptor llama_memory_can_shift$descriptor() {
        return llama_memory_can_shift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_memory_can_shift(llama_memory_t mem)
     * }
     */
    public static MethodHandle llama_memory_can_shift$handle() {
        return llama_memory_can_shift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_memory_can_shift(llama_memory_t mem)
     * }
     */
    public static MemorySegment llama_memory_can_shift$address() {
        return llama_memory_can_shift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_memory_can_shift(llama_memory_t mem)
     * }
     */
    public static boolean llama_memory_can_shift(MemorySegment mem) {
        var mh$ = llama_memory_can_shift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_memory_can_shift", mem);
            }
            return (boolean)mh$.invokeExact(mem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_kv_self_n_tokens {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_kv_self_n_tokens");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_kv_self_n_tokens(const struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_kv_self_n_tokens$descriptor() {
        return llama_kv_self_n_tokens.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_kv_self_n_tokens(const struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_kv_self_n_tokens$handle() {
        return llama_kv_self_n_tokens.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_kv_self_n_tokens(const struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_kv_self_n_tokens$address() {
        return llama_kv_self_n_tokens.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_kv_self_n_tokens(const struct llama_context *ctx)
     * }
     */
    public static int llama_kv_self_n_tokens(MemorySegment ctx) {
        var mh$ = llama_kv_self_n_tokens.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_kv_self_n_tokens", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_kv_self_used_cells {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_kv_self_used_cells");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_kv_self_used_cells(const struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_kv_self_used_cells$descriptor() {
        return llama_kv_self_used_cells.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_kv_self_used_cells(const struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_kv_self_used_cells$handle() {
        return llama_kv_self_used_cells.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_kv_self_used_cells(const struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_kv_self_used_cells$address() {
        return llama_kv_self_used_cells.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_kv_self_used_cells(const struct llama_context *ctx)
     * }
     */
    public static int llama_kv_self_used_cells(MemorySegment ctx) {
        var mh$ = llama_kv_self_used_cells.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_kv_self_used_cells", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_kv_self_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_kv_self_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_kv_self_clear(struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_kv_self_clear$descriptor() {
        return llama_kv_self_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_kv_self_clear(struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_kv_self_clear$handle() {
        return llama_kv_self_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_kv_self_clear(struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_kv_self_clear$address() {
        return llama_kv_self_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_kv_self_clear(struct llama_context *ctx)
     * }
     */
    public static void llama_kv_self_clear(MemorySegment ctx) {
        var mh$ = llama_kv_self_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_kv_self_clear", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_kv_self_seq_rm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_kv_self_seq_rm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_kv_self_seq_rm(struct llama_context *ctx, llama_seq_id seq_id, llama_pos p0, llama_pos p1)
     * }
     */
    public static FunctionDescriptor llama_kv_self_seq_rm$descriptor() {
        return llama_kv_self_seq_rm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_kv_self_seq_rm(struct llama_context *ctx, llama_seq_id seq_id, llama_pos p0, llama_pos p1)
     * }
     */
    public static MethodHandle llama_kv_self_seq_rm$handle() {
        return llama_kv_self_seq_rm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_kv_self_seq_rm(struct llama_context *ctx, llama_seq_id seq_id, llama_pos p0, llama_pos p1)
     * }
     */
    public static MemorySegment llama_kv_self_seq_rm$address() {
        return llama_kv_self_seq_rm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_kv_self_seq_rm(struct llama_context *ctx, llama_seq_id seq_id, llama_pos p0, llama_pos p1)
     * }
     */
    public static boolean llama_kv_self_seq_rm(MemorySegment ctx, int seq_id, int p0, int p1) {
        var mh$ = llama_kv_self_seq_rm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_kv_self_seq_rm", ctx, seq_id, p0, p1);
            }
            return (boolean)mh$.invokeExact(ctx, seq_id, p0, p1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_kv_self_seq_cp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_kv_self_seq_cp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_kv_self_seq_cp(struct llama_context *ctx, llama_seq_id seq_id_src, llama_seq_id seq_id_dst, llama_pos p0, llama_pos p1)
     * }
     */
    public static FunctionDescriptor llama_kv_self_seq_cp$descriptor() {
        return llama_kv_self_seq_cp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_kv_self_seq_cp(struct llama_context *ctx, llama_seq_id seq_id_src, llama_seq_id seq_id_dst, llama_pos p0, llama_pos p1)
     * }
     */
    public static MethodHandle llama_kv_self_seq_cp$handle() {
        return llama_kv_self_seq_cp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_kv_self_seq_cp(struct llama_context *ctx, llama_seq_id seq_id_src, llama_seq_id seq_id_dst, llama_pos p0, llama_pos p1)
     * }
     */
    public static MemorySegment llama_kv_self_seq_cp$address() {
        return llama_kv_self_seq_cp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_kv_self_seq_cp(struct llama_context *ctx, llama_seq_id seq_id_src, llama_seq_id seq_id_dst, llama_pos p0, llama_pos p1)
     * }
     */
    public static void llama_kv_self_seq_cp(MemorySegment ctx, int seq_id_src, int seq_id_dst, int p0, int p1) {
        var mh$ = llama_kv_self_seq_cp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_kv_self_seq_cp", ctx, seq_id_src, seq_id_dst, p0, p1);
            }
            mh$.invokeExact(ctx, seq_id_src, seq_id_dst, p0, p1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_kv_self_seq_keep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_kv_self_seq_keep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_kv_self_seq_keep(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static FunctionDescriptor llama_kv_self_seq_keep$descriptor() {
        return llama_kv_self_seq_keep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_kv_self_seq_keep(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static MethodHandle llama_kv_self_seq_keep$handle() {
        return llama_kv_self_seq_keep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_kv_self_seq_keep(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static MemorySegment llama_kv_self_seq_keep$address() {
        return llama_kv_self_seq_keep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_kv_self_seq_keep(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static void llama_kv_self_seq_keep(MemorySegment ctx, int seq_id) {
        var mh$ = llama_kv_self_seq_keep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_kv_self_seq_keep", ctx, seq_id);
            }
            mh$.invokeExact(ctx, seq_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_kv_self_seq_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_kv_self_seq_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_kv_self_seq_add(struct llama_context *ctx, llama_seq_id seq_id, llama_pos p0, llama_pos p1, llama_pos delta)
     * }
     */
    public static FunctionDescriptor llama_kv_self_seq_add$descriptor() {
        return llama_kv_self_seq_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_kv_self_seq_add(struct llama_context *ctx, llama_seq_id seq_id, llama_pos p0, llama_pos p1, llama_pos delta)
     * }
     */
    public static MethodHandle llama_kv_self_seq_add$handle() {
        return llama_kv_self_seq_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_kv_self_seq_add(struct llama_context *ctx, llama_seq_id seq_id, llama_pos p0, llama_pos p1, llama_pos delta)
     * }
     */
    public static MemorySegment llama_kv_self_seq_add$address() {
        return llama_kv_self_seq_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_kv_self_seq_add(struct llama_context *ctx, llama_seq_id seq_id, llama_pos p0, llama_pos p1, llama_pos delta)
     * }
     */
    public static void llama_kv_self_seq_add(MemorySegment ctx, int seq_id, int p0, int p1, int delta) {
        var mh$ = llama_kv_self_seq_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_kv_self_seq_add", ctx, seq_id, p0, p1, delta);
            }
            mh$.invokeExact(ctx, seq_id, p0, p1, delta);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_kv_self_seq_div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_kv_self_seq_div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_kv_self_seq_div(struct llama_context *ctx, llama_seq_id seq_id, llama_pos p0, llama_pos p1, int d)
     * }
     */
    public static FunctionDescriptor llama_kv_self_seq_div$descriptor() {
        return llama_kv_self_seq_div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_kv_self_seq_div(struct llama_context *ctx, llama_seq_id seq_id, llama_pos p0, llama_pos p1, int d)
     * }
     */
    public static MethodHandle llama_kv_self_seq_div$handle() {
        return llama_kv_self_seq_div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_kv_self_seq_div(struct llama_context *ctx, llama_seq_id seq_id, llama_pos p0, llama_pos p1, int d)
     * }
     */
    public static MemorySegment llama_kv_self_seq_div$address() {
        return llama_kv_self_seq_div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_kv_self_seq_div(struct llama_context *ctx, llama_seq_id seq_id, llama_pos p0, llama_pos p1, int d)
     * }
     */
    public static void llama_kv_self_seq_div(MemorySegment ctx, int seq_id, int p0, int p1, int d) {
        var mh$ = llama_kv_self_seq_div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_kv_self_seq_div", ctx, seq_id, p0, p1, d);
            }
            mh$.invokeExact(ctx, seq_id, p0, p1, d);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_kv_self_seq_pos_min {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_kv_self_seq_pos_min");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_pos llama_kv_self_seq_pos_min(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static FunctionDescriptor llama_kv_self_seq_pos_min$descriptor() {
        return llama_kv_self_seq_pos_min.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_pos llama_kv_self_seq_pos_min(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static MethodHandle llama_kv_self_seq_pos_min$handle() {
        return llama_kv_self_seq_pos_min.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_pos llama_kv_self_seq_pos_min(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static MemorySegment llama_kv_self_seq_pos_min$address() {
        return llama_kv_self_seq_pos_min.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_pos llama_kv_self_seq_pos_min(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static int llama_kv_self_seq_pos_min(MemorySegment ctx, int seq_id) {
        var mh$ = llama_kv_self_seq_pos_min.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_kv_self_seq_pos_min", ctx, seq_id);
            }
            return (int)mh$.invokeExact(ctx, seq_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_kv_self_seq_pos_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_kv_self_seq_pos_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_pos llama_kv_self_seq_pos_max(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static FunctionDescriptor llama_kv_self_seq_pos_max$descriptor() {
        return llama_kv_self_seq_pos_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_pos llama_kv_self_seq_pos_max(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static MethodHandle llama_kv_self_seq_pos_max$handle() {
        return llama_kv_self_seq_pos_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_pos llama_kv_self_seq_pos_max(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static MemorySegment llama_kv_self_seq_pos_max$address() {
        return llama_kv_self_seq_pos_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_pos llama_kv_self_seq_pos_max(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static int llama_kv_self_seq_pos_max(MemorySegment ctx, int seq_id) {
        var mh$ = llama_kv_self_seq_pos_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_kv_self_seq_pos_max", ctx, seq_id);
            }
            return (int)mh$.invokeExact(ctx, seq_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_kv_self_defrag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_kv_self_defrag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_kv_self_defrag(struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_kv_self_defrag$descriptor() {
        return llama_kv_self_defrag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_kv_self_defrag(struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_kv_self_defrag$handle() {
        return llama_kv_self_defrag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_kv_self_defrag(struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_kv_self_defrag$address() {
        return llama_kv_self_defrag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_kv_self_defrag(struct llama_context *ctx)
     * }
     */
    public static void llama_kv_self_defrag(MemorySegment ctx) {
        var mh$ = llama_kv_self_defrag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_kv_self_defrag", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_kv_self_can_shift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_kv_self_can_shift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_kv_self_can_shift(const struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_kv_self_can_shift$descriptor() {
        return llama_kv_self_can_shift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_kv_self_can_shift(const struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_kv_self_can_shift$handle() {
        return llama_kv_self_can_shift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_kv_self_can_shift(const struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_kv_self_can_shift$address() {
        return llama_kv_self_can_shift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_kv_self_can_shift(const struct llama_context *ctx)
     * }
     */
    public static boolean llama_kv_self_can_shift(MemorySegment ctx) {
        var mh$ = llama_kv_self_can_shift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_kv_self_can_shift", ctx);
            }
            return (boolean)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_kv_self_update {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_kv_self_update");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_kv_self_update(struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_kv_self_update$descriptor() {
        return llama_kv_self_update.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_kv_self_update(struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_kv_self_update$handle() {
        return llama_kv_self_update.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_kv_self_update(struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_kv_self_update$address() {
        return llama_kv_self_update.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_kv_self_update(struct llama_context *ctx)
     * }
     */
    public static void llama_kv_self_update(MemorySegment ctx) {
        var mh$ = llama_kv_self_update.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_kv_self_update", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_state_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_state_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t llama_state_get_size(struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_state_get_size$descriptor() {
        return llama_state_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t llama_state_get_size(struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_state_get_size$handle() {
        return llama_state_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t llama_state_get_size(struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_state_get_size$address() {
        return llama_state_get_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t llama_state_get_size(struct llama_context *ctx)
     * }
     */
    public static long llama_state_get_size(MemorySegment ctx) {
        var mh$ = llama_state_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_state_get_size", ctx);
            }
            return (long)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_get_state_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_get_state_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t llama_get_state_size(struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_get_state_size$descriptor() {
        return llama_get_state_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t llama_get_state_size(struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_get_state_size$handle() {
        return llama_get_state_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t llama_get_state_size(struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_get_state_size$address() {
        return llama_get_state_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t llama_get_state_size(struct llama_context *ctx)
     * }
     */
    public static long llama_get_state_size(MemorySegment ctx) {
        var mh$ = llama_get_state_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_get_state_size", ctx);
            }
            return (long)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_state_get_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_state_get_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t llama_state_get_data(struct llama_context *ctx, uint8_t *dst, size_t size)
     * }
     */
    public static FunctionDescriptor llama_state_get_data$descriptor() {
        return llama_state_get_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t llama_state_get_data(struct llama_context *ctx, uint8_t *dst, size_t size)
     * }
     */
    public static MethodHandle llama_state_get_data$handle() {
        return llama_state_get_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t llama_state_get_data(struct llama_context *ctx, uint8_t *dst, size_t size)
     * }
     */
    public static MemorySegment llama_state_get_data$address() {
        return llama_state_get_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t llama_state_get_data(struct llama_context *ctx, uint8_t *dst, size_t size)
     * }
     */
    public static long llama_state_get_data(MemorySegment ctx, MemorySegment dst, long size) {
        var mh$ = llama_state_get_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_state_get_data", ctx, dst, size);
            }
            return (long)mh$.invokeExact(ctx, dst, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_copy_state_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_copy_state_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t llama_copy_state_data(struct llama_context *ctx, uint8_t *dst)
     * }
     */
    public static FunctionDescriptor llama_copy_state_data$descriptor() {
        return llama_copy_state_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t llama_copy_state_data(struct llama_context *ctx, uint8_t *dst)
     * }
     */
    public static MethodHandle llama_copy_state_data$handle() {
        return llama_copy_state_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t llama_copy_state_data(struct llama_context *ctx, uint8_t *dst)
     * }
     */
    public static MemorySegment llama_copy_state_data$address() {
        return llama_copy_state_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t llama_copy_state_data(struct llama_context *ctx, uint8_t *dst)
     * }
     */
    public static long llama_copy_state_data(MemorySegment ctx, MemorySegment dst) {
        var mh$ = llama_copy_state_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_copy_state_data", ctx, dst);
            }
            return (long)mh$.invokeExact(ctx, dst);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_state_set_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_state_set_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t llama_state_set_data(struct llama_context *ctx, const uint8_t *src, size_t size)
     * }
     */
    public static FunctionDescriptor llama_state_set_data$descriptor() {
        return llama_state_set_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t llama_state_set_data(struct llama_context *ctx, const uint8_t *src, size_t size)
     * }
     */
    public static MethodHandle llama_state_set_data$handle() {
        return llama_state_set_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t llama_state_set_data(struct llama_context *ctx, const uint8_t *src, size_t size)
     * }
     */
    public static MemorySegment llama_state_set_data$address() {
        return llama_state_set_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t llama_state_set_data(struct llama_context *ctx, const uint8_t *src, size_t size)
     * }
     */
    public static long llama_state_set_data(MemorySegment ctx, MemorySegment src, long size) {
        var mh$ = llama_state_set_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_state_set_data", ctx, src, size);
            }
            return (long)mh$.invokeExact(ctx, src, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_set_state_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_set_state_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t llama_set_state_data(struct llama_context *ctx, const uint8_t *src)
     * }
     */
    public static FunctionDescriptor llama_set_state_data$descriptor() {
        return llama_set_state_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t llama_set_state_data(struct llama_context *ctx, const uint8_t *src)
     * }
     */
    public static MethodHandle llama_set_state_data$handle() {
        return llama_set_state_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t llama_set_state_data(struct llama_context *ctx, const uint8_t *src)
     * }
     */
    public static MemorySegment llama_set_state_data$address() {
        return llama_set_state_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t llama_set_state_data(struct llama_context *ctx, const uint8_t *src)
     * }
     */
    public static long llama_set_state_data(MemorySegment ctx, MemorySegment src) {
        var mh$ = llama_set_state_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_set_state_data", ctx, src);
            }
            return (long)mh$.invokeExact(ctx, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_state_load_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_state_load_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_state_load_file(struct llama_context *ctx, const char *path_session, llama_token *tokens_out, size_t n_token_capacity, size_t *n_token_count_out)
     * }
     */
    public static FunctionDescriptor llama_state_load_file$descriptor() {
        return llama_state_load_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_state_load_file(struct llama_context *ctx, const char *path_session, llama_token *tokens_out, size_t n_token_capacity, size_t *n_token_count_out)
     * }
     */
    public static MethodHandle llama_state_load_file$handle() {
        return llama_state_load_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_state_load_file(struct llama_context *ctx, const char *path_session, llama_token *tokens_out, size_t n_token_capacity, size_t *n_token_count_out)
     * }
     */
    public static MemorySegment llama_state_load_file$address() {
        return llama_state_load_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_state_load_file(struct llama_context *ctx, const char *path_session, llama_token *tokens_out, size_t n_token_capacity, size_t *n_token_count_out)
     * }
     */
    public static boolean llama_state_load_file(MemorySegment ctx, MemorySegment path_session, MemorySegment tokens_out, long n_token_capacity, MemorySegment n_token_count_out) {
        var mh$ = llama_state_load_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_state_load_file", ctx, path_session, tokens_out, n_token_capacity, n_token_count_out);
            }
            return (boolean)mh$.invokeExact(ctx, path_session, tokens_out, n_token_capacity, n_token_count_out);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_load_session_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_load_session_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_load_session_file(struct llama_context *ctx, const char *path_session, llama_token *tokens_out, size_t n_token_capacity, size_t *n_token_count_out)
     * }
     */
    public static FunctionDescriptor llama_load_session_file$descriptor() {
        return llama_load_session_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_load_session_file(struct llama_context *ctx, const char *path_session, llama_token *tokens_out, size_t n_token_capacity, size_t *n_token_count_out)
     * }
     */
    public static MethodHandle llama_load_session_file$handle() {
        return llama_load_session_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_load_session_file(struct llama_context *ctx, const char *path_session, llama_token *tokens_out, size_t n_token_capacity, size_t *n_token_count_out)
     * }
     */
    public static MemorySegment llama_load_session_file$address() {
        return llama_load_session_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_load_session_file(struct llama_context *ctx, const char *path_session, llama_token *tokens_out, size_t n_token_capacity, size_t *n_token_count_out)
     * }
     */
    public static boolean llama_load_session_file(MemorySegment ctx, MemorySegment path_session, MemorySegment tokens_out, long n_token_capacity, MemorySegment n_token_count_out) {
        var mh$ = llama_load_session_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_load_session_file", ctx, path_session, tokens_out, n_token_capacity, n_token_count_out);
            }
            return (boolean)mh$.invokeExact(ctx, path_session, tokens_out, n_token_capacity, n_token_count_out);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_state_save_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_state_save_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_state_save_file(struct llama_context *ctx, const char *path_session, const llama_token *tokens, size_t n_token_count)
     * }
     */
    public static FunctionDescriptor llama_state_save_file$descriptor() {
        return llama_state_save_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_state_save_file(struct llama_context *ctx, const char *path_session, const llama_token *tokens, size_t n_token_count)
     * }
     */
    public static MethodHandle llama_state_save_file$handle() {
        return llama_state_save_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_state_save_file(struct llama_context *ctx, const char *path_session, const llama_token *tokens, size_t n_token_count)
     * }
     */
    public static MemorySegment llama_state_save_file$address() {
        return llama_state_save_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_state_save_file(struct llama_context *ctx, const char *path_session, const llama_token *tokens, size_t n_token_count)
     * }
     */
    public static boolean llama_state_save_file(MemorySegment ctx, MemorySegment path_session, MemorySegment tokens, long n_token_count) {
        var mh$ = llama_state_save_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_state_save_file", ctx, path_session, tokens, n_token_count);
            }
            return (boolean)mh$.invokeExact(ctx, path_session, tokens, n_token_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_save_session_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_save_session_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_save_session_file(struct llama_context *ctx, const char *path_session, const llama_token *tokens, size_t n_token_count)
     * }
     */
    public static FunctionDescriptor llama_save_session_file$descriptor() {
        return llama_save_session_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_save_session_file(struct llama_context *ctx, const char *path_session, const llama_token *tokens, size_t n_token_count)
     * }
     */
    public static MethodHandle llama_save_session_file$handle() {
        return llama_save_session_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_save_session_file(struct llama_context *ctx, const char *path_session, const llama_token *tokens, size_t n_token_count)
     * }
     */
    public static MemorySegment llama_save_session_file$address() {
        return llama_save_session_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_save_session_file(struct llama_context *ctx, const char *path_session, const llama_token *tokens, size_t n_token_count)
     * }
     */
    public static boolean llama_save_session_file(MemorySegment ctx, MemorySegment path_session, MemorySegment tokens, long n_token_count) {
        var mh$ = llama_save_session_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_save_session_file", ctx, path_session, tokens, n_token_count);
            }
            return (boolean)mh$.invokeExact(ctx, path_session, tokens, n_token_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_state_seq_get_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_state_seq_get_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t llama_state_seq_get_size(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static FunctionDescriptor llama_state_seq_get_size$descriptor() {
        return llama_state_seq_get_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t llama_state_seq_get_size(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static MethodHandle llama_state_seq_get_size$handle() {
        return llama_state_seq_get_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t llama_state_seq_get_size(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static MemorySegment llama_state_seq_get_size$address() {
        return llama_state_seq_get_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t llama_state_seq_get_size(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static long llama_state_seq_get_size(MemorySegment ctx, int seq_id) {
        var mh$ = llama_state_seq_get_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_state_seq_get_size", ctx, seq_id);
            }
            return (long)mh$.invokeExact(ctx, seq_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_state_seq_get_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_state_seq_get_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t llama_state_seq_get_data(struct llama_context *ctx, uint8_t *dst, size_t size, llama_seq_id seq_id)
     * }
     */
    public static FunctionDescriptor llama_state_seq_get_data$descriptor() {
        return llama_state_seq_get_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t llama_state_seq_get_data(struct llama_context *ctx, uint8_t *dst, size_t size, llama_seq_id seq_id)
     * }
     */
    public static MethodHandle llama_state_seq_get_data$handle() {
        return llama_state_seq_get_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t llama_state_seq_get_data(struct llama_context *ctx, uint8_t *dst, size_t size, llama_seq_id seq_id)
     * }
     */
    public static MemorySegment llama_state_seq_get_data$address() {
        return llama_state_seq_get_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t llama_state_seq_get_data(struct llama_context *ctx, uint8_t *dst, size_t size, llama_seq_id seq_id)
     * }
     */
    public static long llama_state_seq_get_data(MemorySegment ctx, MemorySegment dst, long size, int seq_id) {
        var mh$ = llama_state_seq_get_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_state_seq_get_data", ctx, dst, size, seq_id);
            }
            return (long)mh$.invokeExact(ctx, dst, size, seq_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_state_seq_set_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_state_seq_set_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t llama_state_seq_set_data(struct llama_context *ctx, const uint8_t *src, size_t size, llama_seq_id dest_seq_id)
     * }
     */
    public static FunctionDescriptor llama_state_seq_set_data$descriptor() {
        return llama_state_seq_set_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t llama_state_seq_set_data(struct llama_context *ctx, const uint8_t *src, size_t size, llama_seq_id dest_seq_id)
     * }
     */
    public static MethodHandle llama_state_seq_set_data$handle() {
        return llama_state_seq_set_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t llama_state_seq_set_data(struct llama_context *ctx, const uint8_t *src, size_t size, llama_seq_id dest_seq_id)
     * }
     */
    public static MemorySegment llama_state_seq_set_data$address() {
        return llama_state_seq_set_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t llama_state_seq_set_data(struct llama_context *ctx, const uint8_t *src, size_t size, llama_seq_id dest_seq_id)
     * }
     */
    public static long llama_state_seq_set_data(MemorySegment ctx, MemorySegment src, long size, int dest_seq_id) {
        var mh$ = llama_state_seq_set_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_state_seq_set_data", ctx, src, size, dest_seq_id);
            }
            return (long)mh$.invokeExact(ctx, src, size, dest_seq_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_state_seq_save_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_state_seq_save_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t llama_state_seq_save_file(struct llama_context *ctx, const char *filepath, llama_seq_id seq_id, const llama_token *tokens, size_t n_token_count)
     * }
     */
    public static FunctionDescriptor llama_state_seq_save_file$descriptor() {
        return llama_state_seq_save_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t llama_state_seq_save_file(struct llama_context *ctx, const char *filepath, llama_seq_id seq_id, const llama_token *tokens, size_t n_token_count)
     * }
     */
    public static MethodHandle llama_state_seq_save_file$handle() {
        return llama_state_seq_save_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t llama_state_seq_save_file(struct llama_context *ctx, const char *filepath, llama_seq_id seq_id, const llama_token *tokens, size_t n_token_count)
     * }
     */
    public static MemorySegment llama_state_seq_save_file$address() {
        return llama_state_seq_save_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t llama_state_seq_save_file(struct llama_context *ctx, const char *filepath, llama_seq_id seq_id, const llama_token *tokens, size_t n_token_count)
     * }
     */
    public static long llama_state_seq_save_file(MemorySegment ctx, MemorySegment filepath, int seq_id, MemorySegment tokens, long n_token_count) {
        var mh$ = llama_state_seq_save_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_state_seq_save_file", ctx, filepath, seq_id, tokens, n_token_count);
            }
            return (long)mh$.invokeExact(ctx, filepath, seq_id, tokens, n_token_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_state_seq_load_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_LONG,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_state_seq_load_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t llama_state_seq_load_file(struct llama_context *ctx, const char *filepath, llama_seq_id dest_seq_id, llama_token *tokens_out, size_t n_token_capacity, size_t *n_token_count_out)
     * }
     */
    public static FunctionDescriptor llama_state_seq_load_file$descriptor() {
        return llama_state_seq_load_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t llama_state_seq_load_file(struct llama_context *ctx, const char *filepath, llama_seq_id dest_seq_id, llama_token *tokens_out, size_t n_token_capacity, size_t *n_token_count_out)
     * }
     */
    public static MethodHandle llama_state_seq_load_file$handle() {
        return llama_state_seq_load_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t llama_state_seq_load_file(struct llama_context *ctx, const char *filepath, llama_seq_id dest_seq_id, llama_token *tokens_out, size_t n_token_capacity, size_t *n_token_count_out)
     * }
     */
    public static MemorySegment llama_state_seq_load_file$address() {
        return llama_state_seq_load_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t llama_state_seq_load_file(struct llama_context *ctx, const char *filepath, llama_seq_id dest_seq_id, llama_token *tokens_out, size_t n_token_capacity, size_t *n_token_count_out)
     * }
     */
    public static long llama_state_seq_load_file(MemorySegment ctx, MemorySegment filepath, int dest_seq_id, MemorySegment tokens_out, long n_token_capacity, MemorySegment n_token_count_out) {
        var mh$ = llama_state_seq_load_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_state_seq_load_file", ctx, filepath, dest_seq_id, tokens_out, n_token_capacity, n_token_count_out);
            }
            return (long)mh$.invokeExact(ctx, filepath, dest_seq_id, tokens_out, n_token_capacity, n_token_count_out);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_batch_get_one {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_batch.layout(),
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_batch_get_one");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_batch llama_batch_get_one(llama_token *tokens, int32_t n_tokens)
     * }
     */
    public static FunctionDescriptor llama_batch_get_one$descriptor() {
        return llama_batch_get_one.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_batch llama_batch_get_one(llama_token *tokens, int32_t n_tokens)
     * }
     */
    public static MethodHandle llama_batch_get_one$handle() {
        return llama_batch_get_one.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_batch llama_batch_get_one(llama_token *tokens, int32_t n_tokens)
     * }
     */
    public static MemorySegment llama_batch_get_one$address() {
        return llama_batch_get_one.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_batch llama_batch_get_one(llama_token *tokens, int32_t n_tokens)
     * }
     */
    public static MemorySegment llama_batch_get_one(SegmentAllocator allocator, MemorySegment tokens, int n_tokens) {
        var mh$ = llama_batch_get_one.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_batch_get_one", allocator, tokens, n_tokens);
            }
            return (MemorySegment)mh$.invokeExact(allocator, tokens, n_tokens);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_batch_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_batch.layout(),
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_batch_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_batch llama_batch_init(int32_t n_tokens, int32_t embd, int32_t n_seq_max)
     * }
     */
    public static FunctionDescriptor llama_batch_init$descriptor() {
        return llama_batch_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_batch llama_batch_init(int32_t n_tokens, int32_t embd, int32_t n_seq_max)
     * }
     */
    public static MethodHandle llama_batch_init$handle() {
        return llama_batch_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_batch llama_batch_init(int32_t n_tokens, int32_t embd, int32_t n_seq_max)
     * }
     */
    public static MemorySegment llama_batch_init$address() {
        return llama_batch_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_batch llama_batch_init(int32_t n_tokens, int32_t embd, int32_t n_seq_max)
     * }
     */
    public static MemorySegment llama_batch_init(SegmentAllocator allocator, int n_tokens, int embd, int n_seq_max) {
        var mh$ = llama_batch_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_batch_init", allocator, n_tokens, embd, n_seq_max);
            }
            return (MemorySegment)mh$.invokeExact(allocator, n_tokens, embd, n_seq_max);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_batch_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_batch.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_batch_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_batch_free(struct llama_batch batch)
     * }
     */
    public static FunctionDescriptor llama_batch_free$descriptor() {
        return llama_batch_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_batch_free(struct llama_batch batch)
     * }
     */
    public static MethodHandle llama_batch_free$handle() {
        return llama_batch_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_batch_free(struct llama_batch batch)
     * }
     */
    public static MemorySegment llama_batch_free$address() {
        return llama_batch_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_batch_free(struct llama_batch batch)
     * }
     */
    public static void llama_batch_free(MemorySegment batch) {
        var mh$ = llama_batch_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_batch_free", batch);
            }
            mh$.invokeExact(batch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_encode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_batch.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_encode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_encode(struct llama_context *ctx, struct llama_batch batch)
     * }
     */
    public static FunctionDescriptor llama_encode$descriptor() {
        return llama_encode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_encode(struct llama_context *ctx, struct llama_batch batch)
     * }
     */
    public static MethodHandle llama_encode$handle() {
        return llama_encode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_encode(struct llama_context *ctx, struct llama_batch batch)
     * }
     */
    public static MemorySegment llama_encode$address() {
        return llama_encode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_encode(struct llama_context *ctx, struct llama_batch batch)
     * }
     */
    public static int llama_encode(MemorySegment ctx, MemorySegment batch) {
        var mh$ = llama_encode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_encode", ctx, batch);
            }
            return (int)mh$.invokeExact(ctx, batch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_batch.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_decode(struct llama_context *ctx, struct llama_batch batch)
     * }
     */
    public static FunctionDescriptor llama_decode$descriptor() {
        return llama_decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_decode(struct llama_context *ctx, struct llama_batch batch)
     * }
     */
    public static MethodHandle llama_decode$handle() {
        return llama_decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_decode(struct llama_context *ctx, struct llama_batch batch)
     * }
     */
    public static MemorySegment llama_decode$address() {
        return llama_decode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_decode(struct llama_context *ctx, struct llama_batch batch)
     * }
     */
    public static int llama_decode(MemorySegment ctx, MemorySegment batch) {
        var mh$ = llama_decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_decode", ctx, batch);
            }
            return (int)mh$.invokeExact(ctx, batch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_set_n_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_set_n_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_set_n_threads(struct llama_context *ctx, int32_t n_threads, int32_t n_threads_batch)
     * }
     */
    public static FunctionDescriptor llama_set_n_threads$descriptor() {
        return llama_set_n_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_set_n_threads(struct llama_context *ctx, int32_t n_threads, int32_t n_threads_batch)
     * }
     */
    public static MethodHandle llama_set_n_threads$handle() {
        return llama_set_n_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_set_n_threads(struct llama_context *ctx, int32_t n_threads, int32_t n_threads_batch)
     * }
     */
    public static MemorySegment llama_set_n_threads$address() {
        return llama_set_n_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_set_n_threads(struct llama_context *ctx, int32_t n_threads, int32_t n_threads_batch)
     * }
     */
    public static void llama_set_n_threads(MemorySegment ctx, int n_threads, int n_threads_batch) {
        var mh$ = llama_set_n_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_set_n_threads", ctx, n_threads, n_threads_batch);
            }
            mh$.invokeExact(ctx, n_threads, n_threads_batch);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_n_threads {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_n_threads");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_n_threads(struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_n_threads$descriptor() {
        return llama_n_threads.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_n_threads(struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_n_threads$handle() {
        return llama_n_threads.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_n_threads(struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_n_threads$address() {
        return llama_n_threads.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_n_threads(struct llama_context *ctx)
     * }
     */
    public static int llama_n_threads(MemorySegment ctx) {
        var mh$ = llama_n_threads.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_n_threads", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_n_threads_batch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_n_threads_batch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_n_threads_batch(struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_n_threads_batch$descriptor() {
        return llama_n_threads_batch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_n_threads_batch(struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_n_threads_batch$handle() {
        return llama_n_threads_batch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_n_threads_batch(struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_n_threads_batch$address() {
        return llama_n_threads_batch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_n_threads_batch(struct llama_context *ctx)
     * }
     */
    public static int llama_n_threads_batch(MemorySegment ctx) {
        var mh$ = llama_n_threads_batch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_n_threads_batch", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_set_embeddings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_set_embeddings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_set_embeddings(struct llama_context *ctx, bool embeddings)
     * }
     */
    public static FunctionDescriptor llama_set_embeddings$descriptor() {
        return llama_set_embeddings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_set_embeddings(struct llama_context *ctx, bool embeddings)
     * }
     */
    public static MethodHandle llama_set_embeddings$handle() {
        return llama_set_embeddings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_set_embeddings(struct llama_context *ctx, bool embeddings)
     * }
     */
    public static MemorySegment llama_set_embeddings$address() {
        return llama_set_embeddings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_set_embeddings(struct llama_context *ctx, bool embeddings)
     * }
     */
    public static void llama_set_embeddings(MemorySegment ctx, boolean embeddings) {
        var mh$ = llama_set_embeddings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_set_embeddings", ctx, embeddings);
            }
            mh$.invokeExact(ctx, embeddings);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_set_causal_attn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_set_causal_attn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_set_causal_attn(struct llama_context *ctx, bool causal_attn)
     * }
     */
    public static FunctionDescriptor llama_set_causal_attn$descriptor() {
        return llama_set_causal_attn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_set_causal_attn(struct llama_context *ctx, bool causal_attn)
     * }
     */
    public static MethodHandle llama_set_causal_attn$handle() {
        return llama_set_causal_attn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_set_causal_attn(struct llama_context *ctx, bool causal_attn)
     * }
     */
    public static MemorySegment llama_set_causal_attn$address() {
        return llama_set_causal_attn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_set_causal_attn(struct llama_context *ctx, bool causal_attn)
     * }
     */
    public static void llama_set_causal_attn(MemorySegment ctx, boolean causal_attn) {
        var mh$ = llama_set_causal_attn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_set_causal_attn", ctx, causal_attn);
            }
            mh$.invokeExact(ctx, causal_attn);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_set_warmup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_set_warmup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_set_warmup(struct llama_context *ctx, bool warmup)
     * }
     */
    public static FunctionDescriptor llama_set_warmup$descriptor() {
        return llama_set_warmup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_set_warmup(struct llama_context *ctx, bool warmup)
     * }
     */
    public static MethodHandle llama_set_warmup$handle() {
        return llama_set_warmup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_set_warmup(struct llama_context *ctx, bool warmup)
     * }
     */
    public static MemorySegment llama_set_warmup$address() {
        return llama_set_warmup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_set_warmup(struct llama_context *ctx, bool warmup)
     * }
     */
    public static void llama_set_warmup(MemorySegment ctx, boolean warmup) {
        var mh$ = llama_set_warmup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_set_warmup", ctx, warmup);
            }
            mh$.invokeExact(ctx, warmup);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_set_abort_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_set_abort_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_set_abort_callback(struct llama_context *ctx, ggml_abort_callback abort_callback, void *abort_callback_data)
     * }
     */
    public static FunctionDescriptor llama_set_abort_callback$descriptor() {
        return llama_set_abort_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_set_abort_callback(struct llama_context *ctx, ggml_abort_callback abort_callback, void *abort_callback_data)
     * }
     */
    public static MethodHandle llama_set_abort_callback$handle() {
        return llama_set_abort_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_set_abort_callback(struct llama_context *ctx, ggml_abort_callback abort_callback, void *abort_callback_data)
     * }
     */
    public static MemorySegment llama_set_abort_callback$address() {
        return llama_set_abort_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_set_abort_callback(struct llama_context *ctx, ggml_abort_callback abort_callback, void *abort_callback_data)
     * }
     */
    public static void llama_set_abort_callback(MemorySegment ctx, MemorySegment abort_callback, MemorySegment abort_callback_data) {
        var mh$ = llama_set_abort_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_set_abort_callback", ctx, abort_callback, abort_callback_data);
            }
            mh$.invokeExact(ctx, abort_callback, abort_callback_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_synchronize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_synchronize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_synchronize(struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_synchronize$descriptor() {
        return llama_synchronize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_synchronize(struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_synchronize$handle() {
        return llama_synchronize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_synchronize(struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_synchronize$address() {
        return llama_synchronize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_synchronize(struct llama_context *ctx)
     * }
     */
    public static void llama_synchronize(MemorySegment ctx) {
        var mh$ = llama_synchronize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_synchronize", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_get_logits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_get_logits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float *llama_get_logits(struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_get_logits$descriptor() {
        return llama_get_logits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float *llama_get_logits(struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_get_logits$handle() {
        return llama_get_logits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float *llama_get_logits(struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_get_logits$address() {
        return llama_get_logits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float *llama_get_logits(struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_get_logits(MemorySegment ctx) {
        var mh$ = llama_get_logits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_get_logits", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_get_logits_ith {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_get_logits_ith");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float *llama_get_logits_ith(struct llama_context *ctx, int32_t i)
     * }
     */
    public static FunctionDescriptor llama_get_logits_ith$descriptor() {
        return llama_get_logits_ith.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float *llama_get_logits_ith(struct llama_context *ctx, int32_t i)
     * }
     */
    public static MethodHandle llama_get_logits_ith$handle() {
        return llama_get_logits_ith.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float *llama_get_logits_ith(struct llama_context *ctx, int32_t i)
     * }
     */
    public static MemorySegment llama_get_logits_ith$address() {
        return llama_get_logits_ith.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float *llama_get_logits_ith(struct llama_context *ctx, int32_t i)
     * }
     */
    public static MemorySegment llama_get_logits_ith(MemorySegment ctx, int i) {
        var mh$ = llama_get_logits_ith.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_get_logits_ith", ctx, i);
            }
            return (MemorySegment)mh$.invokeExact(ctx, i);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_get_embeddings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_get_embeddings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float *llama_get_embeddings(struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_get_embeddings$descriptor() {
        return llama_get_embeddings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float *llama_get_embeddings(struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_get_embeddings$handle() {
        return llama_get_embeddings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float *llama_get_embeddings(struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_get_embeddings$address() {
        return llama_get_embeddings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float *llama_get_embeddings(struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_get_embeddings(MemorySegment ctx) {
        var mh$ = llama_get_embeddings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_get_embeddings", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_get_embeddings_ith {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_get_embeddings_ith");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float *llama_get_embeddings_ith(struct llama_context *ctx, int32_t i)
     * }
     */
    public static FunctionDescriptor llama_get_embeddings_ith$descriptor() {
        return llama_get_embeddings_ith.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float *llama_get_embeddings_ith(struct llama_context *ctx, int32_t i)
     * }
     */
    public static MethodHandle llama_get_embeddings_ith$handle() {
        return llama_get_embeddings_ith.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float *llama_get_embeddings_ith(struct llama_context *ctx, int32_t i)
     * }
     */
    public static MemorySegment llama_get_embeddings_ith$address() {
        return llama_get_embeddings_ith.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float *llama_get_embeddings_ith(struct llama_context *ctx, int32_t i)
     * }
     */
    public static MemorySegment llama_get_embeddings_ith(MemorySegment ctx, int i) {
        var mh$ = llama_get_embeddings_ith.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_get_embeddings_ith", ctx, i);
            }
            return (MemorySegment)mh$.invokeExact(ctx, i);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_get_embeddings_seq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_get_embeddings_seq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float *llama_get_embeddings_seq(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static FunctionDescriptor llama_get_embeddings_seq$descriptor() {
        return llama_get_embeddings_seq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float *llama_get_embeddings_seq(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static MethodHandle llama_get_embeddings_seq$handle() {
        return llama_get_embeddings_seq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float *llama_get_embeddings_seq(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static MemorySegment llama_get_embeddings_seq$address() {
        return llama_get_embeddings_seq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float *llama_get_embeddings_seq(struct llama_context *ctx, llama_seq_id seq_id)
     * }
     */
    public static MemorySegment llama_get_embeddings_seq(MemorySegment ctx, int seq_id) {
        var mh$ = llama_get_embeddings_seq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_get_embeddings_seq", ctx, seq_id);
            }
            return (MemorySegment)mh$.invokeExact(ctx, seq_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_get_text {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_get_text");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *llama_vocab_get_text(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static FunctionDescriptor llama_vocab_get_text$descriptor() {
        return llama_vocab_get_text.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *llama_vocab_get_text(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MethodHandle llama_vocab_get_text$handle() {
        return llama_vocab_get_text.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *llama_vocab_get_text(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MemorySegment llama_vocab_get_text$address() {
        return llama_vocab_get_text.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *llama_vocab_get_text(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MemorySegment llama_vocab_get_text(MemorySegment vocab, int token) {
        var mh$ = llama_vocab_get_text.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_get_text", vocab, token);
            }
            return (MemorySegment)mh$.invokeExact(vocab, token);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_get_score {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_FLOAT,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_get_score");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float llama_vocab_get_score(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static FunctionDescriptor llama_vocab_get_score$descriptor() {
        return llama_vocab_get_score.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float llama_vocab_get_score(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MethodHandle llama_vocab_get_score$handle() {
        return llama_vocab_get_score.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float llama_vocab_get_score(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MemorySegment llama_vocab_get_score$address() {
        return llama_vocab_get_score.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float llama_vocab_get_score(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static float llama_vocab_get_score(MemorySegment vocab, int token) {
        var mh$ = llama_vocab_get_score.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_get_score", vocab, token);
            }
            return (float)mh$.invokeExact(vocab, token);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_get_attr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_get_attr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum llama_token_attr llama_vocab_get_attr(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static FunctionDescriptor llama_vocab_get_attr$descriptor() {
        return llama_vocab_get_attr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum llama_token_attr llama_vocab_get_attr(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MethodHandle llama_vocab_get_attr$handle() {
        return llama_vocab_get_attr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum llama_token_attr llama_vocab_get_attr(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MemorySegment llama_vocab_get_attr$address() {
        return llama_vocab_get_attr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum llama_token_attr llama_vocab_get_attr(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static int llama_vocab_get_attr(MemorySegment vocab, int token) {
        var mh$ = llama_vocab_get_attr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_get_attr", vocab, token);
            }
            return (int)mh$.invokeExact(vocab, token);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_is_eog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_is_eog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_vocab_is_eog(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static FunctionDescriptor llama_vocab_is_eog$descriptor() {
        return llama_vocab_is_eog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_vocab_is_eog(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MethodHandle llama_vocab_is_eog$handle() {
        return llama_vocab_is_eog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_vocab_is_eog(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MemorySegment llama_vocab_is_eog$address() {
        return llama_vocab_is_eog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_vocab_is_eog(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static boolean llama_vocab_is_eog(MemorySegment vocab, int token) {
        var mh$ = llama_vocab_is_eog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_is_eog", vocab, token);
            }
            return (boolean)mh$.invokeExact(vocab, token);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_is_control {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_is_control");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_vocab_is_control(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static FunctionDescriptor llama_vocab_is_control$descriptor() {
        return llama_vocab_is_control.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_vocab_is_control(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MethodHandle llama_vocab_is_control$handle() {
        return llama_vocab_is_control.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_vocab_is_control(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MemorySegment llama_vocab_is_control$address() {
        return llama_vocab_is_control.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_vocab_is_control(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static boolean llama_vocab_is_control(MemorySegment vocab, int token) {
        var mh$ = llama_vocab_is_control.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_is_control", vocab, token);
            }
            return (boolean)mh$.invokeExact(vocab, token);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_bos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_bos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_vocab_bos(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_vocab_bos$descriptor() {
        return llama_vocab_bos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_vocab_bos(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_vocab_bos$handle() {
        return llama_vocab_bos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_vocab_bos(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_vocab_bos$address() {
        return llama_vocab_bos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_vocab_bos(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_vocab_bos(MemorySegment vocab) {
        var mh$ = llama_vocab_bos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_bos", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_eos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_eos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_vocab_eos(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_vocab_eos$descriptor() {
        return llama_vocab_eos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_vocab_eos(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_vocab_eos$handle() {
        return llama_vocab_eos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_vocab_eos(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_vocab_eos$address() {
        return llama_vocab_eos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_vocab_eos(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_vocab_eos(MemorySegment vocab) {
        var mh$ = llama_vocab_eos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_eos", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_eot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_eot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_vocab_eot(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_vocab_eot$descriptor() {
        return llama_vocab_eot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_vocab_eot(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_vocab_eot$handle() {
        return llama_vocab_eot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_vocab_eot(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_vocab_eot$address() {
        return llama_vocab_eot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_vocab_eot(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_vocab_eot(MemorySegment vocab) {
        var mh$ = llama_vocab_eot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_eot", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_sep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_sep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_vocab_sep(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_vocab_sep$descriptor() {
        return llama_vocab_sep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_vocab_sep(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_vocab_sep$handle() {
        return llama_vocab_sep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_vocab_sep(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_vocab_sep$address() {
        return llama_vocab_sep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_vocab_sep(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_vocab_sep(MemorySegment vocab) {
        var mh$ = llama_vocab_sep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_sep", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_nl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_nl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_vocab_nl(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_vocab_nl$descriptor() {
        return llama_vocab_nl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_vocab_nl(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_vocab_nl$handle() {
        return llama_vocab_nl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_vocab_nl(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_vocab_nl$address() {
        return llama_vocab_nl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_vocab_nl(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_vocab_nl(MemorySegment vocab) {
        var mh$ = llama_vocab_nl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_nl", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_pad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_pad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_vocab_pad(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_vocab_pad$descriptor() {
        return llama_vocab_pad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_vocab_pad(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_vocab_pad$handle() {
        return llama_vocab_pad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_vocab_pad(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_vocab_pad$address() {
        return llama_vocab_pad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_vocab_pad(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_vocab_pad(MemorySegment vocab) {
        var mh$ = llama_vocab_pad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_pad", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_get_add_bos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_get_add_bos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_vocab_get_add_bos(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_vocab_get_add_bos$descriptor() {
        return llama_vocab_get_add_bos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_vocab_get_add_bos(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_vocab_get_add_bos$handle() {
        return llama_vocab_get_add_bos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_vocab_get_add_bos(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_vocab_get_add_bos$address() {
        return llama_vocab_get_add_bos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_vocab_get_add_bos(const struct llama_vocab *vocab)
     * }
     */
    public static boolean llama_vocab_get_add_bos(MemorySegment vocab) {
        var mh$ = llama_vocab_get_add_bos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_get_add_bos", vocab);
            }
            return (boolean)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_get_add_eos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_get_add_eos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_vocab_get_add_eos(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_vocab_get_add_eos$descriptor() {
        return llama_vocab_get_add_eos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_vocab_get_add_eos(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_vocab_get_add_eos$handle() {
        return llama_vocab_get_add_eos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_vocab_get_add_eos(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_vocab_get_add_eos$address() {
        return llama_vocab_get_add_eos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_vocab_get_add_eos(const struct llama_vocab *vocab)
     * }
     */
    public static boolean llama_vocab_get_add_eos(MemorySegment vocab) {
        var mh$ = llama_vocab_get_add_eos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_get_add_eos", vocab);
            }
            return (boolean)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_fim_pre {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_fim_pre");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_pre(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_vocab_fim_pre$descriptor() {
        return llama_vocab_fim_pre.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_pre(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_vocab_fim_pre$handle() {
        return llama_vocab_fim_pre.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_pre(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_vocab_fim_pre$address() {
        return llama_vocab_fim_pre.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_pre(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_vocab_fim_pre(MemorySegment vocab) {
        var mh$ = llama_vocab_fim_pre.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_fim_pre", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_fim_suf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_fim_suf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_suf(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_vocab_fim_suf$descriptor() {
        return llama_vocab_fim_suf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_suf(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_vocab_fim_suf$handle() {
        return llama_vocab_fim_suf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_suf(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_vocab_fim_suf$address() {
        return llama_vocab_fim_suf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_suf(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_vocab_fim_suf(MemorySegment vocab) {
        var mh$ = llama_vocab_fim_suf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_fim_suf", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_fim_mid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_fim_mid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_mid(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_vocab_fim_mid$descriptor() {
        return llama_vocab_fim_mid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_mid(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_vocab_fim_mid$handle() {
        return llama_vocab_fim_mid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_mid(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_vocab_fim_mid$address() {
        return llama_vocab_fim_mid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_mid(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_vocab_fim_mid(MemorySegment vocab) {
        var mh$ = llama_vocab_fim_mid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_fim_mid", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_fim_pad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_fim_pad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_pad(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_vocab_fim_pad$descriptor() {
        return llama_vocab_fim_pad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_pad(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_vocab_fim_pad$handle() {
        return llama_vocab_fim_pad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_pad(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_vocab_fim_pad$address() {
        return llama_vocab_fim_pad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_pad(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_vocab_fim_pad(MemorySegment vocab) {
        var mh$ = llama_vocab_fim_pad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_fim_pad", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_fim_rep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_fim_rep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_rep(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_vocab_fim_rep$descriptor() {
        return llama_vocab_fim_rep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_rep(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_vocab_fim_rep$handle() {
        return llama_vocab_fim_rep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_rep(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_vocab_fim_rep$address() {
        return llama_vocab_fim_rep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_rep(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_vocab_fim_rep(MemorySegment vocab) {
        var mh$ = llama_vocab_fim_rep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_fim_rep", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_fim_sep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_fim_sep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_sep(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_vocab_fim_sep$descriptor() {
        return llama_vocab_fim_sep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_sep(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_vocab_fim_sep$handle() {
        return llama_vocab_fim_sep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_sep(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_vocab_fim_sep$address() {
        return llama_vocab_fim_sep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_vocab_fim_sep(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_vocab_fim_sep(MemorySegment vocab) {
        var mh$ = llama_vocab_fim_sep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_fim_sep", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_get_text {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_get_text");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *llama_token_get_text(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static FunctionDescriptor llama_token_get_text$descriptor() {
        return llama_token_get_text.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *llama_token_get_text(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MethodHandle llama_token_get_text$handle() {
        return llama_token_get_text.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *llama_token_get_text(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MemorySegment llama_token_get_text$address() {
        return llama_token_get_text.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *llama_token_get_text(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MemorySegment llama_token_get_text(MemorySegment vocab, int token) {
        var mh$ = llama_token_get_text.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_get_text", vocab, token);
            }
            return (MemorySegment)mh$.invokeExact(vocab, token);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_get_score {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_FLOAT,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_get_score");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float llama_token_get_score(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static FunctionDescriptor llama_token_get_score$descriptor() {
        return llama_token_get_score.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float llama_token_get_score(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MethodHandle llama_token_get_score$handle() {
        return llama_token_get_score.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float llama_token_get_score(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MemorySegment llama_token_get_score$address() {
        return llama_token_get_score.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float llama_token_get_score(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static float llama_token_get_score(MemorySegment vocab, int token) {
        var mh$ = llama_token_get_score.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_get_score", vocab, token);
            }
            return (float)mh$.invokeExact(vocab, token);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_get_attr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_get_attr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum llama_token_attr llama_token_get_attr(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static FunctionDescriptor llama_token_get_attr$descriptor() {
        return llama_token_get_attr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum llama_token_attr llama_token_get_attr(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MethodHandle llama_token_get_attr$handle() {
        return llama_token_get_attr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum llama_token_attr llama_token_get_attr(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MemorySegment llama_token_get_attr$address() {
        return llama_token_get_attr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum llama_token_attr llama_token_get_attr(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static int llama_token_get_attr(MemorySegment vocab, int token) {
        var mh$ = llama_token_get_attr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_get_attr", vocab, token);
            }
            return (int)mh$.invokeExact(vocab, token);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_is_eog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_is_eog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_token_is_eog(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static FunctionDescriptor llama_token_is_eog$descriptor() {
        return llama_token_is_eog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_token_is_eog(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MethodHandle llama_token_is_eog$handle() {
        return llama_token_is_eog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_token_is_eog(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MemorySegment llama_token_is_eog$address() {
        return llama_token_is_eog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_token_is_eog(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static boolean llama_token_is_eog(MemorySegment vocab, int token) {
        var mh$ = llama_token_is_eog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_is_eog", vocab, token);
            }
            return (boolean)mh$.invokeExact(vocab, token);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_is_control {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_is_control");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_token_is_control(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static FunctionDescriptor llama_token_is_control$descriptor() {
        return llama_token_is_control.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_token_is_control(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MethodHandle llama_token_is_control$handle() {
        return llama_token_is_control.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_token_is_control(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static MemorySegment llama_token_is_control$address() {
        return llama_token_is_control.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_token_is_control(const struct llama_vocab *vocab, llama_token token)
     * }
     */
    public static boolean llama_token_is_control(MemorySegment vocab, int token) {
        var mh$ = llama_token_is_control.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_is_control", vocab, token);
            }
            return (boolean)mh$.invokeExact(vocab, token);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_bos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_bos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_token_bos(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_token_bos$descriptor() {
        return llama_token_bos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_token_bos(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_token_bos$handle() {
        return llama_token_bos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_token_bos(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_token_bos$address() {
        return llama_token_bos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_token_bos(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_token_bos(MemorySegment vocab) {
        var mh$ = llama_token_bos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_bos", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_eos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_eos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_token_eos(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_token_eos$descriptor() {
        return llama_token_eos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_token_eos(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_token_eos$handle() {
        return llama_token_eos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_token_eos(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_token_eos$address() {
        return llama_token_eos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_token_eos(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_token_eos(MemorySegment vocab) {
        var mh$ = llama_token_eos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_eos", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_eot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_eot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_token_eot(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_token_eot$descriptor() {
        return llama_token_eot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_token_eot(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_token_eot$handle() {
        return llama_token_eot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_token_eot(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_token_eot$address() {
        return llama_token_eot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_token_eot(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_token_eot(MemorySegment vocab) {
        var mh$ = llama_token_eot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_eot", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_cls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_cls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_token_cls(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_token_cls$descriptor() {
        return llama_token_cls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_token_cls(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_token_cls$handle() {
        return llama_token_cls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_token_cls(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_token_cls$address() {
        return llama_token_cls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_token_cls(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_token_cls(MemorySegment vocab) {
        var mh$ = llama_token_cls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_cls", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_sep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_sep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_token_sep(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_token_sep$descriptor() {
        return llama_token_sep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_token_sep(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_token_sep$handle() {
        return llama_token_sep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_token_sep(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_token_sep$address() {
        return llama_token_sep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_token_sep(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_token_sep(MemorySegment vocab) {
        var mh$ = llama_token_sep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_sep", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_nl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_nl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_token_nl(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_token_nl$descriptor() {
        return llama_token_nl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_token_nl(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_token_nl$handle() {
        return llama_token_nl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_token_nl(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_token_nl$address() {
        return llama_token_nl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_token_nl(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_token_nl(MemorySegment vocab) {
        var mh$ = llama_token_nl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_nl", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_pad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_pad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_token_pad(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_token_pad$descriptor() {
        return llama_token_pad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_token_pad(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_token_pad$handle() {
        return llama_token_pad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_token_pad(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_token_pad$address() {
        return llama_token_pad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_token_pad(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_token_pad(MemorySegment vocab) {
        var mh$ = llama_token_pad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_pad", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_add_bos_token {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_add_bos_token");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_add_bos_token(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_add_bos_token$descriptor() {
        return llama_add_bos_token.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_add_bos_token(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_add_bos_token$handle() {
        return llama_add_bos_token.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_add_bos_token(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_add_bos_token$address() {
        return llama_add_bos_token.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_add_bos_token(const struct llama_vocab *vocab)
     * }
     */
    public static boolean llama_add_bos_token(MemorySegment vocab) {
        var mh$ = llama_add_bos_token.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_add_bos_token", vocab);
            }
            return (boolean)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_add_eos_token {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_add_eos_token");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_add_eos_token(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_add_eos_token$descriptor() {
        return llama_add_eos_token.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_add_eos_token(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_add_eos_token$handle() {
        return llama_add_eos_token.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_add_eos_token(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_add_eos_token$address() {
        return llama_add_eos_token.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_add_eos_token(const struct llama_vocab *vocab)
     * }
     */
    public static boolean llama_add_eos_token(MemorySegment vocab) {
        var mh$ = llama_add_eos_token.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_add_eos_token", vocab);
            }
            return (boolean)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_fim_pre {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_fim_pre");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_token_fim_pre(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_token_fim_pre$descriptor() {
        return llama_token_fim_pre.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_token_fim_pre(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_token_fim_pre$handle() {
        return llama_token_fim_pre.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_token_fim_pre(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_token_fim_pre$address() {
        return llama_token_fim_pre.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_token_fim_pre(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_token_fim_pre(MemorySegment vocab) {
        var mh$ = llama_token_fim_pre.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_fim_pre", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_fim_suf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_fim_suf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_token_fim_suf(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_token_fim_suf$descriptor() {
        return llama_token_fim_suf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_token_fim_suf(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_token_fim_suf$handle() {
        return llama_token_fim_suf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_token_fim_suf(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_token_fim_suf$address() {
        return llama_token_fim_suf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_token_fim_suf(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_token_fim_suf(MemorySegment vocab) {
        var mh$ = llama_token_fim_suf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_fim_suf", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_fim_mid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_fim_mid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_token_fim_mid(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_token_fim_mid$descriptor() {
        return llama_token_fim_mid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_token_fim_mid(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_token_fim_mid$handle() {
        return llama_token_fim_mid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_token_fim_mid(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_token_fim_mid$address() {
        return llama_token_fim_mid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_token_fim_mid(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_token_fim_mid(MemorySegment vocab) {
        var mh$ = llama_token_fim_mid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_fim_mid", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_fim_pad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_fim_pad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_token_fim_pad(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_token_fim_pad$descriptor() {
        return llama_token_fim_pad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_token_fim_pad(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_token_fim_pad$handle() {
        return llama_token_fim_pad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_token_fim_pad(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_token_fim_pad$address() {
        return llama_token_fim_pad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_token_fim_pad(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_token_fim_pad(MemorySegment vocab) {
        var mh$ = llama_token_fim_pad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_fim_pad", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_fim_rep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_fim_rep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_token_fim_rep(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_token_fim_rep$descriptor() {
        return llama_token_fim_rep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_token_fim_rep(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_token_fim_rep$handle() {
        return llama_token_fim_rep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_token_fim_rep(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_token_fim_rep$address() {
        return llama_token_fim_rep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_token_fim_rep(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_token_fim_rep(MemorySegment vocab) {
        var mh$ = llama_token_fim_rep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_fim_rep", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_fim_sep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_fim_sep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_token_fim_sep(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_token_fim_sep$descriptor() {
        return llama_token_fim_sep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_token_fim_sep(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_token_fim_sep$handle() {
        return llama_token_fim_sep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_token_fim_sep(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_token_fim_sep$address() {
        return llama_token_fim_sep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_token_fim_sep(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_token_fim_sep(MemorySegment vocab) {
        var mh$ = llama_token_fim_sep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_fim_sep", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_vocab_cls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_vocab_cls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_vocab_cls(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_vocab_cls$descriptor() {
        return llama_vocab_cls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_vocab_cls(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_vocab_cls$handle() {
        return llama_vocab_cls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_vocab_cls(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_vocab_cls$address() {
        return llama_vocab_cls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_vocab_cls(const struct llama_vocab *vocab)
     * }
     */
    public static int llama_vocab_cls(MemorySegment vocab) {
        var mh$ = llama_vocab_cls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_vocab_cls", vocab);
            }
            return (int)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_tokenize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_BOOL,
            llama_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_tokenize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_tokenize(const struct llama_vocab *vocab, const char *text, int32_t text_len, llama_token *tokens, int32_t n_tokens_max, bool add_special, bool parse_special)
     * }
     */
    public static FunctionDescriptor llama_tokenize$descriptor() {
        return llama_tokenize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_tokenize(const struct llama_vocab *vocab, const char *text, int32_t text_len, llama_token *tokens, int32_t n_tokens_max, bool add_special, bool parse_special)
     * }
     */
    public static MethodHandle llama_tokenize$handle() {
        return llama_tokenize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_tokenize(const struct llama_vocab *vocab, const char *text, int32_t text_len, llama_token *tokens, int32_t n_tokens_max, bool add_special, bool parse_special)
     * }
     */
    public static MemorySegment llama_tokenize$address() {
        return llama_tokenize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_tokenize(const struct llama_vocab *vocab, const char *text, int32_t text_len, llama_token *tokens, int32_t n_tokens_max, bool add_special, bool parse_special)
     * }
     */
    public static int llama_tokenize(MemorySegment vocab, MemorySegment text, int text_len, MemorySegment tokens, int n_tokens_max, boolean add_special, boolean parse_special) {
        var mh$ = llama_tokenize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_tokenize", vocab, text, text_len, tokens, n_tokens_max, add_special, parse_special);
            }
            return (int)mh$.invokeExact(vocab, text, text_len, tokens, n_tokens_max, add_special, parse_special);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_token_to_piece {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_token_to_piece");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_token_to_piece(const struct llama_vocab *vocab, llama_token token, char *buf, int32_t length, int32_t lstrip, bool special)
     * }
     */
    public static FunctionDescriptor llama_token_to_piece$descriptor() {
        return llama_token_to_piece.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_token_to_piece(const struct llama_vocab *vocab, llama_token token, char *buf, int32_t length, int32_t lstrip, bool special)
     * }
     */
    public static MethodHandle llama_token_to_piece$handle() {
        return llama_token_to_piece.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_token_to_piece(const struct llama_vocab *vocab, llama_token token, char *buf, int32_t length, int32_t lstrip, bool special)
     * }
     */
    public static MemorySegment llama_token_to_piece$address() {
        return llama_token_to_piece.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_token_to_piece(const struct llama_vocab *vocab, llama_token token, char *buf, int32_t length, int32_t lstrip, bool special)
     * }
     */
    public static int llama_token_to_piece(MemorySegment vocab, int token, MemorySegment buf, int length, int lstrip, boolean special) {
        var mh$ = llama_token_to_piece.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_token_to_piece", vocab, token, buf, length, lstrip, special);
            }
            return (int)mh$.invokeExact(vocab, token, buf, length, lstrip, special);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_detokenize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_BOOL,
            llama_h.C_BOOL
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_detokenize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_detokenize(const struct llama_vocab *vocab, const llama_token *tokens, int32_t n_tokens, char *text, int32_t text_len_max, bool remove_special, bool unparse_special)
     * }
     */
    public static FunctionDescriptor llama_detokenize$descriptor() {
        return llama_detokenize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_detokenize(const struct llama_vocab *vocab, const llama_token *tokens, int32_t n_tokens, char *text, int32_t text_len_max, bool remove_special, bool unparse_special)
     * }
     */
    public static MethodHandle llama_detokenize$handle() {
        return llama_detokenize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_detokenize(const struct llama_vocab *vocab, const llama_token *tokens, int32_t n_tokens, char *text, int32_t text_len_max, bool remove_special, bool unparse_special)
     * }
     */
    public static MemorySegment llama_detokenize$address() {
        return llama_detokenize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_detokenize(const struct llama_vocab *vocab, const llama_token *tokens, int32_t n_tokens, char *text, int32_t text_len_max, bool remove_special, bool unparse_special)
     * }
     */
    public static int llama_detokenize(MemorySegment vocab, MemorySegment tokens, int n_tokens, MemorySegment text, int text_len_max, boolean remove_special, boolean unparse_special) {
        var mh$ = llama_detokenize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_detokenize", vocab, tokens, n_tokens, text, text_len_max, remove_special, unparse_special);
            }
            return (int)mh$.invokeExact(vocab, tokens, n_tokens, text, text_len_max, remove_special, unparse_special);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_chat_apply_template {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_chat_apply_template");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_chat_apply_template(const char *tmpl, const struct llama_chat_message *chat, size_t n_msg, bool add_ass, char *buf, int32_t length)
     * }
     */
    public static FunctionDescriptor llama_chat_apply_template$descriptor() {
        return llama_chat_apply_template.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_chat_apply_template(const char *tmpl, const struct llama_chat_message *chat, size_t n_msg, bool add_ass, char *buf, int32_t length)
     * }
     */
    public static MethodHandle llama_chat_apply_template$handle() {
        return llama_chat_apply_template.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_chat_apply_template(const char *tmpl, const struct llama_chat_message *chat, size_t n_msg, bool add_ass, char *buf, int32_t length)
     * }
     */
    public static MemorySegment llama_chat_apply_template$address() {
        return llama_chat_apply_template.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_chat_apply_template(const char *tmpl, const struct llama_chat_message *chat, size_t n_msg, bool add_ass, char *buf, int32_t length)
     * }
     */
    public static int llama_chat_apply_template(MemorySegment tmpl, MemorySegment chat, long n_msg, boolean add_ass, MemorySegment buf, int length) {
        var mh$ = llama_chat_apply_template.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_chat_apply_template", tmpl, chat, n_msg, add_ass, buf, length);
            }
            return (int)mh$.invokeExact(tmpl, chat, n_msg, add_ass, buf, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_chat_builtin_templates {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_chat_builtin_templates");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t llama_chat_builtin_templates(const char **output, size_t len)
     * }
     */
    public static FunctionDescriptor llama_chat_builtin_templates$descriptor() {
        return llama_chat_builtin_templates.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t llama_chat_builtin_templates(const char **output, size_t len)
     * }
     */
    public static MethodHandle llama_chat_builtin_templates$handle() {
        return llama_chat_builtin_templates.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t llama_chat_builtin_templates(const char **output, size_t len)
     * }
     */
    public static MemorySegment llama_chat_builtin_templates$address() {
        return llama_chat_builtin_templates.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t llama_chat_builtin_templates(const char **output, size_t len)
     * }
     */
    public static int llama_chat_builtin_templates(MemorySegment output, long len) {
        var mh$ = llama_chat_builtin_templates.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_chat_builtin_templates", output, len);
            }
            return (int)mh$.invokeExact(output, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *llama_sampler_context_t
     * }
     */
    public static final AddressLayout llama_sampler_context_t = llama_h.C_POINTER;

    private static class llama_sampler_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init(const struct llama_sampler_i *iface, llama_sampler_context_t ctx)
     * }
     */
    public static FunctionDescriptor llama_sampler_init$descriptor() {
        return llama_sampler_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init(const struct llama_sampler_i *iface, llama_sampler_context_t ctx)
     * }
     */
    public static MethodHandle llama_sampler_init$handle() {
        return llama_sampler_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init(const struct llama_sampler_i *iface, llama_sampler_context_t ctx)
     * }
     */
    public static MemorySegment llama_sampler_init$address() {
        return llama_sampler_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init(const struct llama_sampler_i *iface, llama_sampler_context_t ctx)
     * }
     */
    public static MemorySegment llama_sampler_init(MemorySegment iface, MemorySegment ctx) {
        var mh$ = llama_sampler_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init", iface, ctx);
            }
            return (MemorySegment)mh$.invokeExact(iface, ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *llama_sampler_name(const struct llama_sampler *smpl)
     * }
     */
    public static FunctionDescriptor llama_sampler_name$descriptor() {
        return llama_sampler_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *llama_sampler_name(const struct llama_sampler *smpl)
     * }
     */
    public static MethodHandle llama_sampler_name$handle() {
        return llama_sampler_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *llama_sampler_name(const struct llama_sampler *smpl)
     * }
     */
    public static MemorySegment llama_sampler_name$address() {
        return llama_sampler_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *llama_sampler_name(const struct llama_sampler *smpl)
     * }
     */
    public static MemorySegment llama_sampler_name(MemorySegment smpl) {
        var mh$ = llama_sampler_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_name", smpl);
            }
            return (MemorySegment)mh$.invokeExact(smpl);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_accept {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_accept");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_sampler_accept(struct llama_sampler *smpl, llama_token token)
     * }
     */
    public static FunctionDescriptor llama_sampler_accept$descriptor() {
        return llama_sampler_accept.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_sampler_accept(struct llama_sampler *smpl, llama_token token)
     * }
     */
    public static MethodHandle llama_sampler_accept$handle() {
        return llama_sampler_accept.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_sampler_accept(struct llama_sampler *smpl, llama_token token)
     * }
     */
    public static MemorySegment llama_sampler_accept$address() {
        return llama_sampler_accept.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_sampler_accept(struct llama_sampler *smpl, llama_token token)
     * }
     */
    public static void llama_sampler_accept(MemorySegment smpl, int token) {
        var mh$ = llama_sampler_accept.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_accept", smpl, token);
            }
            mh$.invokeExact(smpl, token);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_apply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_apply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_sampler_apply(struct llama_sampler *smpl, llama_token_data_array *cur_p)
     * }
     */
    public static FunctionDescriptor llama_sampler_apply$descriptor() {
        return llama_sampler_apply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_sampler_apply(struct llama_sampler *smpl, llama_token_data_array *cur_p)
     * }
     */
    public static MethodHandle llama_sampler_apply$handle() {
        return llama_sampler_apply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_sampler_apply(struct llama_sampler *smpl, llama_token_data_array *cur_p)
     * }
     */
    public static MemorySegment llama_sampler_apply$address() {
        return llama_sampler_apply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_sampler_apply(struct llama_sampler *smpl, llama_token_data_array *cur_p)
     * }
     */
    public static void llama_sampler_apply(MemorySegment smpl, MemorySegment cur_p) {
        var mh$ = llama_sampler_apply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_apply", smpl, cur_p);
            }
            mh$.invokeExact(smpl, cur_p);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_sampler_reset(struct llama_sampler *smpl)
     * }
     */
    public static FunctionDescriptor llama_sampler_reset$descriptor() {
        return llama_sampler_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_sampler_reset(struct llama_sampler *smpl)
     * }
     */
    public static MethodHandle llama_sampler_reset$handle() {
        return llama_sampler_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_sampler_reset(struct llama_sampler *smpl)
     * }
     */
    public static MemorySegment llama_sampler_reset$address() {
        return llama_sampler_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_sampler_reset(struct llama_sampler *smpl)
     * }
     */
    public static void llama_sampler_reset(MemorySegment smpl) {
        var mh$ = llama_sampler_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_reset", smpl);
            }
            mh$.invokeExact(smpl);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_clone(const struct llama_sampler *smpl)
     * }
     */
    public static FunctionDescriptor llama_sampler_clone$descriptor() {
        return llama_sampler_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_clone(const struct llama_sampler *smpl)
     * }
     */
    public static MethodHandle llama_sampler_clone$handle() {
        return llama_sampler_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_clone(const struct llama_sampler *smpl)
     * }
     */
    public static MemorySegment llama_sampler_clone$address() {
        return llama_sampler_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_clone(const struct llama_sampler *smpl)
     * }
     */
    public static MemorySegment llama_sampler_clone(MemorySegment smpl) {
        var mh$ = llama_sampler_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_clone", smpl);
            }
            return (MemorySegment)mh$.invokeExact(smpl);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_sampler_free(struct llama_sampler *smpl)
     * }
     */
    public static FunctionDescriptor llama_sampler_free$descriptor() {
        return llama_sampler_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_sampler_free(struct llama_sampler *smpl)
     * }
     */
    public static MethodHandle llama_sampler_free$handle() {
        return llama_sampler_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_sampler_free(struct llama_sampler *smpl)
     * }
     */
    public static MemorySegment llama_sampler_free$address() {
        return llama_sampler_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_sampler_free(struct llama_sampler *smpl)
     * }
     */
    public static void llama_sampler_free(MemorySegment smpl) {
        var mh$ = llama_sampler_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_free", smpl);
            }
            mh$.invokeExact(smpl);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_chain_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_sampler_chain_params.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_chain_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_chain_init(struct llama_sampler_chain_params params)
     * }
     */
    public static FunctionDescriptor llama_sampler_chain_init$descriptor() {
        return llama_sampler_chain_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_chain_init(struct llama_sampler_chain_params params)
     * }
     */
    public static MethodHandle llama_sampler_chain_init$handle() {
        return llama_sampler_chain_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_chain_init(struct llama_sampler_chain_params params)
     * }
     */
    public static MemorySegment llama_sampler_chain_init$address() {
        return llama_sampler_chain_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_chain_init(struct llama_sampler_chain_params params)
     * }
     */
    public static MemorySegment llama_sampler_chain_init(MemorySegment params) {
        var mh$ = llama_sampler_chain_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_chain_init", params);
            }
            return (MemorySegment)mh$.invokeExact(params);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_chain_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_chain_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_sampler_chain_add(struct llama_sampler *chain, struct llama_sampler *smpl)
     * }
     */
    public static FunctionDescriptor llama_sampler_chain_add$descriptor() {
        return llama_sampler_chain_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_sampler_chain_add(struct llama_sampler *chain, struct llama_sampler *smpl)
     * }
     */
    public static MethodHandle llama_sampler_chain_add$handle() {
        return llama_sampler_chain_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_sampler_chain_add(struct llama_sampler *chain, struct llama_sampler *smpl)
     * }
     */
    public static MemorySegment llama_sampler_chain_add$address() {
        return llama_sampler_chain_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_sampler_chain_add(struct llama_sampler *chain, struct llama_sampler *smpl)
     * }
     */
    public static void llama_sampler_chain_add(MemorySegment chain, MemorySegment smpl) {
        var mh$ = llama_sampler_chain_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_chain_add", chain, smpl);
            }
            mh$.invokeExact(chain, smpl);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_chain_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_chain_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_chain_get(const struct llama_sampler *chain, int32_t i)
     * }
     */
    public static FunctionDescriptor llama_sampler_chain_get$descriptor() {
        return llama_sampler_chain_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_chain_get(const struct llama_sampler *chain, int32_t i)
     * }
     */
    public static MethodHandle llama_sampler_chain_get$handle() {
        return llama_sampler_chain_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_chain_get(const struct llama_sampler *chain, int32_t i)
     * }
     */
    public static MemorySegment llama_sampler_chain_get$address() {
        return llama_sampler_chain_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_chain_get(const struct llama_sampler *chain, int32_t i)
     * }
     */
    public static MemorySegment llama_sampler_chain_get(MemorySegment chain, int i) {
        var mh$ = llama_sampler_chain_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_chain_get", chain, i);
            }
            return (MemorySegment)mh$.invokeExact(chain, i);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_chain_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_chain_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int llama_sampler_chain_n(const struct llama_sampler *chain)
     * }
     */
    public static FunctionDescriptor llama_sampler_chain_n$descriptor() {
        return llama_sampler_chain_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int llama_sampler_chain_n(const struct llama_sampler *chain)
     * }
     */
    public static MethodHandle llama_sampler_chain_n$handle() {
        return llama_sampler_chain_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int llama_sampler_chain_n(const struct llama_sampler *chain)
     * }
     */
    public static MemorySegment llama_sampler_chain_n$address() {
        return llama_sampler_chain_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int llama_sampler_chain_n(const struct llama_sampler *chain)
     * }
     */
    public static int llama_sampler_chain_n(MemorySegment chain) {
        var mh$ = llama_sampler_chain_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_chain_n", chain);
            }
            return (int)mh$.invokeExact(chain);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_chain_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_chain_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_chain_remove(struct llama_sampler *chain, int32_t i)
     * }
     */
    public static FunctionDescriptor llama_sampler_chain_remove$descriptor() {
        return llama_sampler_chain_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_chain_remove(struct llama_sampler *chain, int32_t i)
     * }
     */
    public static MethodHandle llama_sampler_chain_remove$handle() {
        return llama_sampler_chain_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_chain_remove(struct llama_sampler *chain, int32_t i)
     * }
     */
    public static MemorySegment llama_sampler_chain_remove$address() {
        return llama_sampler_chain_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_chain_remove(struct llama_sampler *chain, int32_t i)
     * }
     */
    public static MemorySegment llama_sampler_chain_remove(MemorySegment chain, int i) {
        var mh$ = llama_sampler_chain_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_chain_remove", chain, i);
            }
            return (MemorySegment)mh$.invokeExact(chain, i);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_greedy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_greedy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_greedy(void)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_greedy$descriptor() {
        return llama_sampler_init_greedy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_greedy(void)
     * }
     */
    public static MethodHandle llama_sampler_init_greedy$handle() {
        return llama_sampler_init_greedy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_greedy(void)
     * }
     */
    public static MemorySegment llama_sampler_init_greedy$address() {
        return llama_sampler_init_greedy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_greedy(void)
     * }
     */
    public static MemorySegment llama_sampler_init_greedy() {
        var mh$ = llama_sampler_init_greedy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_greedy");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_dist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_dist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_dist(uint32_t seed)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_dist$descriptor() {
        return llama_sampler_init_dist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_dist(uint32_t seed)
     * }
     */
    public static MethodHandle llama_sampler_init_dist$handle() {
        return llama_sampler_init_dist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_dist(uint32_t seed)
     * }
     */
    public static MemorySegment llama_sampler_init_dist$address() {
        return llama_sampler_init_dist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_dist(uint32_t seed)
     * }
     */
    public static MemorySegment llama_sampler_init_dist(int seed) {
        var mh$ = llama_sampler_init_dist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_dist", seed);
            }
            return (MemorySegment)mh$.invokeExact(seed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_softmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_softmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_softmax(void)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_softmax$descriptor() {
        return llama_sampler_init_softmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_softmax(void)
     * }
     */
    public static MethodHandle llama_sampler_init_softmax$handle() {
        return llama_sampler_init_softmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_softmax(void)
     * }
     */
    public static MemorySegment llama_sampler_init_softmax$address() {
        return llama_sampler_init_softmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_softmax(void)
     * }
     */
    public static MemorySegment llama_sampler_init_softmax() {
        var mh$ = llama_sampler_init_softmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_softmax");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_top_k {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_top_k");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_top_k(int32_t k)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_top_k$descriptor() {
        return llama_sampler_init_top_k.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_top_k(int32_t k)
     * }
     */
    public static MethodHandle llama_sampler_init_top_k$handle() {
        return llama_sampler_init_top_k.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_top_k(int32_t k)
     * }
     */
    public static MemorySegment llama_sampler_init_top_k$address() {
        return llama_sampler_init_top_k.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_top_k(int32_t k)
     * }
     */
    public static MemorySegment llama_sampler_init_top_k(int k) {
        var mh$ = llama_sampler_init_top_k.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_top_k", k);
            }
            return (MemorySegment)mh$.invokeExact(k);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_top_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_FLOAT,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_top_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_top_p(float p, size_t min_keep)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_top_p$descriptor() {
        return llama_sampler_init_top_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_top_p(float p, size_t min_keep)
     * }
     */
    public static MethodHandle llama_sampler_init_top_p$handle() {
        return llama_sampler_init_top_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_top_p(float p, size_t min_keep)
     * }
     */
    public static MemorySegment llama_sampler_init_top_p$address() {
        return llama_sampler_init_top_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_top_p(float p, size_t min_keep)
     * }
     */
    public static MemorySegment llama_sampler_init_top_p(float p, long min_keep) {
        var mh$ = llama_sampler_init_top_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_top_p", p, min_keep);
            }
            return (MemorySegment)mh$.invokeExact(p, min_keep);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_min_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_FLOAT,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_min_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_min_p(float p, size_t min_keep)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_min_p$descriptor() {
        return llama_sampler_init_min_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_min_p(float p, size_t min_keep)
     * }
     */
    public static MethodHandle llama_sampler_init_min_p$handle() {
        return llama_sampler_init_min_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_min_p(float p, size_t min_keep)
     * }
     */
    public static MemorySegment llama_sampler_init_min_p$address() {
        return llama_sampler_init_min_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_min_p(float p, size_t min_keep)
     * }
     */
    public static MemorySegment llama_sampler_init_min_p(float p, long min_keep) {
        var mh$ = llama_sampler_init_min_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_min_p", p, min_keep);
            }
            return (MemorySegment)mh$.invokeExact(p, min_keep);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_typical {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_FLOAT,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_typical");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_typical(float p, size_t min_keep)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_typical$descriptor() {
        return llama_sampler_init_typical.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_typical(float p, size_t min_keep)
     * }
     */
    public static MethodHandle llama_sampler_init_typical$handle() {
        return llama_sampler_init_typical.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_typical(float p, size_t min_keep)
     * }
     */
    public static MemorySegment llama_sampler_init_typical$address() {
        return llama_sampler_init_typical.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_typical(float p, size_t min_keep)
     * }
     */
    public static MemorySegment llama_sampler_init_typical(float p, long min_keep) {
        var mh$ = llama_sampler_init_typical.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_typical", p, min_keep);
            }
            return (MemorySegment)mh$.invokeExact(p, min_keep);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_temp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_temp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_temp(float t)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_temp$descriptor() {
        return llama_sampler_init_temp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_temp(float t)
     * }
     */
    public static MethodHandle llama_sampler_init_temp$handle() {
        return llama_sampler_init_temp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_temp(float t)
     * }
     */
    public static MemorySegment llama_sampler_init_temp$address() {
        return llama_sampler_init_temp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_temp(float t)
     * }
     */
    public static MemorySegment llama_sampler_init_temp(float t) {
        var mh$ = llama_sampler_init_temp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_temp", t);
            }
            return (MemorySegment)mh$.invokeExact(t);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_temp_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_temp_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_temp_ext(float t, float delta, float exponent)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_temp_ext$descriptor() {
        return llama_sampler_init_temp_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_temp_ext(float t, float delta, float exponent)
     * }
     */
    public static MethodHandle llama_sampler_init_temp_ext$handle() {
        return llama_sampler_init_temp_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_temp_ext(float t, float delta, float exponent)
     * }
     */
    public static MemorySegment llama_sampler_init_temp_ext$address() {
        return llama_sampler_init_temp_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_temp_ext(float t, float delta, float exponent)
     * }
     */
    public static MemorySegment llama_sampler_init_temp_ext(float t, float delta, float exponent) {
        var mh$ = llama_sampler_init_temp_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_temp_ext", t, delta, exponent);
            }
            return (MemorySegment)mh$.invokeExact(t, delta, exponent);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_xtc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_LONG,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_xtc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_xtc(float p, float t, size_t min_keep, uint32_t seed)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_xtc$descriptor() {
        return llama_sampler_init_xtc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_xtc(float p, float t, size_t min_keep, uint32_t seed)
     * }
     */
    public static MethodHandle llama_sampler_init_xtc$handle() {
        return llama_sampler_init_xtc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_xtc(float p, float t, size_t min_keep, uint32_t seed)
     * }
     */
    public static MemorySegment llama_sampler_init_xtc$address() {
        return llama_sampler_init_xtc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_xtc(float p, float t, size_t min_keep, uint32_t seed)
     * }
     */
    public static MemorySegment llama_sampler_init_xtc(float p, float t, long min_keep, int seed) {
        var mh$ = llama_sampler_init_xtc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_xtc", p, t, min_keep, seed);
            }
            return (MemorySegment)mh$.invokeExact(p, t, min_keep, seed);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_top_n_sigma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_top_n_sigma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_top_n_sigma(float n)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_top_n_sigma$descriptor() {
        return llama_sampler_init_top_n_sigma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_top_n_sigma(float n)
     * }
     */
    public static MethodHandle llama_sampler_init_top_n_sigma$handle() {
        return llama_sampler_init_top_n_sigma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_top_n_sigma(float n)
     * }
     */
    public static MemorySegment llama_sampler_init_top_n_sigma$address() {
        return llama_sampler_init_top_n_sigma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_top_n_sigma(float n)
     * }
     */
    public static MemorySegment llama_sampler_init_top_n_sigma(float n) {
        var mh$ = llama_sampler_init_top_n_sigma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_top_n_sigma", n);
            }
            return (MemorySegment)mh$.invokeExact(n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_mirostat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_mirostat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_mirostat(int32_t n_vocab, uint32_t seed, float tau, float eta, int32_t m)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_mirostat$descriptor() {
        return llama_sampler_init_mirostat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_mirostat(int32_t n_vocab, uint32_t seed, float tau, float eta, int32_t m)
     * }
     */
    public static MethodHandle llama_sampler_init_mirostat$handle() {
        return llama_sampler_init_mirostat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_mirostat(int32_t n_vocab, uint32_t seed, float tau, float eta, int32_t m)
     * }
     */
    public static MemorySegment llama_sampler_init_mirostat$address() {
        return llama_sampler_init_mirostat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_mirostat(int32_t n_vocab, uint32_t seed, float tau, float eta, int32_t m)
     * }
     */
    public static MemorySegment llama_sampler_init_mirostat(int n_vocab, int seed, float tau, float eta, int m) {
        var mh$ = llama_sampler_init_mirostat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_mirostat", n_vocab, seed, tau, eta, m);
            }
            return (MemorySegment)mh$.invokeExact(n_vocab, seed, tau, eta, m);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_mirostat_v2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_mirostat_v2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_mirostat_v2(uint32_t seed, float tau, float eta)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_mirostat_v2$descriptor() {
        return llama_sampler_init_mirostat_v2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_mirostat_v2(uint32_t seed, float tau, float eta)
     * }
     */
    public static MethodHandle llama_sampler_init_mirostat_v2$handle() {
        return llama_sampler_init_mirostat_v2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_mirostat_v2(uint32_t seed, float tau, float eta)
     * }
     */
    public static MemorySegment llama_sampler_init_mirostat_v2$address() {
        return llama_sampler_init_mirostat_v2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_mirostat_v2(uint32_t seed, float tau, float eta)
     * }
     */
    public static MemorySegment llama_sampler_init_mirostat_v2(int seed, float tau, float eta) {
        var mh$ = llama_sampler_init_mirostat_v2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_mirostat_v2", seed, tau, eta);
            }
            return (MemorySegment)mh$.invokeExact(seed, tau, eta);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_grammar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_grammar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_grammar(const struct llama_vocab *vocab, const char *grammar_str, const char *grammar_root)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_grammar$descriptor() {
        return llama_sampler_init_grammar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_grammar(const struct llama_vocab *vocab, const char *grammar_str, const char *grammar_root)
     * }
     */
    public static MethodHandle llama_sampler_init_grammar$handle() {
        return llama_sampler_init_grammar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_grammar(const struct llama_vocab *vocab, const char *grammar_str, const char *grammar_root)
     * }
     */
    public static MemorySegment llama_sampler_init_grammar$address() {
        return llama_sampler_init_grammar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_grammar(const struct llama_vocab *vocab, const char *grammar_str, const char *grammar_root)
     * }
     */
    public static MemorySegment llama_sampler_init_grammar(MemorySegment vocab, MemorySegment grammar_str, MemorySegment grammar_root) {
        var mh$ = llama_sampler_init_grammar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_grammar", vocab, grammar_str, grammar_root);
            }
            return (MemorySegment)mh$.invokeExact(vocab, grammar_str, grammar_root);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_grammar_lazy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_grammar_lazy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_grammar_lazy(const struct llama_vocab *vocab, const char *grammar_str, const char *grammar_root, const char **trigger_words, size_t num_trigger_words, const llama_token *trigger_tokens, size_t num_trigger_tokens)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_grammar_lazy$descriptor() {
        return llama_sampler_init_grammar_lazy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_grammar_lazy(const struct llama_vocab *vocab, const char *grammar_str, const char *grammar_root, const char **trigger_words, size_t num_trigger_words, const llama_token *trigger_tokens, size_t num_trigger_tokens)
     * }
     */
    public static MethodHandle llama_sampler_init_grammar_lazy$handle() {
        return llama_sampler_init_grammar_lazy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_grammar_lazy(const struct llama_vocab *vocab, const char *grammar_str, const char *grammar_root, const char **trigger_words, size_t num_trigger_words, const llama_token *trigger_tokens, size_t num_trigger_tokens)
     * }
     */
    public static MemorySegment llama_sampler_init_grammar_lazy$address() {
        return llama_sampler_init_grammar_lazy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_grammar_lazy(const struct llama_vocab *vocab, const char *grammar_str, const char *grammar_root, const char **trigger_words, size_t num_trigger_words, const llama_token *trigger_tokens, size_t num_trigger_tokens)
     * }
     */
    public static MemorySegment llama_sampler_init_grammar_lazy(MemorySegment vocab, MemorySegment grammar_str, MemorySegment grammar_root, MemorySegment trigger_words, long num_trigger_words, MemorySegment trigger_tokens, long num_trigger_tokens) {
        var mh$ = llama_sampler_init_grammar_lazy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_grammar_lazy", vocab, grammar_str, grammar_root, trigger_words, num_trigger_words, trigger_tokens, num_trigger_tokens);
            }
            return (MemorySegment)mh$.invokeExact(vocab, grammar_str, grammar_root, trigger_words, num_trigger_words, trigger_tokens, num_trigger_tokens);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_grammar_lazy_patterns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_grammar_lazy_patterns");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_grammar_lazy_patterns(const struct llama_vocab *vocab, const char *grammar_str, const char *grammar_root, const char **trigger_patterns, size_t num_trigger_patterns, const llama_token *trigger_tokens, size_t num_trigger_tokens)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_grammar_lazy_patterns$descriptor() {
        return llama_sampler_init_grammar_lazy_patterns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_grammar_lazy_patterns(const struct llama_vocab *vocab, const char *grammar_str, const char *grammar_root, const char **trigger_patterns, size_t num_trigger_patterns, const llama_token *trigger_tokens, size_t num_trigger_tokens)
     * }
     */
    public static MethodHandle llama_sampler_init_grammar_lazy_patterns$handle() {
        return llama_sampler_init_grammar_lazy_patterns.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_grammar_lazy_patterns(const struct llama_vocab *vocab, const char *grammar_str, const char *grammar_root, const char **trigger_patterns, size_t num_trigger_patterns, const llama_token *trigger_tokens, size_t num_trigger_tokens)
     * }
     */
    public static MemorySegment llama_sampler_init_grammar_lazy_patterns$address() {
        return llama_sampler_init_grammar_lazy_patterns.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_grammar_lazy_patterns(const struct llama_vocab *vocab, const char *grammar_str, const char *grammar_root, const char **trigger_patterns, size_t num_trigger_patterns, const llama_token *trigger_tokens, size_t num_trigger_tokens)
     * }
     */
    public static MemorySegment llama_sampler_init_grammar_lazy_patterns(MemorySegment vocab, MemorySegment grammar_str, MemorySegment grammar_root, MemorySegment trigger_patterns, long num_trigger_patterns, MemorySegment trigger_tokens, long num_trigger_tokens) {
        var mh$ = llama_sampler_init_grammar_lazy_patterns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_grammar_lazy_patterns", vocab, grammar_str, grammar_root, trigger_patterns, num_trigger_patterns, trigger_tokens, num_trigger_tokens);
            }
            return (MemorySegment)mh$.invokeExact(vocab, grammar_str, grammar_root, trigger_patterns, num_trigger_patterns, trigger_tokens, num_trigger_tokens);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_penalties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_penalties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_penalties(int32_t penalty_last_n, float penalty_repeat, float penalty_freq, float penalty_present)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_penalties$descriptor() {
        return llama_sampler_init_penalties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_penalties(int32_t penalty_last_n, float penalty_repeat, float penalty_freq, float penalty_present)
     * }
     */
    public static MethodHandle llama_sampler_init_penalties$handle() {
        return llama_sampler_init_penalties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_penalties(int32_t penalty_last_n, float penalty_repeat, float penalty_freq, float penalty_present)
     * }
     */
    public static MemorySegment llama_sampler_init_penalties$address() {
        return llama_sampler_init_penalties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_penalties(int32_t penalty_last_n, float penalty_repeat, float penalty_freq, float penalty_present)
     * }
     */
    public static MemorySegment llama_sampler_init_penalties(int penalty_last_n, float penalty_repeat, float penalty_freq, float penalty_present) {
        var mh$ = llama_sampler_init_penalties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_penalties", penalty_last_n, penalty_repeat, penalty_freq, penalty_present);
            }
            return (MemorySegment)mh$.invokeExact(penalty_last_n, penalty_repeat, penalty_freq, penalty_present);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_dry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_FLOAT,
            llama_h.C_FLOAT,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_dry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_dry(const struct llama_vocab *vocab, int32_t n_ctx_train, float dry_multiplier, float dry_base, int32_t dry_allowed_length, int32_t dry_penalty_last_n, const char **seq_breakers, size_t num_breakers)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_dry$descriptor() {
        return llama_sampler_init_dry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_dry(const struct llama_vocab *vocab, int32_t n_ctx_train, float dry_multiplier, float dry_base, int32_t dry_allowed_length, int32_t dry_penalty_last_n, const char **seq_breakers, size_t num_breakers)
     * }
     */
    public static MethodHandle llama_sampler_init_dry$handle() {
        return llama_sampler_init_dry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_dry(const struct llama_vocab *vocab, int32_t n_ctx_train, float dry_multiplier, float dry_base, int32_t dry_allowed_length, int32_t dry_penalty_last_n, const char **seq_breakers, size_t num_breakers)
     * }
     */
    public static MemorySegment llama_sampler_init_dry$address() {
        return llama_sampler_init_dry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_dry(const struct llama_vocab *vocab, int32_t n_ctx_train, float dry_multiplier, float dry_base, int32_t dry_allowed_length, int32_t dry_penalty_last_n, const char **seq_breakers, size_t num_breakers)
     * }
     */
    public static MemorySegment llama_sampler_init_dry(MemorySegment vocab, int n_ctx_train, float dry_multiplier, float dry_base, int dry_allowed_length, int dry_penalty_last_n, MemorySegment seq_breakers, long num_breakers) {
        var mh$ = llama_sampler_init_dry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_dry", vocab, n_ctx_train, dry_multiplier, dry_base, dry_allowed_length, dry_penalty_last_n, seq_breakers, num_breakers);
            }
            return (MemorySegment)mh$.invokeExact(vocab, n_ctx_train, dry_multiplier, dry_base, dry_allowed_length, dry_penalty_last_n, seq_breakers, num_breakers);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_logit_bias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_logit_bias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_logit_bias(int32_t n_vocab, int32_t n_logit_bias, const llama_logit_bias *logit_bias)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_logit_bias$descriptor() {
        return llama_sampler_init_logit_bias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_logit_bias(int32_t n_vocab, int32_t n_logit_bias, const llama_logit_bias *logit_bias)
     * }
     */
    public static MethodHandle llama_sampler_init_logit_bias$handle() {
        return llama_sampler_init_logit_bias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_logit_bias(int32_t n_vocab, int32_t n_logit_bias, const llama_logit_bias *logit_bias)
     * }
     */
    public static MemorySegment llama_sampler_init_logit_bias$address() {
        return llama_sampler_init_logit_bias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_logit_bias(int32_t n_vocab, int32_t n_logit_bias, const llama_logit_bias *logit_bias)
     * }
     */
    public static MemorySegment llama_sampler_init_logit_bias(int n_vocab, int n_logit_bias, MemorySegment logit_bias) {
        var mh$ = llama_sampler_init_logit_bias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_logit_bias", n_vocab, n_logit_bias, logit_bias);
            }
            return (MemorySegment)mh$.invokeExact(n_vocab, n_logit_bias, logit_bias);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_init_infill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_init_infill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_infill(const struct llama_vocab *vocab)
     * }
     */
    public static FunctionDescriptor llama_sampler_init_infill$descriptor() {
        return llama_sampler_init_infill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_infill(const struct llama_vocab *vocab)
     * }
     */
    public static MethodHandle llama_sampler_init_infill$handle() {
        return llama_sampler_init_infill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_infill(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_sampler_init_infill$address() {
        return llama_sampler_init_infill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_sampler *llama_sampler_init_infill(const struct llama_vocab *vocab)
     * }
     */
    public static MemorySegment llama_sampler_init_infill(MemorySegment vocab) {
        var mh$ = llama_sampler_init_infill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_init_infill", vocab);
            }
            return (MemorySegment)mh$.invokeExact(vocab);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_get_seed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_get_seed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t llama_sampler_get_seed(const struct llama_sampler *smpl)
     * }
     */
    public static FunctionDescriptor llama_sampler_get_seed$descriptor() {
        return llama_sampler_get_seed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t llama_sampler_get_seed(const struct llama_sampler *smpl)
     * }
     */
    public static MethodHandle llama_sampler_get_seed$handle() {
        return llama_sampler_get_seed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t llama_sampler_get_seed(const struct llama_sampler *smpl)
     * }
     */
    public static MemorySegment llama_sampler_get_seed$address() {
        return llama_sampler_get_seed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t llama_sampler_get_seed(const struct llama_sampler *smpl)
     * }
     */
    public static int llama_sampler_get_seed(MemorySegment smpl) {
        var mh$ = llama_sampler_get_seed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_get_seed", smpl);
            }
            return (int)mh$.invokeExact(smpl);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_sampler_sample {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_sampler_sample");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * llama_token llama_sampler_sample(struct llama_sampler *smpl, struct llama_context *ctx, int32_t idx)
     * }
     */
    public static FunctionDescriptor llama_sampler_sample$descriptor() {
        return llama_sampler_sample.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * llama_token llama_sampler_sample(struct llama_sampler *smpl, struct llama_context *ctx, int32_t idx)
     * }
     */
    public static MethodHandle llama_sampler_sample$handle() {
        return llama_sampler_sample.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * llama_token llama_sampler_sample(struct llama_sampler *smpl, struct llama_context *ctx, int32_t idx)
     * }
     */
    public static MemorySegment llama_sampler_sample$address() {
        return llama_sampler_sample.ADDR;
    }

    /**
     * {@snippet lang=c :
     * llama_token llama_sampler_sample(struct llama_sampler *smpl, struct llama_context *ctx, int32_t idx)
     * }
     */
    public static int llama_sampler_sample(MemorySegment smpl, MemorySegment ctx, int idx) {
        var mh$ = llama_sampler_sample.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_sampler_sample", smpl, ctx, idx);
            }
            return (int)mh$.invokeExact(smpl, ctx, idx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_split_path {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_split_path");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int llama_split_path(char *split_path, size_t maxlen, const char *path_prefix, int split_no, int split_count)
     * }
     */
    public static FunctionDescriptor llama_split_path$descriptor() {
        return llama_split_path.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int llama_split_path(char *split_path, size_t maxlen, const char *path_prefix, int split_no, int split_count)
     * }
     */
    public static MethodHandle llama_split_path$handle() {
        return llama_split_path.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int llama_split_path(char *split_path, size_t maxlen, const char *path_prefix, int split_no, int split_count)
     * }
     */
    public static MemorySegment llama_split_path$address() {
        return llama_split_path.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int llama_split_path(char *split_path, size_t maxlen, const char *path_prefix, int split_no, int split_count)
     * }
     */
    public static int llama_split_path(MemorySegment split_path, long maxlen, MemorySegment path_prefix, int split_no, int split_count) {
        var mh$ = llama_split_path.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_split_path", split_path, maxlen, path_prefix, split_no, split_count);
            }
            return (int)mh$.invokeExact(split_path, maxlen, path_prefix, split_no, split_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_split_prefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_INT,
            llama_h.C_POINTER,
            llama_h.C_LONG,
            llama_h.C_POINTER,
            llama_h.C_INT,
            llama_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_split_prefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int llama_split_prefix(char *split_prefix, size_t maxlen, const char *split_path, int split_no, int split_count)
     * }
     */
    public static FunctionDescriptor llama_split_prefix$descriptor() {
        return llama_split_prefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int llama_split_prefix(char *split_prefix, size_t maxlen, const char *split_path, int split_no, int split_count)
     * }
     */
    public static MethodHandle llama_split_prefix$handle() {
        return llama_split_prefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int llama_split_prefix(char *split_prefix, size_t maxlen, const char *split_path, int split_no, int split_count)
     * }
     */
    public static MemorySegment llama_split_prefix$address() {
        return llama_split_prefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int llama_split_prefix(char *split_prefix, size_t maxlen, const char *split_path, int split_no, int split_count)
     * }
     */
    public static int llama_split_prefix(MemorySegment split_prefix, long maxlen, MemorySegment split_path, int split_no, int split_count) {
        var mh$ = llama_split_prefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_split_prefix", split_prefix, maxlen, split_path, split_no, split_count);
            }
            return (int)mh$.invokeExact(split_prefix, maxlen, split_path, split_no, split_count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_print_system_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_print_system_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *llama_print_system_info(void)
     * }
     */
    public static FunctionDescriptor llama_print_system_info$descriptor() {
        return llama_print_system_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *llama_print_system_info(void)
     * }
     */
    public static MethodHandle llama_print_system_info$handle() {
        return llama_print_system_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *llama_print_system_info(void)
     * }
     */
    public static MemorySegment llama_print_system_info$address() {
        return llama_print_system_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *llama_print_system_info(void)
     * }
     */
    public static MemorySegment llama_print_system_info() {
        var mh$ = llama_print_system_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_print_system_info");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_log_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_log_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_log_set(ggml_log_callback log_callback, void *user_data)
     * }
     */
    public static FunctionDescriptor llama_log_set$descriptor() {
        return llama_log_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_log_set(ggml_log_callback log_callback, void *user_data)
     * }
     */
    public static MethodHandle llama_log_set$handle() {
        return llama_log_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_log_set(ggml_log_callback log_callback, void *user_data)
     * }
     */
    public static MemorySegment llama_log_set$address() {
        return llama_log_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_log_set(ggml_log_callback log_callback, void *user_data)
     * }
     */
    public static void llama_log_set(MemorySegment log_callback, MemorySegment user_data) {
        var mh$ = llama_log_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_log_set", log_callback, user_data);
            }
            mh$.invokeExact(log_callback, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_perf_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_perf_context_data.layout(),
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_perf_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_perf_context_data llama_perf_context(const struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_perf_context$descriptor() {
        return llama_perf_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_perf_context_data llama_perf_context(const struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_perf_context$handle() {
        return llama_perf_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_perf_context_data llama_perf_context(const struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_perf_context$address() {
        return llama_perf_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_perf_context_data llama_perf_context(const struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_perf_context(SegmentAllocator allocator, MemorySegment ctx) {
        var mh$ = llama_perf_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_perf_context", allocator, ctx);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_perf_context_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_perf_context_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_perf_context_print(const struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_perf_context_print$descriptor() {
        return llama_perf_context_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_perf_context_print(const struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_perf_context_print$handle() {
        return llama_perf_context_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_perf_context_print(const struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_perf_context_print$address() {
        return llama_perf_context_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_perf_context_print(const struct llama_context *ctx)
     * }
     */
    public static void llama_perf_context_print(MemorySegment ctx) {
        var mh$ = llama_perf_context_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_perf_context_print", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_perf_context_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_perf_context_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_perf_context_reset(struct llama_context *ctx)
     * }
     */
    public static FunctionDescriptor llama_perf_context_reset$descriptor() {
        return llama_perf_context_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_perf_context_reset(struct llama_context *ctx)
     * }
     */
    public static MethodHandle llama_perf_context_reset$handle() {
        return llama_perf_context_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_perf_context_reset(struct llama_context *ctx)
     * }
     */
    public static MemorySegment llama_perf_context_reset$address() {
        return llama_perf_context_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_perf_context_reset(struct llama_context *ctx)
     * }
     */
    public static void llama_perf_context_reset(MemorySegment ctx) {
        var mh$ = llama_perf_context_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_perf_context_reset", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_perf_sampler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_perf_sampler_data.layout(),
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_perf_sampler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct llama_perf_sampler_data llama_perf_sampler(const struct llama_sampler *chain)
     * }
     */
    public static FunctionDescriptor llama_perf_sampler$descriptor() {
        return llama_perf_sampler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct llama_perf_sampler_data llama_perf_sampler(const struct llama_sampler *chain)
     * }
     */
    public static MethodHandle llama_perf_sampler$handle() {
        return llama_perf_sampler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct llama_perf_sampler_data llama_perf_sampler(const struct llama_sampler *chain)
     * }
     */
    public static MemorySegment llama_perf_sampler$address() {
        return llama_perf_sampler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct llama_perf_sampler_data llama_perf_sampler(const struct llama_sampler *chain)
     * }
     */
    public static MemorySegment llama_perf_sampler(SegmentAllocator allocator, MemorySegment chain) {
        var mh$ = llama_perf_sampler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_perf_sampler", allocator, chain);
            }
            return (MemorySegment)mh$.invokeExact(allocator, chain);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_perf_sampler_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_perf_sampler_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_perf_sampler_print(const struct llama_sampler *chain)
     * }
     */
    public static FunctionDescriptor llama_perf_sampler_print$descriptor() {
        return llama_perf_sampler_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_perf_sampler_print(const struct llama_sampler *chain)
     * }
     */
    public static MethodHandle llama_perf_sampler_print$handle() {
        return llama_perf_sampler_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_perf_sampler_print(const struct llama_sampler *chain)
     * }
     */
    public static MemorySegment llama_perf_sampler_print$address() {
        return llama_perf_sampler_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_perf_sampler_print(const struct llama_sampler *chain)
     * }
     */
    public static void llama_perf_sampler_print(MemorySegment chain) {
        var mh$ = llama_perf_sampler_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_perf_sampler_print", chain);
            }
            mh$.invokeExact(chain);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_perf_sampler_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_perf_sampler_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_perf_sampler_reset(struct llama_sampler *chain)
     * }
     */
    public static FunctionDescriptor llama_perf_sampler_reset$descriptor() {
        return llama_perf_sampler_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_perf_sampler_reset(struct llama_sampler *chain)
     * }
     */
    public static MethodHandle llama_perf_sampler_reset$handle() {
        return llama_perf_sampler_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_perf_sampler_reset(struct llama_sampler *chain)
     * }
     */
    public static MemorySegment llama_perf_sampler_reset$address() {
        return llama_perf_sampler_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_perf_sampler_reset(struct llama_sampler *chain)
     * }
     */
    public static void llama_perf_sampler_reset(MemorySegment chain) {
        var mh$ = llama_perf_sampler_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_perf_sampler_reset", chain);
            }
            mh$.invokeExact(chain);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_opt_param_filter_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_opt_param_filter_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * bool llama_opt_param_filter_all(const struct ggml_tensor *tensor, void *userdata)
     * }
     */
    public static FunctionDescriptor llama_opt_param_filter_all$descriptor() {
        return llama_opt_param_filter_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * bool llama_opt_param_filter_all(const struct ggml_tensor *tensor, void *userdata)
     * }
     */
    public static MethodHandle llama_opt_param_filter_all$handle() {
        return llama_opt_param_filter_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * bool llama_opt_param_filter_all(const struct ggml_tensor *tensor, void *userdata)
     * }
     */
    public static MemorySegment llama_opt_param_filter_all$address() {
        return llama_opt_param_filter_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * bool llama_opt_param_filter_all(const struct ggml_tensor *tensor, void *userdata)
     * }
     */
    public static boolean llama_opt_param_filter_all(MemorySegment tensor, MemorySegment userdata) {
        var mh$ = llama_opt_param_filter_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_opt_param_filter_all", tensor, userdata);
            }
            return (boolean)mh$.invokeExact(tensor, userdata);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_opt_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_opt_params.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_opt_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_opt_init(struct llama_context *lctx, struct llama_model *model, struct llama_opt_params lopt_params)
     * }
     */
    public static FunctionDescriptor llama_opt_init$descriptor() {
        return llama_opt_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_opt_init(struct llama_context *lctx, struct llama_model *model, struct llama_opt_params lopt_params)
     * }
     */
    public static MethodHandle llama_opt_init$handle() {
        return llama_opt_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_opt_init(struct llama_context *lctx, struct llama_model *model, struct llama_opt_params lopt_params)
     * }
     */
    public static MemorySegment llama_opt_init$address() {
        return llama_opt_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_opt_init(struct llama_context *lctx, struct llama_model *model, struct llama_opt_params lopt_params)
     * }
     */
    public static void llama_opt_init(MemorySegment lctx, MemorySegment model, MemorySegment lopt_params) {
        var mh$ = llama_opt_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_opt_init", lctx, model, lopt_params);
            }
            mh$.invokeExact(lctx, model, lopt_params);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llama_opt_epoch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_POINTER,
            llama_h.C_LONG_LONG,
            llama_h.C_POINTER,
            llama_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llama_opt_epoch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void llama_opt_epoch(struct llama_context *lctx, ggml_opt_dataset_t dataset, ggml_opt_result_t result_train, ggml_opt_result_t result_eval, int64_t idata_split, ggml_opt_epoch_callback callback_train, ggml_opt_epoch_callback callback_eval)
     * }
     */
    public static FunctionDescriptor llama_opt_epoch$descriptor() {
        return llama_opt_epoch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void llama_opt_epoch(struct llama_context *lctx, ggml_opt_dataset_t dataset, ggml_opt_result_t result_train, ggml_opt_result_t result_eval, int64_t idata_split, ggml_opt_epoch_callback callback_train, ggml_opt_epoch_callback callback_eval)
     * }
     */
    public static MethodHandle llama_opt_epoch$handle() {
        return llama_opt_epoch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void llama_opt_epoch(struct llama_context *lctx, ggml_opt_dataset_t dataset, ggml_opt_result_t result_train, ggml_opt_result_t result_eval, int64_t idata_split, ggml_opt_epoch_callback callback_train, ggml_opt_epoch_callback callback_eval)
     * }
     */
    public static MemorySegment llama_opt_epoch$address() {
        return llama_opt_epoch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void llama_opt_epoch(struct llama_context *lctx, ggml_opt_dataset_t dataset, ggml_opt_result_t result_train, ggml_opt_result_t result_eval, int64_t idata_split, ggml_opt_epoch_callback callback_train, ggml_opt_epoch_callback callback_eval)
     * }
     */
    public static void llama_opt_epoch(MemorySegment lctx, MemorySegment dataset, MemorySegment result_train, MemorySegment result_eval, long idata_split, MemorySegment callback_train, MemorySegment callback_eval) {
        var mh$ = llama_opt_epoch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llama_opt_epoch", lctx, dataset, result_train, result_eval, idata_split, callback_train, callback_eval);
            }
            mh$.invokeExact(lctx, dataset, result_train, result_eval, idata_split, callback_train, callback_eval);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"
     * }
     */
    public static MemorySegment __DARWIN_SUF_EXTSN() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_EXTSN
                = llama_h.LIBRARY_ARENA.allocateFrom("$DARWIN_EXTSN");
        }
        return Holder.__DARWIN_SUF_EXTSN;
    }
    private static final long __DARWIN_C_ANSI = 4096L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_ANSI 4096
     * }
     */
    public static long __DARWIN_C_ANSI() {
        return __DARWIN_C_ANSI;
    }
    private static final long __DARWIN_C_FULL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_FULL 900000
     * }
     */
    public static long __DARWIN_C_FULL() {
        return __DARWIN_C_FULL;
    }
    private static final long __DARWIN_C_LEVEL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_LEVEL 900000
     * }
     */
    public static long __DARWIN_C_LEVEL() {
        return __DARWIN_C_LEVEL;
    }
    private static final MemorySegment __DARWIN_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NULL (void*) 0
     * }
     */
    public static MemorySegment __DARWIN_NULL() {
        return __DARWIN_NULL;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final int INT_FAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -32768
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final int INT_FAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final int INT_FAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 32767
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final int INT_FAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final int UINT_FAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 65535
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final int UINT_FAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WINT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN -2147483648
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 2147483647
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final int MAC_OS_X_VERSION_10_0 = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_0 1000
     * }
     */
    public static int MAC_OS_X_VERSION_10_0() {
        return MAC_OS_X_VERSION_10_0;
    }
    private static final int MAC_OS_X_VERSION_10_1 = (int)1010L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_1 1010
     * }
     */
    public static int MAC_OS_X_VERSION_10_1() {
        return MAC_OS_X_VERSION_10_1;
    }
    private static final int MAC_OS_X_VERSION_10_2 = (int)1020L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_2 1020
     * }
     */
    public static int MAC_OS_X_VERSION_10_2() {
        return MAC_OS_X_VERSION_10_2;
    }
    private static final int MAC_OS_X_VERSION_10_3 = (int)1030L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_3 1030
     * }
     */
    public static int MAC_OS_X_VERSION_10_3() {
        return MAC_OS_X_VERSION_10_3;
    }
    private static final int MAC_OS_X_VERSION_10_4 = (int)1040L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_4 1040
     * }
     */
    public static int MAC_OS_X_VERSION_10_4() {
        return MAC_OS_X_VERSION_10_4;
    }
    private static final int MAC_OS_X_VERSION_10_5 = (int)1050L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_5 1050
     * }
     */
    public static int MAC_OS_X_VERSION_10_5() {
        return MAC_OS_X_VERSION_10_5;
    }
    private static final int MAC_OS_X_VERSION_10_6 = (int)1060L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_6 1060
     * }
     */
    public static int MAC_OS_X_VERSION_10_6() {
        return MAC_OS_X_VERSION_10_6;
    }
    private static final int MAC_OS_X_VERSION_10_7 = (int)1070L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_7 1070
     * }
     */
    public static int MAC_OS_X_VERSION_10_7() {
        return MAC_OS_X_VERSION_10_7;
    }
    private static final int MAC_OS_X_VERSION_10_8 = (int)1080L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_8 1080
     * }
     */
    public static int MAC_OS_X_VERSION_10_8() {
        return MAC_OS_X_VERSION_10_8;
    }
    private static final int MAC_OS_X_VERSION_10_9 = (int)1090L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_9 1090
     * }
     */
    public static int MAC_OS_X_VERSION_10_9() {
        return MAC_OS_X_VERSION_10_9;
    }
    private static final int MAC_OS_X_VERSION_10_10 = (int)101000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10 101000
     * }
     */
    public static int MAC_OS_X_VERSION_10_10() {
        return MAC_OS_X_VERSION_10_10;
    }
    private static final int MAC_OS_X_VERSION_10_10_2 = (int)101002L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_2 101002
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_2() {
        return MAC_OS_X_VERSION_10_10_2;
    }
    private static final int MAC_OS_X_VERSION_10_10_3 = (int)101003L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_3 101003
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_3() {
        return MAC_OS_X_VERSION_10_10_3;
    }
    private static final int MAC_OS_X_VERSION_10_11 = (int)101100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11 101100
     * }
     */
    public static int MAC_OS_X_VERSION_10_11() {
        return MAC_OS_X_VERSION_10_11;
    }
    private static final int MAC_OS_X_VERSION_10_11_2 = (int)101102L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_2 101102
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_2() {
        return MAC_OS_X_VERSION_10_11_2;
    }
    private static final int MAC_OS_X_VERSION_10_11_3 = (int)101103L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_3 101103
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_3() {
        return MAC_OS_X_VERSION_10_11_3;
    }
    private static final int MAC_OS_X_VERSION_10_11_4 = (int)101104L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_4 101104
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_4() {
        return MAC_OS_X_VERSION_10_11_4;
    }
    private static final int MAC_OS_X_VERSION_10_12 = (int)101200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12 101200
     * }
     */
    public static int MAC_OS_X_VERSION_10_12() {
        return MAC_OS_X_VERSION_10_12;
    }
    private static final int MAC_OS_X_VERSION_10_12_1 = (int)101201L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_1 101201
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_1() {
        return MAC_OS_X_VERSION_10_12_1;
    }
    private static final int MAC_OS_X_VERSION_10_12_2 = (int)101202L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_2 101202
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_2() {
        return MAC_OS_X_VERSION_10_12_2;
    }
    private static final int MAC_OS_X_VERSION_10_12_4 = (int)101204L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_4 101204
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_4() {
        return MAC_OS_X_VERSION_10_12_4;
    }
    private static final int MAC_OS_X_VERSION_10_13 = (int)101300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13 101300
     * }
     */
    public static int MAC_OS_X_VERSION_10_13() {
        return MAC_OS_X_VERSION_10_13;
    }
    private static final int MAC_OS_X_VERSION_10_13_1 = (int)101301L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_1 101301
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_1() {
        return MAC_OS_X_VERSION_10_13_1;
    }
    private static final int MAC_OS_X_VERSION_10_13_2 = (int)101302L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_2 101302
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_2() {
        return MAC_OS_X_VERSION_10_13_2;
    }
    private static final int MAC_OS_X_VERSION_10_13_4 = (int)101304L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_4 101304
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_4() {
        return MAC_OS_X_VERSION_10_13_4;
    }
    private static final int MAC_OS_X_VERSION_10_14 = (int)101400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14 101400
     * }
     */
    public static int MAC_OS_X_VERSION_10_14() {
        return MAC_OS_X_VERSION_10_14;
    }
    private static final int MAC_OS_X_VERSION_10_14_1 = (int)101401L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_1 101401
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_1() {
        return MAC_OS_X_VERSION_10_14_1;
    }
    private static final int MAC_OS_X_VERSION_10_14_4 = (int)101404L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_4 101404
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_4() {
        return MAC_OS_X_VERSION_10_14_4;
    }
    private static final int MAC_OS_X_VERSION_10_14_5 = (int)101405L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_5 101405
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_5() {
        return MAC_OS_X_VERSION_10_14_5;
    }
    private static final int MAC_OS_X_VERSION_10_14_6 = (int)101406L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_6 101406
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_6() {
        return MAC_OS_X_VERSION_10_14_6;
    }
    private static final int MAC_OS_X_VERSION_10_15 = (int)101500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15 101500
     * }
     */
    public static int MAC_OS_X_VERSION_10_15() {
        return MAC_OS_X_VERSION_10_15;
    }
    private static final int MAC_OS_X_VERSION_10_15_1 = (int)101501L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_1 101501
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_1() {
        return MAC_OS_X_VERSION_10_15_1;
    }
    private static final int MAC_OS_X_VERSION_10_15_4 = (int)101504L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_4 101504
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_4() {
        return MAC_OS_X_VERSION_10_15_4;
    }
    private static final int MAC_OS_X_VERSION_10_16 = (int)101600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_16 101600
     * }
     */
    public static int MAC_OS_X_VERSION_10_16() {
        return MAC_OS_X_VERSION_10_16;
    }
    private static final int MAC_OS_VERSION_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_0 110000
     * }
     */
    public static int MAC_OS_VERSION_11_0() {
        return MAC_OS_VERSION_11_0;
    }
    private static final int MAC_OS_VERSION_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_1 110100
     * }
     */
    public static int MAC_OS_VERSION_11_1() {
        return MAC_OS_VERSION_11_1;
    }
    private static final int MAC_OS_VERSION_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_3 110300
     * }
     */
    public static int MAC_OS_VERSION_11_3() {
        return MAC_OS_VERSION_11_3;
    }
    private static final int MAC_OS_VERSION_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_4 110400
     * }
     */
    public static int MAC_OS_VERSION_11_4() {
        return MAC_OS_VERSION_11_4;
    }
    private static final int MAC_OS_VERSION_11_5 = (int)110500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_5 110500
     * }
     */
    public static int MAC_OS_VERSION_11_5() {
        return MAC_OS_VERSION_11_5;
    }
    private static final int MAC_OS_VERSION_11_6 = (int)110600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_6 110600
     * }
     */
    public static int MAC_OS_VERSION_11_6() {
        return MAC_OS_VERSION_11_6;
    }
    private static final int MAC_OS_VERSION_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_0 120000
     * }
     */
    public static int MAC_OS_VERSION_12_0() {
        return MAC_OS_VERSION_12_0;
    }
    private static final int MAC_OS_VERSION_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_1 120100
     * }
     */
    public static int MAC_OS_VERSION_12_1() {
        return MAC_OS_VERSION_12_1;
    }
    private static final int MAC_OS_VERSION_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_2 120200
     * }
     */
    public static int MAC_OS_VERSION_12_2() {
        return MAC_OS_VERSION_12_2;
    }
    private static final int MAC_OS_VERSION_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_3 120300
     * }
     */
    public static int MAC_OS_VERSION_12_3() {
        return MAC_OS_VERSION_12_3;
    }
    private static final int MAC_OS_VERSION_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_4 120400
     * }
     */
    public static int MAC_OS_VERSION_12_4() {
        return MAC_OS_VERSION_12_4;
    }
    private static final int MAC_OS_VERSION_12_5 = (int)120500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_5 120500
     * }
     */
    public static int MAC_OS_VERSION_12_5() {
        return MAC_OS_VERSION_12_5;
    }
    private static final int MAC_OS_VERSION_12_6 = (int)120600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_6 120600
     * }
     */
    public static int MAC_OS_VERSION_12_6() {
        return MAC_OS_VERSION_12_6;
    }
    private static final int MAC_OS_VERSION_12_7 = (int)120700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_7 120700
     * }
     */
    public static int MAC_OS_VERSION_12_7() {
        return MAC_OS_VERSION_12_7;
    }
    private static final int MAC_OS_VERSION_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_0 130000
     * }
     */
    public static int MAC_OS_VERSION_13_0() {
        return MAC_OS_VERSION_13_0;
    }
    private static final int MAC_OS_VERSION_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_1 130100
     * }
     */
    public static int MAC_OS_VERSION_13_1() {
        return MAC_OS_VERSION_13_1;
    }
    private static final int MAC_OS_VERSION_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_2 130200
     * }
     */
    public static int MAC_OS_VERSION_13_2() {
        return MAC_OS_VERSION_13_2;
    }
    private static final int MAC_OS_VERSION_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_3 130300
     * }
     */
    public static int MAC_OS_VERSION_13_3() {
        return MAC_OS_VERSION_13_3;
    }
    private static final int MAC_OS_VERSION_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_4 130400
     * }
     */
    public static int MAC_OS_VERSION_13_4() {
        return MAC_OS_VERSION_13_4;
    }
    private static final int MAC_OS_VERSION_13_5 = (int)130500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_5 130500
     * }
     */
    public static int MAC_OS_VERSION_13_5() {
        return MAC_OS_VERSION_13_5;
    }
    private static final int MAC_OS_VERSION_13_6 = (int)130600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_6 130600
     * }
     */
    public static int MAC_OS_VERSION_13_6() {
        return MAC_OS_VERSION_13_6;
    }
    private static final int MAC_OS_VERSION_13_7 = (int)130700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_7 130700
     * }
     */
    public static int MAC_OS_VERSION_13_7() {
        return MAC_OS_VERSION_13_7;
    }
    private static final int MAC_OS_VERSION_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_0 140000
     * }
     */
    public static int MAC_OS_VERSION_14_0() {
        return MAC_OS_VERSION_14_0;
    }
    private static final int MAC_OS_VERSION_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_1 140100
     * }
     */
    public static int MAC_OS_VERSION_14_1() {
        return MAC_OS_VERSION_14_1;
    }
    private static final int MAC_OS_VERSION_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_2 140200
     * }
     */
    public static int MAC_OS_VERSION_14_2() {
        return MAC_OS_VERSION_14_2;
    }
    private static final int MAC_OS_VERSION_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_3 140300
     * }
     */
    public static int MAC_OS_VERSION_14_3() {
        return MAC_OS_VERSION_14_3;
    }
    private static final int MAC_OS_VERSION_14_4 = (int)140400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_4 140400
     * }
     */
    public static int MAC_OS_VERSION_14_4() {
        return MAC_OS_VERSION_14_4;
    }
    private static final int MAC_OS_VERSION_14_5 = (int)140500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_5 140500
     * }
     */
    public static int MAC_OS_VERSION_14_5() {
        return MAC_OS_VERSION_14_5;
    }
    private static final int MAC_OS_VERSION_14_6 = (int)140600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_6 140600
     * }
     */
    public static int MAC_OS_VERSION_14_6() {
        return MAC_OS_VERSION_14_6;
    }
    private static final int MAC_OS_VERSION_14_7 = (int)140700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_7 140700
     * }
     */
    public static int MAC_OS_VERSION_14_7() {
        return MAC_OS_VERSION_14_7;
    }
    private static final int MAC_OS_VERSION_15_0 = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_0 150000
     * }
     */
    public static int MAC_OS_VERSION_15_0() {
        return MAC_OS_VERSION_15_0;
    }
    private static final int MAC_OS_VERSION_15_1 = (int)150100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_1 150100
     * }
     */
    public static int MAC_OS_VERSION_15_1() {
        return MAC_OS_VERSION_15_1;
    }
    private static final int MAC_OS_VERSION_15_2 = (int)150200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_2 150200
     * }
     */
    public static int MAC_OS_VERSION_15_2() {
        return MAC_OS_VERSION_15_2;
    }
    private static final int MAC_OS_VERSION_15_3 = (int)150300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_3 150300
     * }
     */
    public static int MAC_OS_VERSION_15_3() {
        return MAC_OS_VERSION_15_3;
    }
    private static final int MAC_OS_VERSION_15_4 = (int)150400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_4 150400
     * }
     */
    public static int MAC_OS_VERSION_15_4() {
        return MAC_OS_VERSION_15_4;
    }
    private static final int __AVAILABILITY_VERSIONS_VERSION_HASH = (int)93585900L;
    /**
     * {@snippet lang=c :
     * #define __AVAILABILITY_VERSIONS_VERSION_HASH 93585900
     * }
     */
    public static int __AVAILABILITY_VERSIONS_VERSION_HASH() {
        return __AVAILABILITY_VERSIONS_VERSION_HASH;
    }
    /**
     * {@snippet lang=c :
     * #define __AVAILABILITY_VERSIONS_VERSION_STRING "Local"
     * }
     */
    public static MemorySegment __AVAILABILITY_VERSIONS_VERSION_STRING() {
        class Holder {
            static final MemorySegment __AVAILABILITY_VERSIONS_VERSION_STRING
                = llama_h.LIBRARY_ARENA.allocateFrom("Local");
        }
        return Holder.__AVAILABILITY_VERSIONS_VERSION_STRING;
    }
    /**
     * {@snippet lang=c :
     * #define __AVAILABILITY_FILE "AvailabilityVersions.h"
     * }
     */
    public static MemorySegment __AVAILABILITY_FILE() {
        class Holder {
            static final MemorySegment __AVAILABILITY_FILE
                = llama_h.LIBRARY_ARENA.allocateFrom("AvailabilityVersions.h");
        }
        return Holder.__AVAILABILITY_FILE;
    }
    private static final int __MAC_OS_X_VERSION_MIN_REQUIRED = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_OS_X_VERSION_MIN_REQUIRED 150000
     * }
     */
    public static int __MAC_OS_X_VERSION_MIN_REQUIRED() {
        return __MAC_OS_X_VERSION_MIN_REQUIRED;
    }
    private static final int __MAC_OS_X_VERSION_MAX_ALLOWED = (int)150400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_OS_X_VERSION_MAX_ALLOWED 150400
     * }
     */
    public static int __MAC_OS_X_VERSION_MAX_ALLOWED() {
        return __MAC_OS_X_VERSION_MAX_ALLOWED;
    }
    private static final int __DARWIN_WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MAX 2147483647
     * }
     */
    public static int __DARWIN_WCHAR_MAX() {
        return __DARWIN_WCHAR_MAX;
    }
    private static final int __DARWIN_WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MIN -2147483648
     * }
     */
    public static int __DARWIN_WCHAR_MIN() {
        return __DARWIN_WCHAR_MIN;
    }
    private static final int __DARWIN_WEOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WEOF -1
     * }
     */
    public static int __DARWIN_WEOF() {
        return __DARWIN_WEOF;
    }
    private static final long USER_ADDR_NULL = 0L;
    /**
     * {@snippet lang=c :
     * #define USER_ADDR_NULL 0
     * }
     */
    public static long USER_ADDR_NULL() {
        return USER_ADDR_NULL;
    }
    private static final int EOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define EOF -1
     * }
     */
    public static int EOF() {
        return EOF;
    }
    /**
     * {@snippet lang=c :
     * #define P_tmpdir "/var/tmp/"
     * }
     */
    public static MemorySegment P_tmpdir() {
        class Holder {
            static final MemorySegment P_tmpdir
                = llama_h.LIBRARY_ARENA.allocateFrom("/var/tmp/");
        }
        return Holder.P_tmpdir;
    }
    private static final int GGML_N_TASKS_MAX = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define GGML_N_TASKS_MAX -1
     * }
     */
    public static int GGML_N_TASKS_MAX() {
        return GGML_N_TASKS_MAX;
    }
    private static final int LLAMA_DEFAULT_SEED = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define LLAMA_DEFAULT_SEED 4294967295
     * }
     */
    public static int LLAMA_DEFAULT_SEED() {
        return LLAMA_DEFAULT_SEED;
    }
    private static final int LLAMA_TOKEN_NULL = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define LLAMA_TOKEN_NULL -1
     * }
     */
    public static int LLAMA_TOKEN_NULL() {
        return LLAMA_TOKEN_NULL;
    }
    private static final int LLAMA_FILE_MAGIC_GGLA = (int)1734831201L;
    /**
     * {@snippet lang=c :
     * #define LLAMA_FILE_MAGIC_GGLA 1734831201
     * }
     */
    public static int LLAMA_FILE_MAGIC_GGLA() {
        return LLAMA_FILE_MAGIC_GGLA;
    }
    private static final int LLAMA_FILE_MAGIC_GGSN = (int)1734833006L;
    /**
     * {@snippet lang=c :
     * #define LLAMA_FILE_MAGIC_GGSN 1734833006
     * }
     */
    public static int LLAMA_FILE_MAGIC_GGSN() {
        return LLAMA_FILE_MAGIC_GGSN;
    }
    private static final int LLAMA_FILE_MAGIC_GGSQ = (int)1734833009L;
    /**
     * {@snippet lang=c :
     * #define LLAMA_FILE_MAGIC_GGSQ 1734833009
     * }
     */
    public static int LLAMA_FILE_MAGIC_GGSQ() {
        return LLAMA_FILE_MAGIC_GGSQ;
    }
    private static final int LLAMA_SESSION_MAGIC = (int)1734833006L;
    /**
     * {@snippet lang=c :
     * #define LLAMA_SESSION_MAGIC 1734833006
     * }
     */
    public static int LLAMA_SESSION_MAGIC() {
        return LLAMA_SESSION_MAGIC;
    }
    private static final int LLAMA_STATE_SEQ_MAGIC = (int)1734833009L;
    /**
     * {@snippet lang=c :
     * #define LLAMA_STATE_SEQ_MAGIC 1734833009
     * }
     */
    public static int LLAMA_STATE_SEQ_MAGIC() {
        return LLAMA_STATE_SEQ_MAGIC;
    }
}


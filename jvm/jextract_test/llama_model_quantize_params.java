// Generated by jextract

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct llama_model_quantize_params {
 *     int32_t nthread;
 *     enum llama_ftype ftype;
 *     enum ggml_type output_tensor_type;
 *     enum ggml_type token_embedding_type;
 *     bool allow_requantize;
 *     bool quantize_output_tensor;
 *     bool only_copy;
 *     bool pure;
 *     bool keep_split;
 *     void *imatrix;
 *     void *kv_overrides;
 *     void *tensor_types;
 * }
 * }
 */
public class llama_model_quantize_params {

    llama_model_quantize_params() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        llama_h.C_INT.withName("nthread"),
        llama_h.C_INT.withName("ftype"),
        llama_h.C_INT.withName("output_tensor_type"),
        llama_h.C_INT.withName("token_embedding_type"),
        llama_h.C_BOOL.withName("allow_requantize"),
        llama_h.C_BOOL.withName("quantize_output_tensor"),
        llama_h.C_BOOL.withName("only_copy"),
        llama_h.C_BOOL.withName("pure"),
        llama_h.C_BOOL.withName("keep_split"),
        MemoryLayout.paddingLayout(3),
        llama_h.C_POINTER.withName("imatrix"),
        llama_h.C_POINTER.withName("kv_overrides"),
        llama_h.C_POINTER.withName("tensor_types")
    ).withName("llama_model_quantize_params");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt nthread$LAYOUT = (OfInt)$LAYOUT.select(groupElement("nthread"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int32_t nthread
     * }
     */
    public static final OfInt nthread$layout() {
        return nthread$LAYOUT;
    }

    private static final long nthread$OFFSET = $LAYOUT.byteOffset(groupElement("nthread"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int32_t nthread
     * }
     */
    public static final long nthread$offset() {
        return nthread$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int32_t nthread
     * }
     */
    public static int nthread(MemorySegment struct) {
        return struct.get(nthread$LAYOUT, nthread$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int32_t nthread
     * }
     */
    public static void nthread(MemorySegment struct, int fieldValue) {
        struct.set(nthread$LAYOUT, nthread$OFFSET, fieldValue);
    }

    private static final OfInt ftype$LAYOUT = (OfInt)$LAYOUT.select(groupElement("ftype"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum llama_ftype ftype
     * }
     */
    public static final OfInt ftype$layout() {
        return ftype$LAYOUT;
    }

    private static final long ftype$OFFSET = $LAYOUT.byteOffset(groupElement("ftype"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum llama_ftype ftype
     * }
     */
    public static final long ftype$offset() {
        return ftype$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum llama_ftype ftype
     * }
     */
    public static int ftype(MemorySegment struct) {
        return struct.get(ftype$LAYOUT, ftype$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum llama_ftype ftype
     * }
     */
    public static void ftype(MemorySegment struct, int fieldValue) {
        struct.set(ftype$LAYOUT, ftype$OFFSET, fieldValue);
    }

    private static final OfInt output_tensor_type$LAYOUT = (OfInt)$LAYOUT.select(groupElement("output_tensor_type"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum ggml_type output_tensor_type
     * }
     */
    public static final OfInt output_tensor_type$layout() {
        return output_tensor_type$LAYOUT;
    }

    private static final long output_tensor_type$OFFSET = $LAYOUT.byteOffset(groupElement("output_tensor_type"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum ggml_type output_tensor_type
     * }
     */
    public static final long output_tensor_type$offset() {
        return output_tensor_type$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum ggml_type output_tensor_type
     * }
     */
    public static int output_tensor_type(MemorySegment struct) {
        return struct.get(output_tensor_type$LAYOUT, output_tensor_type$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum ggml_type output_tensor_type
     * }
     */
    public static void output_tensor_type(MemorySegment struct, int fieldValue) {
        struct.set(output_tensor_type$LAYOUT, output_tensor_type$OFFSET, fieldValue);
    }

    private static final OfInt token_embedding_type$LAYOUT = (OfInt)$LAYOUT.select(groupElement("token_embedding_type"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum ggml_type token_embedding_type
     * }
     */
    public static final OfInt token_embedding_type$layout() {
        return token_embedding_type$LAYOUT;
    }

    private static final long token_embedding_type$OFFSET = $LAYOUT.byteOffset(groupElement("token_embedding_type"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum ggml_type token_embedding_type
     * }
     */
    public static final long token_embedding_type$offset() {
        return token_embedding_type$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum ggml_type token_embedding_type
     * }
     */
    public static int token_embedding_type(MemorySegment struct) {
        return struct.get(token_embedding_type$LAYOUT, token_embedding_type$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum ggml_type token_embedding_type
     * }
     */
    public static void token_embedding_type(MemorySegment struct, int fieldValue) {
        struct.set(token_embedding_type$LAYOUT, token_embedding_type$OFFSET, fieldValue);
    }

    private static final OfBoolean allow_requantize$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("allow_requantize"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool allow_requantize
     * }
     */
    public static final OfBoolean allow_requantize$layout() {
        return allow_requantize$LAYOUT;
    }

    private static final long allow_requantize$OFFSET = $LAYOUT.byteOffset(groupElement("allow_requantize"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool allow_requantize
     * }
     */
    public static final long allow_requantize$offset() {
        return allow_requantize$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool allow_requantize
     * }
     */
    public static boolean allow_requantize(MemorySegment struct) {
        return struct.get(allow_requantize$LAYOUT, allow_requantize$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool allow_requantize
     * }
     */
    public static void allow_requantize(MemorySegment struct, boolean fieldValue) {
        struct.set(allow_requantize$LAYOUT, allow_requantize$OFFSET, fieldValue);
    }

    private static final OfBoolean quantize_output_tensor$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("quantize_output_tensor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool quantize_output_tensor
     * }
     */
    public static final OfBoolean quantize_output_tensor$layout() {
        return quantize_output_tensor$LAYOUT;
    }

    private static final long quantize_output_tensor$OFFSET = $LAYOUT.byteOffset(groupElement("quantize_output_tensor"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool quantize_output_tensor
     * }
     */
    public static final long quantize_output_tensor$offset() {
        return quantize_output_tensor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool quantize_output_tensor
     * }
     */
    public static boolean quantize_output_tensor(MemorySegment struct) {
        return struct.get(quantize_output_tensor$LAYOUT, quantize_output_tensor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool quantize_output_tensor
     * }
     */
    public static void quantize_output_tensor(MemorySegment struct, boolean fieldValue) {
        struct.set(quantize_output_tensor$LAYOUT, quantize_output_tensor$OFFSET, fieldValue);
    }

    private static final OfBoolean only_copy$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("only_copy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool only_copy
     * }
     */
    public static final OfBoolean only_copy$layout() {
        return only_copy$LAYOUT;
    }

    private static final long only_copy$OFFSET = $LAYOUT.byteOffset(groupElement("only_copy"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool only_copy
     * }
     */
    public static final long only_copy$offset() {
        return only_copy$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool only_copy
     * }
     */
    public static boolean only_copy(MemorySegment struct) {
        return struct.get(only_copy$LAYOUT, only_copy$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool only_copy
     * }
     */
    public static void only_copy(MemorySegment struct, boolean fieldValue) {
        struct.set(only_copy$LAYOUT, only_copy$OFFSET, fieldValue);
    }

    private static final OfBoolean pure$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("pure"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool pure
     * }
     */
    public static final OfBoolean pure$layout() {
        return pure$LAYOUT;
    }

    private static final long pure$OFFSET = $LAYOUT.byteOffset(groupElement("pure"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool pure
     * }
     */
    public static final long pure$offset() {
        return pure$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool pure
     * }
     */
    public static boolean pure(MemorySegment struct) {
        return struct.get(pure$LAYOUT, pure$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool pure
     * }
     */
    public static void pure(MemorySegment struct, boolean fieldValue) {
        struct.set(pure$LAYOUT, pure$OFFSET, fieldValue);
    }

    private static final OfBoolean keep_split$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("keep_split"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool keep_split
     * }
     */
    public static final OfBoolean keep_split$layout() {
        return keep_split$LAYOUT;
    }

    private static final long keep_split$OFFSET = $LAYOUT.byteOffset(groupElement("keep_split"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool keep_split
     * }
     */
    public static final long keep_split$offset() {
        return keep_split$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool keep_split
     * }
     */
    public static boolean keep_split(MemorySegment struct) {
        return struct.get(keep_split$LAYOUT, keep_split$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool keep_split
     * }
     */
    public static void keep_split(MemorySegment struct, boolean fieldValue) {
        struct.set(keep_split$LAYOUT, keep_split$OFFSET, fieldValue);
    }

    private static final AddressLayout imatrix$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("imatrix"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *imatrix
     * }
     */
    public static final AddressLayout imatrix$layout() {
        return imatrix$LAYOUT;
    }

    private static final long imatrix$OFFSET = $LAYOUT.byteOffset(groupElement("imatrix"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *imatrix
     * }
     */
    public static final long imatrix$offset() {
        return imatrix$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *imatrix
     * }
     */
    public static MemorySegment imatrix(MemorySegment struct) {
        return struct.get(imatrix$LAYOUT, imatrix$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *imatrix
     * }
     */
    public static void imatrix(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(imatrix$LAYOUT, imatrix$OFFSET, fieldValue);
    }

    private static final AddressLayout kv_overrides$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("kv_overrides"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *kv_overrides
     * }
     */
    public static final AddressLayout kv_overrides$layout() {
        return kv_overrides$LAYOUT;
    }

    private static final long kv_overrides$OFFSET = $LAYOUT.byteOffset(groupElement("kv_overrides"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *kv_overrides
     * }
     */
    public static final long kv_overrides$offset() {
        return kv_overrides$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *kv_overrides
     * }
     */
    public static MemorySegment kv_overrides(MemorySegment struct) {
        return struct.get(kv_overrides$LAYOUT, kv_overrides$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *kv_overrides
     * }
     */
    public static void kv_overrides(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(kv_overrides$LAYOUT, kv_overrides$OFFSET, fieldValue);
    }

    private static final AddressLayout tensor_types$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("tensor_types"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *tensor_types
     * }
     */
    public static final AddressLayout tensor_types$layout() {
        return tensor_types$LAYOUT;
    }

    private static final long tensor_types$OFFSET = $LAYOUT.byteOffset(groupElement("tensor_types"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *tensor_types
     * }
     */
    public static final long tensor_types$offset() {
        return tensor_types$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *tensor_types
     * }
     */
    public static MemorySegment tensor_types(MemorySegment struct) {
        return struct.get(tensor_types$LAYOUT, tensor_types$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *tensor_types
     * }
     */
    public static void tensor_types(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(tensor_types$LAYOUT, tensor_types$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}


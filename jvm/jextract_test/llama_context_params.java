// Generated by jextract

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct llama_context_params {
 *     uint32_t n_ctx;
 *     uint32_t n_batch;
 *     uint32_t n_ubatch;
 *     uint32_t n_seq_max;
 *     int32_t n_threads;
 *     int32_t n_threads_batch;
 *     enum llama_rope_scaling_type rope_scaling_type;
 *     enum llama_pooling_type pooling_type;
 *     enum llama_attention_type attention_type;
 *     float rope_freq_base;
 *     float rope_freq_scale;
 *     float yarn_ext_factor;
 *     float yarn_attn_factor;
 *     float yarn_beta_fast;
 *     float yarn_beta_slow;
 *     uint32_t yarn_orig_ctx;
 *     float defrag_thold;
 *     ggml_backend_sched_eval_callback cb_eval;
 *     void *cb_eval_user_data;
 *     enum ggml_type type_k;
 *     enum ggml_type type_v;
 *     ggml_abort_callback abort_callback;
 *     void *abort_callback_data;
 *     bool embeddings;
 *     bool offload_kqv;
 *     bool flash_attn;
 *     bool no_perf;
 *     bool op_offload;
 *     bool swa_full;
 * }
 * }
 */
public class llama_context_params {

    llama_context_params() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        llama_h.C_INT.withName("n_ctx"),
        llama_h.C_INT.withName("n_batch"),
        llama_h.C_INT.withName("n_ubatch"),
        llama_h.C_INT.withName("n_seq_max"),
        llama_h.C_INT.withName("n_threads"),
        llama_h.C_INT.withName("n_threads_batch"),
        llama_h.C_INT.withName("rope_scaling_type"),
        llama_h.C_INT.withName("pooling_type"),
        llama_h.C_INT.withName("attention_type"),
        llama_h.C_FLOAT.withName("rope_freq_base"),
        llama_h.C_FLOAT.withName("rope_freq_scale"),
        llama_h.C_FLOAT.withName("yarn_ext_factor"),
        llama_h.C_FLOAT.withName("yarn_attn_factor"),
        llama_h.C_FLOAT.withName("yarn_beta_fast"),
        llama_h.C_FLOAT.withName("yarn_beta_slow"),
        llama_h.C_INT.withName("yarn_orig_ctx"),
        llama_h.C_FLOAT.withName("defrag_thold"),
        MemoryLayout.paddingLayout(4),
        llama_h.C_POINTER.withName("cb_eval"),
        llama_h.C_POINTER.withName("cb_eval_user_data"),
        llama_h.C_INT.withName("type_k"),
        llama_h.C_INT.withName("type_v"),
        llama_h.C_POINTER.withName("abort_callback"),
        llama_h.C_POINTER.withName("abort_callback_data"),
        llama_h.C_BOOL.withName("embeddings"),
        llama_h.C_BOOL.withName("offload_kqv"),
        llama_h.C_BOOL.withName("flash_attn"),
        llama_h.C_BOOL.withName("no_perf"),
        llama_h.C_BOOL.withName("op_offload"),
        llama_h.C_BOOL.withName("swa_full"),
        MemoryLayout.paddingLayout(2)
    ).withName("llama_context_params");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt n_ctx$LAYOUT = (OfInt)$LAYOUT.select(groupElement("n_ctx"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t n_ctx
     * }
     */
    public static final OfInt n_ctx$layout() {
        return n_ctx$LAYOUT;
    }

    private static final long n_ctx$OFFSET = $LAYOUT.byteOffset(groupElement("n_ctx"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t n_ctx
     * }
     */
    public static final long n_ctx$offset() {
        return n_ctx$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t n_ctx
     * }
     */
    public static int n_ctx(MemorySegment struct) {
        return struct.get(n_ctx$LAYOUT, n_ctx$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t n_ctx
     * }
     */
    public static void n_ctx(MemorySegment struct, int fieldValue) {
        struct.set(n_ctx$LAYOUT, n_ctx$OFFSET, fieldValue);
    }

    private static final OfInt n_batch$LAYOUT = (OfInt)$LAYOUT.select(groupElement("n_batch"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t n_batch
     * }
     */
    public static final OfInt n_batch$layout() {
        return n_batch$LAYOUT;
    }

    private static final long n_batch$OFFSET = $LAYOUT.byteOffset(groupElement("n_batch"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t n_batch
     * }
     */
    public static final long n_batch$offset() {
        return n_batch$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t n_batch
     * }
     */
    public static int n_batch(MemorySegment struct) {
        return struct.get(n_batch$LAYOUT, n_batch$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t n_batch
     * }
     */
    public static void n_batch(MemorySegment struct, int fieldValue) {
        struct.set(n_batch$LAYOUT, n_batch$OFFSET, fieldValue);
    }

    private static final OfInt n_ubatch$LAYOUT = (OfInt)$LAYOUT.select(groupElement("n_ubatch"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t n_ubatch
     * }
     */
    public static final OfInt n_ubatch$layout() {
        return n_ubatch$LAYOUT;
    }

    private static final long n_ubatch$OFFSET = $LAYOUT.byteOffset(groupElement("n_ubatch"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t n_ubatch
     * }
     */
    public static final long n_ubatch$offset() {
        return n_ubatch$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t n_ubatch
     * }
     */
    public static int n_ubatch(MemorySegment struct) {
        return struct.get(n_ubatch$LAYOUT, n_ubatch$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t n_ubatch
     * }
     */
    public static void n_ubatch(MemorySegment struct, int fieldValue) {
        struct.set(n_ubatch$LAYOUT, n_ubatch$OFFSET, fieldValue);
    }

    private static final OfInt n_seq_max$LAYOUT = (OfInt)$LAYOUT.select(groupElement("n_seq_max"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t n_seq_max
     * }
     */
    public static final OfInt n_seq_max$layout() {
        return n_seq_max$LAYOUT;
    }

    private static final long n_seq_max$OFFSET = $LAYOUT.byteOffset(groupElement("n_seq_max"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t n_seq_max
     * }
     */
    public static final long n_seq_max$offset() {
        return n_seq_max$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t n_seq_max
     * }
     */
    public static int n_seq_max(MemorySegment struct) {
        return struct.get(n_seq_max$LAYOUT, n_seq_max$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t n_seq_max
     * }
     */
    public static void n_seq_max(MemorySegment struct, int fieldValue) {
        struct.set(n_seq_max$LAYOUT, n_seq_max$OFFSET, fieldValue);
    }

    private static final OfInt n_threads$LAYOUT = (OfInt)$LAYOUT.select(groupElement("n_threads"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int32_t n_threads
     * }
     */
    public static final OfInt n_threads$layout() {
        return n_threads$LAYOUT;
    }

    private static final long n_threads$OFFSET = $LAYOUT.byteOffset(groupElement("n_threads"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int32_t n_threads
     * }
     */
    public static final long n_threads$offset() {
        return n_threads$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int32_t n_threads
     * }
     */
    public static int n_threads(MemorySegment struct) {
        return struct.get(n_threads$LAYOUT, n_threads$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int32_t n_threads
     * }
     */
    public static void n_threads(MemorySegment struct, int fieldValue) {
        struct.set(n_threads$LAYOUT, n_threads$OFFSET, fieldValue);
    }

    private static final OfInt n_threads_batch$LAYOUT = (OfInt)$LAYOUT.select(groupElement("n_threads_batch"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int32_t n_threads_batch
     * }
     */
    public static final OfInt n_threads_batch$layout() {
        return n_threads_batch$LAYOUT;
    }

    private static final long n_threads_batch$OFFSET = $LAYOUT.byteOffset(groupElement("n_threads_batch"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int32_t n_threads_batch
     * }
     */
    public static final long n_threads_batch$offset() {
        return n_threads_batch$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int32_t n_threads_batch
     * }
     */
    public static int n_threads_batch(MemorySegment struct) {
        return struct.get(n_threads_batch$LAYOUT, n_threads_batch$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int32_t n_threads_batch
     * }
     */
    public static void n_threads_batch(MemorySegment struct, int fieldValue) {
        struct.set(n_threads_batch$LAYOUT, n_threads_batch$OFFSET, fieldValue);
    }

    private static final OfInt rope_scaling_type$LAYOUT = (OfInt)$LAYOUT.select(groupElement("rope_scaling_type"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum llama_rope_scaling_type rope_scaling_type
     * }
     */
    public static final OfInt rope_scaling_type$layout() {
        return rope_scaling_type$LAYOUT;
    }

    private static final long rope_scaling_type$OFFSET = $LAYOUT.byteOffset(groupElement("rope_scaling_type"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum llama_rope_scaling_type rope_scaling_type
     * }
     */
    public static final long rope_scaling_type$offset() {
        return rope_scaling_type$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum llama_rope_scaling_type rope_scaling_type
     * }
     */
    public static int rope_scaling_type(MemorySegment struct) {
        return struct.get(rope_scaling_type$LAYOUT, rope_scaling_type$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum llama_rope_scaling_type rope_scaling_type
     * }
     */
    public static void rope_scaling_type(MemorySegment struct, int fieldValue) {
        struct.set(rope_scaling_type$LAYOUT, rope_scaling_type$OFFSET, fieldValue);
    }

    private static final OfInt pooling_type$LAYOUT = (OfInt)$LAYOUT.select(groupElement("pooling_type"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum llama_pooling_type pooling_type
     * }
     */
    public static final OfInt pooling_type$layout() {
        return pooling_type$LAYOUT;
    }

    private static final long pooling_type$OFFSET = $LAYOUT.byteOffset(groupElement("pooling_type"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum llama_pooling_type pooling_type
     * }
     */
    public static final long pooling_type$offset() {
        return pooling_type$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum llama_pooling_type pooling_type
     * }
     */
    public static int pooling_type(MemorySegment struct) {
        return struct.get(pooling_type$LAYOUT, pooling_type$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum llama_pooling_type pooling_type
     * }
     */
    public static void pooling_type(MemorySegment struct, int fieldValue) {
        struct.set(pooling_type$LAYOUT, pooling_type$OFFSET, fieldValue);
    }

    private static final OfInt attention_type$LAYOUT = (OfInt)$LAYOUT.select(groupElement("attention_type"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum llama_attention_type attention_type
     * }
     */
    public static final OfInt attention_type$layout() {
        return attention_type$LAYOUT;
    }

    private static final long attention_type$OFFSET = $LAYOUT.byteOffset(groupElement("attention_type"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum llama_attention_type attention_type
     * }
     */
    public static final long attention_type$offset() {
        return attention_type$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum llama_attention_type attention_type
     * }
     */
    public static int attention_type(MemorySegment struct) {
        return struct.get(attention_type$LAYOUT, attention_type$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum llama_attention_type attention_type
     * }
     */
    public static void attention_type(MemorySegment struct, int fieldValue) {
        struct.set(attention_type$LAYOUT, attention_type$OFFSET, fieldValue);
    }

    private static final OfFloat rope_freq_base$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("rope_freq_base"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float rope_freq_base
     * }
     */
    public static final OfFloat rope_freq_base$layout() {
        return rope_freq_base$LAYOUT;
    }

    private static final long rope_freq_base$OFFSET = $LAYOUT.byteOffset(groupElement("rope_freq_base"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float rope_freq_base
     * }
     */
    public static final long rope_freq_base$offset() {
        return rope_freq_base$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float rope_freq_base
     * }
     */
    public static float rope_freq_base(MemorySegment struct) {
        return struct.get(rope_freq_base$LAYOUT, rope_freq_base$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float rope_freq_base
     * }
     */
    public static void rope_freq_base(MemorySegment struct, float fieldValue) {
        struct.set(rope_freq_base$LAYOUT, rope_freq_base$OFFSET, fieldValue);
    }

    private static final OfFloat rope_freq_scale$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("rope_freq_scale"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float rope_freq_scale
     * }
     */
    public static final OfFloat rope_freq_scale$layout() {
        return rope_freq_scale$LAYOUT;
    }

    private static final long rope_freq_scale$OFFSET = $LAYOUT.byteOffset(groupElement("rope_freq_scale"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float rope_freq_scale
     * }
     */
    public static final long rope_freq_scale$offset() {
        return rope_freq_scale$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float rope_freq_scale
     * }
     */
    public static float rope_freq_scale(MemorySegment struct) {
        return struct.get(rope_freq_scale$LAYOUT, rope_freq_scale$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float rope_freq_scale
     * }
     */
    public static void rope_freq_scale(MemorySegment struct, float fieldValue) {
        struct.set(rope_freq_scale$LAYOUT, rope_freq_scale$OFFSET, fieldValue);
    }

    private static final OfFloat yarn_ext_factor$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("yarn_ext_factor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float yarn_ext_factor
     * }
     */
    public static final OfFloat yarn_ext_factor$layout() {
        return yarn_ext_factor$LAYOUT;
    }

    private static final long yarn_ext_factor$OFFSET = $LAYOUT.byteOffset(groupElement("yarn_ext_factor"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float yarn_ext_factor
     * }
     */
    public static final long yarn_ext_factor$offset() {
        return yarn_ext_factor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float yarn_ext_factor
     * }
     */
    public static float yarn_ext_factor(MemorySegment struct) {
        return struct.get(yarn_ext_factor$LAYOUT, yarn_ext_factor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float yarn_ext_factor
     * }
     */
    public static void yarn_ext_factor(MemorySegment struct, float fieldValue) {
        struct.set(yarn_ext_factor$LAYOUT, yarn_ext_factor$OFFSET, fieldValue);
    }

    private static final OfFloat yarn_attn_factor$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("yarn_attn_factor"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float yarn_attn_factor
     * }
     */
    public static final OfFloat yarn_attn_factor$layout() {
        return yarn_attn_factor$LAYOUT;
    }

    private static final long yarn_attn_factor$OFFSET = $LAYOUT.byteOffset(groupElement("yarn_attn_factor"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float yarn_attn_factor
     * }
     */
    public static final long yarn_attn_factor$offset() {
        return yarn_attn_factor$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float yarn_attn_factor
     * }
     */
    public static float yarn_attn_factor(MemorySegment struct) {
        return struct.get(yarn_attn_factor$LAYOUT, yarn_attn_factor$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float yarn_attn_factor
     * }
     */
    public static void yarn_attn_factor(MemorySegment struct, float fieldValue) {
        struct.set(yarn_attn_factor$LAYOUT, yarn_attn_factor$OFFSET, fieldValue);
    }

    private static final OfFloat yarn_beta_fast$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("yarn_beta_fast"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float yarn_beta_fast
     * }
     */
    public static final OfFloat yarn_beta_fast$layout() {
        return yarn_beta_fast$LAYOUT;
    }

    private static final long yarn_beta_fast$OFFSET = $LAYOUT.byteOffset(groupElement("yarn_beta_fast"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float yarn_beta_fast
     * }
     */
    public static final long yarn_beta_fast$offset() {
        return yarn_beta_fast$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float yarn_beta_fast
     * }
     */
    public static float yarn_beta_fast(MemorySegment struct) {
        return struct.get(yarn_beta_fast$LAYOUT, yarn_beta_fast$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float yarn_beta_fast
     * }
     */
    public static void yarn_beta_fast(MemorySegment struct, float fieldValue) {
        struct.set(yarn_beta_fast$LAYOUT, yarn_beta_fast$OFFSET, fieldValue);
    }

    private static final OfFloat yarn_beta_slow$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("yarn_beta_slow"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float yarn_beta_slow
     * }
     */
    public static final OfFloat yarn_beta_slow$layout() {
        return yarn_beta_slow$LAYOUT;
    }

    private static final long yarn_beta_slow$OFFSET = $LAYOUT.byteOffset(groupElement("yarn_beta_slow"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float yarn_beta_slow
     * }
     */
    public static final long yarn_beta_slow$offset() {
        return yarn_beta_slow$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float yarn_beta_slow
     * }
     */
    public static float yarn_beta_slow(MemorySegment struct) {
        return struct.get(yarn_beta_slow$LAYOUT, yarn_beta_slow$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float yarn_beta_slow
     * }
     */
    public static void yarn_beta_slow(MemorySegment struct, float fieldValue) {
        struct.set(yarn_beta_slow$LAYOUT, yarn_beta_slow$OFFSET, fieldValue);
    }

    private static final OfInt yarn_orig_ctx$LAYOUT = (OfInt)$LAYOUT.select(groupElement("yarn_orig_ctx"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * uint32_t yarn_orig_ctx
     * }
     */
    public static final OfInt yarn_orig_ctx$layout() {
        return yarn_orig_ctx$LAYOUT;
    }

    private static final long yarn_orig_ctx$OFFSET = $LAYOUT.byteOffset(groupElement("yarn_orig_ctx"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * uint32_t yarn_orig_ctx
     * }
     */
    public static final long yarn_orig_ctx$offset() {
        return yarn_orig_ctx$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * uint32_t yarn_orig_ctx
     * }
     */
    public static int yarn_orig_ctx(MemorySegment struct) {
        return struct.get(yarn_orig_ctx$LAYOUT, yarn_orig_ctx$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * uint32_t yarn_orig_ctx
     * }
     */
    public static void yarn_orig_ctx(MemorySegment struct, int fieldValue) {
        struct.set(yarn_orig_ctx$LAYOUT, yarn_orig_ctx$OFFSET, fieldValue);
    }

    private static final OfFloat defrag_thold$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("defrag_thold"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float defrag_thold
     * }
     */
    public static final OfFloat defrag_thold$layout() {
        return defrag_thold$LAYOUT;
    }

    private static final long defrag_thold$OFFSET = $LAYOUT.byteOffset(groupElement("defrag_thold"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float defrag_thold
     * }
     */
    public static final long defrag_thold$offset() {
        return defrag_thold$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float defrag_thold
     * }
     */
    public static float defrag_thold(MemorySegment struct) {
        return struct.get(defrag_thold$LAYOUT, defrag_thold$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float defrag_thold
     * }
     */
    public static void defrag_thold(MemorySegment struct, float fieldValue) {
        struct.set(defrag_thold$LAYOUT, defrag_thold$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * ggml_backend_sched_eval_callback cb_eval
     * }
     */
    public final static class cb_eval {

        private cb_eval() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            boolean apply(MemorySegment _x0, boolean _x1, MemorySegment _x2);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER,
            llama_h.C_BOOL,
            llama_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = llama_h.upcallHandle(cb_eval.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(cb_eval.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static boolean invoke(MemorySegment funcPtr, MemorySegment _x0, boolean _x1, MemorySegment _x2) {
            try {
                return (boolean) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout cb_eval$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("cb_eval"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ggml_backend_sched_eval_callback cb_eval
     * }
     */
    public static final AddressLayout cb_eval$layout() {
        return cb_eval$LAYOUT;
    }

    private static final long cb_eval$OFFSET = $LAYOUT.byteOffset(groupElement("cb_eval"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ggml_backend_sched_eval_callback cb_eval
     * }
     */
    public static final long cb_eval$offset() {
        return cb_eval$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ggml_backend_sched_eval_callback cb_eval
     * }
     */
    public static MemorySegment cb_eval(MemorySegment struct) {
        return struct.get(cb_eval$LAYOUT, cb_eval$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ggml_backend_sched_eval_callback cb_eval
     * }
     */
    public static void cb_eval(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(cb_eval$LAYOUT, cb_eval$OFFSET, fieldValue);
    }

    private static final AddressLayout cb_eval_user_data$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("cb_eval_user_data"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *cb_eval_user_data
     * }
     */
    public static final AddressLayout cb_eval_user_data$layout() {
        return cb_eval_user_data$LAYOUT;
    }

    private static final long cb_eval_user_data$OFFSET = $LAYOUT.byteOffset(groupElement("cb_eval_user_data"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *cb_eval_user_data
     * }
     */
    public static final long cb_eval_user_data$offset() {
        return cb_eval_user_data$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *cb_eval_user_data
     * }
     */
    public static MemorySegment cb_eval_user_data(MemorySegment struct) {
        return struct.get(cb_eval_user_data$LAYOUT, cb_eval_user_data$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *cb_eval_user_data
     * }
     */
    public static void cb_eval_user_data(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(cb_eval_user_data$LAYOUT, cb_eval_user_data$OFFSET, fieldValue);
    }

    private static final OfInt type_k$LAYOUT = (OfInt)$LAYOUT.select(groupElement("type_k"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum ggml_type type_k
     * }
     */
    public static final OfInt type_k$layout() {
        return type_k$LAYOUT;
    }

    private static final long type_k$OFFSET = $LAYOUT.byteOffset(groupElement("type_k"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum ggml_type type_k
     * }
     */
    public static final long type_k$offset() {
        return type_k$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum ggml_type type_k
     * }
     */
    public static int type_k(MemorySegment struct) {
        return struct.get(type_k$LAYOUT, type_k$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum ggml_type type_k
     * }
     */
    public static void type_k(MemorySegment struct, int fieldValue) {
        struct.set(type_k$LAYOUT, type_k$OFFSET, fieldValue);
    }

    private static final OfInt type_v$LAYOUT = (OfInt)$LAYOUT.select(groupElement("type_v"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum ggml_type type_v
     * }
     */
    public static final OfInt type_v$layout() {
        return type_v$LAYOUT;
    }

    private static final long type_v$OFFSET = $LAYOUT.byteOffset(groupElement("type_v"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum ggml_type type_v
     * }
     */
    public static final long type_v$offset() {
        return type_v$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum ggml_type type_v
     * }
     */
    public static int type_v(MemorySegment struct) {
        return struct.get(type_v$LAYOUT, type_v$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum ggml_type type_v
     * }
     */
    public static void type_v(MemorySegment struct, int fieldValue) {
        struct.set(type_v$LAYOUT, type_v$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * ggml_abort_callback abort_callback
     * }
     */
    public final static class abort_callback {

        private abort_callback() {
            // Should not be called directly
        }

        /**
         * The function pointer signature, expressed as a functional interface
         */
        public interface Function {
            boolean apply(MemorySegment _x0);
        }

        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(
            llama_h.C_BOOL,
            llama_h.C_POINTER
        );

        /**
         * The descriptor of this function pointer
         */
        public static FunctionDescriptor descriptor() {
            return $DESC;
        }

        private static final MethodHandle UP$MH = llama_h.upcallHandle(abort_callback.Function.class, "apply", $DESC);

        /**
         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.
         * The lifetime of the returned segment is managed by {@code arena}
         */
        public static MemorySegment allocate(abort_callback.Function fi, Arena arena) {
            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);
        }

        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);

        /**
         * Invoke the upcall stub {@code funcPtr}, with given parameters
         */
        public static boolean invoke(MemorySegment funcPtr, MemorySegment _x0) {
            try {
                return (boolean) DOWN$MH.invokeExact(funcPtr, _x0);
            } catch (Error | RuntimeException ex) {
                throw ex;
            } catch (Throwable ex$) {
                throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static final AddressLayout abort_callback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("abort_callback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ggml_abort_callback abort_callback
     * }
     */
    public static final AddressLayout abort_callback$layout() {
        return abort_callback$LAYOUT;
    }

    private static final long abort_callback$OFFSET = $LAYOUT.byteOffset(groupElement("abort_callback"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ggml_abort_callback abort_callback
     * }
     */
    public static final long abort_callback$offset() {
        return abort_callback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ggml_abort_callback abort_callback
     * }
     */
    public static MemorySegment abort_callback(MemorySegment struct) {
        return struct.get(abort_callback$LAYOUT, abort_callback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ggml_abort_callback abort_callback
     * }
     */
    public static void abort_callback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(abort_callback$LAYOUT, abort_callback$OFFSET, fieldValue);
    }

    private static final AddressLayout abort_callback_data$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("abort_callback_data"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *abort_callback_data
     * }
     */
    public static final AddressLayout abort_callback_data$layout() {
        return abort_callback_data$LAYOUT;
    }

    private static final long abort_callback_data$OFFSET = $LAYOUT.byteOffset(groupElement("abort_callback_data"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *abort_callback_data
     * }
     */
    public static final long abort_callback_data$offset() {
        return abort_callback_data$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *abort_callback_data
     * }
     */
    public static MemorySegment abort_callback_data(MemorySegment struct) {
        return struct.get(abort_callback_data$LAYOUT, abort_callback_data$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *abort_callback_data
     * }
     */
    public static void abort_callback_data(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(abort_callback_data$LAYOUT, abort_callback_data$OFFSET, fieldValue);
    }

    private static final OfBoolean embeddings$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("embeddings"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool embeddings
     * }
     */
    public static final OfBoolean embeddings$layout() {
        return embeddings$LAYOUT;
    }

    private static final long embeddings$OFFSET = $LAYOUT.byteOffset(groupElement("embeddings"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool embeddings
     * }
     */
    public static final long embeddings$offset() {
        return embeddings$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool embeddings
     * }
     */
    public static boolean embeddings(MemorySegment struct) {
        return struct.get(embeddings$LAYOUT, embeddings$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool embeddings
     * }
     */
    public static void embeddings(MemorySegment struct, boolean fieldValue) {
        struct.set(embeddings$LAYOUT, embeddings$OFFSET, fieldValue);
    }

    private static final OfBoolean offload_kqv$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("offload_kqv"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool offload_kqv
     * }
     */
    public static final OfBoolean offload_kqv$layout() {
        return offload_kqv$LAYOUT;
    }

    private static final long offload_kqv$OFFSET = $LAYOUT.byteOffset(groupElement("offload_kqv"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool offload_kqv
     * }
     */
    public static final long offload_kqv$offset() {
        return offload_kqv$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool offload_kqv
     * }
     */
    public static boolean offload_kqv(MemorySegment struct) {
        return struct.get(offload_kqv$LAYOUT, offload_kqv$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool offload_kqv
     * }
     */
    public static void offload_kqv(MemorySegment struct, boolean fieldValue) {
        struct.set(offload_kqv$LAYOUT, offload_kqv$OFFSET, fieldValue);
    }

    private static final OfBoolean flash_attn$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("flash_attn"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool flash_attn
     * }
     */
    public static final OfBoolean flash_attn$layout() {
        return flash_attn$LAYOUT;
    }

    private static final long flash_attn$OFFSET = $LAYOUT.byteOffset(groupElement("flash_attn"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool flash_attn
     * }
     */
    public static final long flash_attn$offset() {
        return flash_attn$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool flash_attn
     * }
     */
    public static boolean flash_attn(MemorySegment struct) {
        return struct.get(flash_attn$LAYOUT, flash_attn$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool flash_attn
     * }
     */
    public static void flash_attn(MemorySegment struct, boolean fieldValue) {
        struct.set(flash_attn$LAYOUT, flash_attn$OFFSET, fieldValue);
    }

    private static final OfBoolean no_perf$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("no_perf"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool no_perf
     * }
     */
    public static final OfBoolean no_perf$layout() {
        return no_perf$LAYOUT;
    }

    private static final long no_perf$OFFSET = $LAYOUT.byteOffset(groupElement("no_perf"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool no_perf
     * }
     */
    public static final long no_perf$offset() {
        return no_perf$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool no_perf
     * }
     */
    public static boolean no_perf(MemorySegment struct) {
        return struct.get(no_perf$LAYOUT, no_perf$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool no_perf
     * }
     */
    public static void no_perf(MemorySegment struct, boolean fieldValue) {
        struct.set(no_perf$LAYOUT, no_perf$OFFSET, fieldValue);
    }

    private static final OfBoolean op_offload$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("op_offload"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool op_offload
     * }
     */
    public static final OfBoolean op_offload$layout() {
        return op_offload$LAYOUT;
    }

    private static final long op_offload$OFFSET = $LAYOUT.byteOffset(groupElement("op_offload"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool op_offload
     * }
     */
    public static final long op_offload$offset() {
        return op_offload$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool op_offload
     * }
     */
    public static boolean op_offload(MemorySegment struct) {
        return struct.get(op_offload$LAYOUT, op_offload$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool op_offload
     * }
     */
    public static void op_offload(MemorySegment struct, boolean fieldValue) {
        struct.set(op_offload$LAYOUT, op_offload$OFFSET, fieldValue);
    }

    private static final OfBoolean swa_full$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("swa_full"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool swa_full
     * }
     */
    public static final OfBoolean swa_full$layout() {
        return swa_full$LAYOUT;
    }

    private static final long swa_full$OFFSET = $LAYOUT.byteOffset(groupElement("swa_full"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool swa_full
     * }
     */
    public static final long swa_full$offset() {
        return swa_full$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool swa_full
     * }
     */
    public static boolean swa_full(MemorySegment struct) {
        return struct.get(swa_full$LAYOUT, swa_full$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool swa_full
     * }
     */
    public static void swa_full(MemorySegment struct, boolean fieldValue) {
        struct.set(swa_full$LAYOUT, swa_full$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

